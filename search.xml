<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[comsol快速入门教程]]></title>
      <url>/2018/05/09/comsol%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>我曾经大三的专业课老师要求全班学习COMSOL！</p>
<p>我自己参照官网的教程，写了个比较通俗易懂的入门教程，字多图多慎看（大三的时候写的）。</p>
<p>教你一步一步做出第一个项目。（其实COMSOL本身不难，主要是其中涉及的物理建模和数理方程的知识是不可或缺的）</p>
<p>扳手受力分析</p>
<p>我们平常用的扳手：如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-a21c048217a6475b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>我们可以通过对它进行模拟分析，熟悉一下comsol的基本操作流程；（这是个简单的力学模拟，不涉及耦合场的模拟，当然，comsol最强大的功能是耦合场模拟，这个我们不急，先看完这个了解一下，具体的耦合场的例子推荐大家去看官方的help文档example2，这个例子也是上面的，相比官方来说，我的首先是中文比较好懂一点，然后解释比较直白通俗）</p>
<p>当然你也可能有些地方不懂，第一是有限元不太知道，第二就是数理方程边界条件不太知道，第三就是我没说明白！！！</p>
<p>本人也是个新手，刚看过三国，就学关公耍大刀了，大家将就着看吧，肯定会有差错，敬请原谅敬请原谅。。。。。</p>
<p>第一部分：</p>
<p>选择基本的研究领域，显然，我们这里研究的是结构力学模块中的固体力学，然后它跟时间无关，所以是稳态的研究。模型当然是选择3D的了。具体步骤有截图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-9166ac5555caf4b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-5adf7d430b251b76.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-85e9500eb514b15a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-8d2ec4730bfb94cf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>完成这四步以后，我们就可以进入comsol 的主界面了！</p>
<p>Ps：这里稍微介绍一下，为什么我们一开始要选择不同的模块和领域，什么力学，电磁学，光学什么的，在于不同模块所需要的偏微分方程和边界条件都是不一样的（请回忆数学物理方程里的三个基本方程和相关的定界问题），comsol为我们预设了不同的微分方程所以我们不需要自己设（当然你可以选择自己设），只要点击相应的模块就行了。这是comsol的一大优势。</p>
<p>第二部分：</p>
<p>下面我们就开始设置相关的条件了。</p>
<p>首先我们要有一个模型，我们研究的是一个扳手，所以我们要有一个扳手的模型，可以自己绘制，这个扳手模型的绘制应该是比较复杂的，只用comsol基本功能可能比较难，可以用CAD软件区绘制，comsol支持CAD文件的导入。</p>
<p>上面扯了一大堆，对于我们来说，第一次就用comsol里面自带的几何模型库吧，正好里面有。我们可以选择导入，具体步骤如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-e89b0d84e3c7d8a3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-815eeb100ad7ab13.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-76e041e9296fd7f3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>上面那个默认的目录是：C:\Program Files\COMSOL\COMSOL44\models\COMSOL_Multiphysics\</p>
<p>Structural_Mechanics\wrench.mphbin</p>
<p>大家根据自己的安装情况不同可以找到它。</p>
<p>这时候，我们就把扳手的模型导入了，大家可以去随便点一点</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-93ca82b39bc3d618.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>这一排的按钮，看一看它们的作用是什么，可以随便点的，点不坏的，不用怕，我就不一一介绍了</p>
<p>下面我们就进行下一步了</p>
<p>模型选定了，接下来我们根据</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-23ddb8cfa0c08e72.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>它上面从上到下的顺序，选择材料属性</p>
<p>我们知道不同的材料的杨氏模量，泊松比是不一样的，所以要确定材料（具体请脑补朝玉大师的弹性力学与张亮分析）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-29f55f0c83631f81.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>大家可能会找不到它，它是在built-in里面的，需要先打开built-in再找。</p>
<p>然后就设置好材料了，大家可以看一看它的具体的数据</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-45ef379a58fd0b98.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>下面我们就进行第三步了，模型有了，材料也搞好了，开始设置边界条件吧！（最关键的一步）</p>
<p>微分方程之前我们选模块的时候就选好了，要解微分方程就看边界条件和初始条件了，这里跟时间无关（此处脑补操老师的数理方程）</p>
<p>扳手的受力，显然我们按住扳手的尾端，也就是在扳手的尾端施加力，扳手的前端是固定的</p>
<p>很明显，扳手的前端是固定端，添加固定边界条件</p>
<p>尾端要加上载荷（这里有问题请参考数理方程）</p>
<p>首先选择固定边界条件</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-6377716b390acf00.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>加在扳手的前端上，变成蓝色说明已经被选定，这一步只要在扳手前端找到如图所示，点击鼠标就行了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-448e7cb89ae9e301.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>以上两步，说明我们给扳手前端加了固定边界条件。</p>
<p>下面一步给扳手加上载荷：</p>
<p>跟上一步一样，左键选择添加边界载荷：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-2c05bd9c2f45355d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>然后我们选定载荷作用的这一部分：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-7df5ffdf2bc76e73.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>选好之后，我们看左边的栏目，添加相应的载荷属性（也就是力的方向和大小）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-2b13fd3894e8c653.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>先选择total force，在写上力就行了，我写的是150，大家可以随便大小，但不要太大（太大，扳手承受不了就。。。。）</p>
<p>这里为什么有负号，因为压扳手的力是朝z轴负方向的。。。。。</p>
<p>到此就全部设置好了！</p>
<p>下面就进行网格化吧（这是有限元方法的基本步骤，不懂的请稍微看看有限元）</p>
<p>当然，目前也不需要你懂什么，稍微点两下就行了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-0f4a0dbe77fc089c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-827bc44c399d02da.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>再点</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-6964c66c1f038bfc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>就行了，。。网格化完毕</p>
<p>这里我们用的是系统自动网格化，我们也可以选择人工的，人工的就要我们自己设置网格的大小，密度什么的。。。。</p>
<p>网格化完了，你的扳手就会变成这样：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-4f03174641bdcfa5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>全部设置都结束了</p>
<p>最后只要轻轻点一下计算就行了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-86b39933387bc137.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>如果你的电脑运行内存小于4g，那很不幸，你可能算不出来，要进行一些额外的步骤（现在4g以下的笔记本应该不多了，如果你是，就来问我吧）</p>
<p>如果你的内存小于4g的话，就请看下面：</p>
<p>没关系，可以用硬盘内存代替运行内存，多几个简单的步骤：</p>
<p>首先，你就不要点计算了，先进行以下步骤</p>
<p>右击</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-fd7e24d140a5c999.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>,选择</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-b8c596aebd5122d7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>，然后展开</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-843e950dd78d53bd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>，变成下面这个样子：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-c57f5ef3efc51ffa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>展开</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-55baeeace2a23c75.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>，并点击</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-d9083afc1bce8ed3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>在右边的设置窗口设置：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-a3b8c9df67e32607.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>跟这个图上设置的一样吧</p>
<p>这个设置确保如果你的电脑运行低内存中计算,解算器将开始使用硬盘作为补充RAM。允许解算器使用硬盘而不是内存计算慢下来。</p>
<p>到此你就设置完了，可以像之前一样，右键</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-d98b6b2dd0c239ac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>，点击计算就行了。</p>
<p>你的内存大于4g就不用管，等它算完吧，可能要一些时间，一两分钟。。。</p>
<p>成功算完之后，你会看到：</p>
<p>是不是很神奇，整个扳手每个地方的受力都显示出来了（如果你的力不是150的话，可能情况跟我不一样。。。。。）</p>
<p>你看到的黑线的部分是扳手形变之前的位置，也就是初始位置。。。。</p>
<p>接下来，你可以稍微设置一下，就可以看到扳手的形变情况或者是受压力的情况。。。。（如果你的力不是150的话，可能情况跟我不一样。。。。。）</p>
<p>后面我就贴步骤，具体不啰嗦了，你基本也知道基本的流程了</p>
<p>这个扳手的建模我实际上是省略的全局定义的那一部分，这一部分在大型的建模过程中是排在第一步的，也就是设定参数，设定变量，设定函数什么的，比如我们就可以事先设定一个参数F来代表载荷，在填载荷的时候就可以直接写F不用写具体数值。。。。。但是我们这个小模型很显然就没必要了。。。。大家先有一个意识</p>
]]></content>
      
        <categories>
            
            <category> comsol </category>
            
        </categories>
        
        
        <tags>
            
            <tag> comsol </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一个故事带你搞懂ASCII,Unicode字符集和UTF-8编码]]></title>
      <url>/2018/05/06/%E4%B8%80%E4%B8%AA%E6%95%85%E4%BA%8B%E5%B8%A6%E4%BD%A0%E6%90%9E%E6%87%82ASCII-Unicode%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8CUTF-8%E7%BC%96%E7%A0%81/</url>
      <content type="html"><![CDATA[<blockquote>
<p>熟悉html等知识的都知道，html中有一个重要的字段叫“content-type”，一般中文网站都是设置为“utf-8”编码，可能你还知道之所以设置为utf-8是为了正常的显示中文，但为什么utf-8就可以作为中文的编码呢？我们常常见到的ASCII码又是什么？Unicode字符集又是什么？它们之间有着什么样的关系呢？要搞清楚这些问题就得弄清楚字符的编码方式和各种常用的字符集。我查阅了一堆中文和外文的文献博客资料，研究了一波发现，有一篇已经不知道作者是谁的中文txt文档讲的绘声绘色，看的我如痴如醉，很好的解释了上述的问题，远比一些英文资料讲的还要清晰。<br><a id="more"></a></p>
</blockquote>
<p>下面分享给大家这篇神文！<br>希望大家可以彻底搞懂相关的字符集和编码的故事</p>
<hr>
<p>随便说说字符集和编码 </p>
<p>快下班时，爱问问题的小朋友Nico又问了一个问题：<br>“sqlserver里面有char和nchar，那个n据说是指unicode的数据，这个是什么意思。”<br>并不是所有简单的问题都很容易回答，就像这个问题一样。于是我答应专门写一篇BLOG来从头讲讲编码的故事。那么就让我们找个草堆坐下，先抽口烟，看看夜晚天空上的银河，然后想一想要从哪里开始讲起。嗯，也许这样开始比较好…… </p>
<p>很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为”字节”。<br>再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机”。 </p>
<p>开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。<br>他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上00x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20以下的字节状态称为”控制码”。<br>他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的”Ascii”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。<br>后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称”扩展字符集”。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！<br>等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。<br>中国人民看到这样很不错，于是就把这种汉字方案叫做 “GB2312”。GB2312 是对 ASCII 的中文扩展。<br>但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。<br>后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。<br>后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。<br>中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “DBCS”（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣们都要每天念下面这个咒语数百遍：<br>“一个汉字算两个英文字符！一个汉字算两个英文字符……” </p>
<p>因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？<br>真是计算机的巴比伦塔命题啊！<br>正在这时，大天使加百列及时出现了——一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “UNICODE”。<br>UNICODE 开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ascii里的那些“半角”字符，UNICODE 包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。<br>这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的strlen函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是的，从 UNICODE 开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的”一个字符”！同时，也都是统一的”两个字节”，请注意”字符”和”字节”两个术语的不同，“字节”是一个8位的物理存贮单元，而“字符”则是一个文化相关的符号。在UNICODE 中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。<br>从前多种字符集存在时，那些做多语言软件的公司遇上过很大麻烦，他们为了在不同的国家销售同一套软件，就不得不在区域化软件时也加持那个双字节字符集咒语，不仅要处处小心不要搞错，还要把软件中的文字在不同的字符集中转来转去。UNICODE 对于他们来说是一个很好的一揽子解决方案，于是从 Windows NT 开始，MS 趁机把它们的操作系统改了一遍，把所有的核心代码都改成了用 UNICODE 方式工作的版本，从这时开始，WINDOWS 系统终于无需要加装各种本土语言系统，就可以显示全世界上所有文化的字符了。<br>但是，UNICODE 在制订时没有考虑与任何一种现有的编码方案保持兼容，这使得 GBK 与UNICODE 在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从UNICODE编码和另一种编码进行转换，这种转换必须通过查表来进行。<br>如前所述，UNICODE 是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符，这大概已经可以覆盖世界上所有文化的符号。如果还不够也没有关系，ISO已经准备了UCS-4方案，说简单了就是四个字节来表示一个字符，这样我们就可以组合出21亿个不同的字符出来（最高位有其他用途），这大概可以用到银河联邦成立那一天吧！ </p>
<p>UNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE 如何在网络上传输也是一个必须考虑的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF8就是每次8个位传输数据，而UTF16就是每次16个位，只不过为了传输时的可靠性，从UNICODE到UTF时并不是直接的对应，而是要过一些算法和规则来转换。<br>受到过网络编程加持的计算机僧侣们都知道，在网络里传递信息时有一个很重要的问题，就是对于数据高低位的解读方式，一些计算机是采用低位先发送的方法，例如我们PC机采用的 INTEL 架构，而另一些是采用高位先发送的方式，在网络中交换数据时，为了核对双方对于高低位的认识是否是一致的，采用了一种很简便的方法，就是在文本流的开始时向对方发送一个标志符——如果之后的文本是高位在位，那就发送”FEFF”，反之，则发送”FFFE”。不信你可以用二进制方式打开一个UTF-X格式的文件，看看开头两个字节是不是这两个字节？ </p>
<p>讲到这里，我们再顺便说说一个很著名的奇怪现象：当你在 windows 的记事本里新建一个文件，输入”联通”两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码！呵呵，有人说这就是联通之所以拼不过移动的原因。<br>其实这是因为GB2312编码与UTF8编码产生了编码冲撞的原因。<br>从网上引来一段从UNICODE到UTF8的转换规则： </p>
<p>Unicode<br>UTF-8 </p>
<p>0000 - 007F<br>0xxxxxxx </p>
<p>0080 - 07FF<br>110xxxxx 10xxxxxx </p>
<p>0800 - FFFF<br>1110xxxx 10xxxxxx 10xxxxxx </p>
<p>例如”汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以要用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 1100 0100 1001，将这个比特流按三字节模板的分段方法分为0110 110001 001001，依次代替模板中的x，得到：1110-0110 10-110001 10-001001，即E6 B1 89，这就是其UTF8的编码。<br>而当你新建一个文本文件时，记事本的编码默认是ANSI, 如果你在ANSI的编码输入汉字，那么他实际就是GB系列的编码方式，在这种编码下，”联通”的内码是：<br>c1 1100 0001<br>aa 1010 1010<br>cd 1100 1101<br>a8 1010 1000<br>注意到了吗？第一二个字节、第三四个字节的起始部分的都是”110”和”10”，正好与UTF8规则里的两字节模板是一致的，于是再次打开记事本时，记事本就误认为这是一个UTF8编码的文件，让我们把第一个字节的110和第二个字节的10去掉，我们就得到了”00001 101010”，再把各位对齐，补上前导的0，就得到了”0000 0000 0110 1010”，不好意思，这是UNICODE的006A，也就是小写的字母”j”，而之后的两字节用UTF8解码之后是0368，这个字符什么也不是。这就是只有”联通”两个字的文件没有办法在记事本里正常显示的原因。<br>而如果你在”联通”之后多输入几个字，其他的字的编码不见得又恰好是110和10开始的字节，这样再次打开时，记事本就不会坚持这是一个utf8编码的文件，而会用ANSI的方式解读之，这时乱码又不出现了。 </p>
<p>好了，终于可以回答NICO的问题了，在数据库里，有n前缀的字串类型就是UNICODE类型，这种类型中，固定用两个字节来表示一个字符，无论这个字符是汉字还是英文字母，或是别的什么。<br>如果你要测试”abc汉字”这个串的长度，在没有n前缀的数据类型里，这个字串是7个字符的长度，因为一个汉字相当于两个字符。而在有n前缀的数据类型里，同样的测试串长度的函数将会告诉你是5个字符，因为一个汉字就是一个字符。 </p>
]]></content>
      
        <categories>
            
            <category> 网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数字签名和数字证书究竟是什么？]]></title>
      <url>/2018/03/04/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>我们经常会见到数字签名和数字证书的身影，比如访问一些不安全的网站时，浏览器会提示，此网站的数字证书不可靠等。那么究竟什么是数字签名和数字证书呢？本文就将通过一个场景深入浅出的介绍数字签名和数字证书的概念！<br><a id="more"></a></p>
<p>Bob有两个密钥，一个叫公钥Public Key，一个叫私钥Private Key。<br><img src="http://upload-images.jianshu.io/upload_images/1234352-563ceae9874bea17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>Bob的公钥是公之于众的，所有需要的人都可以获得公钥，但Bob的私钥是自己私有的。密钥用来加密信息，将一段可以理解阅读的明文信息，用密钥进行加密，变成一段‘乱码’。因此，只有持有正确密钥的人，才能重新将这段加密后的信息，也就是‘乱码’，恢复成可以理解阅读的真实信息。Bob的两个密钥，公钥和私钥都可以将信息进行加密，并且能用对应的密钥将信息解码，也就是说，如果用Bob的公钥将信息加密，那么可以并且只可以用Bob的私钥将信息解码，反之，如果用Bob的私钥将信息加密，那么可以且只可以用Bob的公钥将信息解码！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-d99dff6fb0c4dc62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>所以Bob就可以利用自己的公钥和私钥进行信息的加密传输！</p>
<p>比如，Susan想要和Bob进行通信，考虑到信息的安全性，Susan可以利用Bob公之于众的公钥对所要传输的信息进行加密。这样，Bob收到信息后，就可以用自己的私钥对信息进行解码。假设此时有人窃取了Susan传给Bob的信息，但是由于没有Bob的私钥，无法对信息进行解码，所以即使窃取了信息，也无法阅读理解。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-1b6cea83e7e90135.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>但是虽然黑客们无法解码Susan传给Bob的信息，却可以对信息进行篡改，破坏原有的信息，这样Bob收到被篡改的信息之后，再用自己的私钥进行解码，就会与Susan本来想要传达的信息出现不一致，这样也就相当于破坏了Susan和Bob的信息传输！学术上，我们将这种行为称为破坏信息的完整性！通俗的说，就是我得不到的信息，你也别想得到！</p>
<p>所以，现在的问题就是，我们如何保证信息的完整性，也就是保证信息不被破坏，或者说，当信息被破坏之后，接收方可以识别出，这个时候的信息是被破坏过的，就将其丢弃。</p>
<p>数字签名就可以解决上述的问题！根据数字签名，接收方接收到信息之后，可以判断信息是否被破坏过，如果没有被破坏，就可以正确的解码，如果被破坏，就直接丢弃。</p>
<p>数字签名可以保证对信息的任何篡改都可以被发现，从而保证信息传输过程中的完整性。</p>
<p>那么数字签名是如何实现对完整性保证的呢？关键技术就是hash，也就是哈希技术。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-0c465e48c715f9f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>首先，Bob先对将要传输的信息进行hash，得到一串独一无二的字符，通常把hash之后的内容称为<strong>信息摘要message digest</strong>。我们都知道，hash往往是不可逆的，就是说，我们无法根据hash后的内容推断出hash前的原文。同时，不同的原文，会造成不同的hash结果，并且结果的差异是巨大甚至毫无规律的。也就是说，对原文进行再细微的修改，得到的hash后的内容都会与未经修改的原文的hash内容大相径庭。这样就保证了黑客对原文的任何修改都会被发现！</p>
<p>Bob同时将hash后的信息摘要，用自己的私钥进行加密，这样就保证只有Bob的公钥才能对信息摘要进行正确的解码，这样就保证了信息摘要一定是来自Bob的，也就是起到了一个独一无二的签名的作用。<br>加密后的信息摘要实际就是数字签名的内容。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-6033446c64109a2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>最后，Bob再将数字签名附加到原文信息的后面，这样就形成了一个完整的带数字签名的信息报文。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-09b0248f4ad1e263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>Bob将带数字签名的信息报文传输给Pat。</p>
<p>Pat接收到信息之后，先利用Bob的公钥对数字签名进行解码，得到信息摘要，如果成功解码，就说明数字签名是来自Bob的，因为数字签名是Bob利用自己的私钥进行加密的，只有Bob的公钥可以进行解密。然后，Pat将信息原文进行hash得到自己hash的信息摘要，再与之前解码数字签名得到的信息摘要进行对比，如果相同，就说明原文信息是完整的，没有被篡改，反之，则确认信息被破坏了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-9b50a8ee6c577768.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>似乎现在，利用公钥和私钥以及数字签名，我们可以保证信息传输过程中的私密性和完整性。但还存在一个问题，就是公钥分发的问题，我们如果保证Bob的公钥被正确的分发给了Susan或者Pat等人呢？假设现在有一个中间人，他劫取了Bob发给Pat的公钥，然后私自伪造了一个假的公钥并加上Bob的名字，发给了Pat，这样就导致Pat永远实际上就是在跟中间人通信，和Bob也实际上在跟中间人通信，但都以为在跟对方通信。因此，现在的问题就是，Pat如何确认收到的公钥真的是Bob的公钥，而不是别人伪造的！</p>
<p>这个问题，其实可以类比一下现实生活中的问题。我们知道，公钥和私钥是成对存在的，也就是一个人一般都有一对独有的公钥和私钥。就好像我们每个人都有一个独有的身份证，我们把公钥类比为现实中的身份证，当我们在面对一个陌生人的时候，我们为了信任对方，一般可以查看对方的身份证，但此时就存在一个和上面中间人问题一样的漏洞，就是万一对方给的身份证是一个假的伪造的身份证呢？也就是万一对方给的是一个假的公钥呢？我们怎么识别真伪？现实中，我们往往会有一个身份证真伪的识别器，一般公安局等机构会有，也就是我们可以利用身份证真伪的识别器确认这个身份证的真假。我们仔细思考这个机制，实际上就是引入了一个独立的第三方机制，国家作为一个独立的第三方，给我们每个人创建了一个身份证，当我们需要验证身份证的真伪的时候，我们只需要找这个独立的第三方提供的真伪鉴别服务就可以验证身份证的真伪。</p>
<p>所以，相似的我们解决公钥分发问题的思路也就是引入一个独立的权威的第三方机构。</p>
<p>假设现在有一个数字证书的权威认证中心，这个中心会给Bob创建一个数字证书，这个数字证书包括了Bob的一些信息以及Bob的公钥。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-090832ad686eebfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>那么，此时，想要跟Bob进行通信的人，就可以检查Bob的数字证书，然后向权威的数字证书的认证中心，去认证这是不是真实的Bob的数字证书，如果是，就可以从数字证书中获取到Bob的公钥，然后进行安全的通信。同时，就像现实生活中一样，我们不管进行任何涉及到资金或者安全问题的时候，都需要出示自己的身份证，并且对方会验证你的身份证的真假，也就是说，一个持有假身份证的人，或者没有身份信息的人是获取不了他人的信任的。同理，在网络通信中，如果在数字证书的认证中心中查询不到信息，那么就说明这样的通信方是不安全的，是不值得信任的！另一方面，数字证书除了解决了公钥分发和身份认证的问题，还加强了安全性。</p>
<p>详细的利用数字证书的通信过程如下：</p>
<blockquote>
<p>Bob想要和Pat进行通信，首先就要告知Pat自己的公钥，Bob先向Pat发送自己的数字证书，Pat收到数字证书后，会向权威的数字证书认证中心进行认证，确认是否是Bob的数字证书。（这个认证的过程，实际上也是通过公钥和私钥的机制，Pat会根据数字证书的类别，查找发布这个数字证书的中心的公钥，然后用相应的公钥对证书进行家解码，如果能正确解码则说明这个数字证书确实是此中心颁布的，然后根据解码后的信息验证是否是Bob的数字证书，最后从解码后的信息中，获取Bob的公钥）。<br>然后，Pat可以利用Bob的公钥对Bob的数字签名进行解码，验证是否是Bob的数字签名，如果能正确解码，就说明数字签名是由Bob的私钥进行加密的。然后就进行完整性的验证，将信息原文进行hash，得到信息摘要，并与数字签名解码后得到的信息摘要进行对比，如果一致，就说明信息是完整的没有被篡改的！</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-8287283c2d6640b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>上述的公钥分发和数字签名验证的过程似乎很复杂，但实际上，就跟我们验证身份证真伪一样，我们通常有一个识别器，只要将身份证放上去就可以得到结果，后面的实际过程往往不需要我们关心，网络通信中也是如此，往往会提供一个友好的用户接口，想要验证数字签名或者数字证书，其实就类似于我们点击一下按钮一样简单！</p>
]]></content>
      
        <categories>
            
            <category> 网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入解析Backpropagation反向传播算法]]></title>
      <url>/2018/01/26/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Backpropagation%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><strong>Backpropagation反向传播算法</strong>是神经网络理论中的最基本的算法，也是神经网络能够自主学习的根本原理，也就是神经网络的<strong>“智能”</strong>所在！<br><a id="more"></a><br>所以掌握<strong>Backpropagation反向传播算法</strong>是极其重要的！能帮助我们更好的理解神经网络的本质！然而相关资料却晦涩难懂，或者是没有讲到<strong>Backpropagation反向传播算法</strong>的本质！</p>
<p>其实，<strong>Backpropagation反向传播算法</strong>的本质就是<strong>链式法则</strong> 和 <strong>动态规划</strong>!!!</p>
<p>为了更好的理解<strong>Further into Backpropagation</strong>的本质，我更新了五篇相关的文章，循序渐进，从函数的微分开始，讲到链式法则，然后引入动态规划优化反向传播算法，从单个神经元结构的反向传播计算，到嵌套多个神经元结构的反向传播计算，然后扩展到复杂函数的浅谈神经元结构的计算，从两层神经网络结构的反向传播，到多层神经网络的反向传播，并应用动态规划进行规划！</p>
<p><strong>Backpropagation反向传播算法</strong>系列文章：</p>
<ul>
<li><a href="https://liuchi.coding.me/2018/01/26/Towards-Backpropagation/">Towards-Backpropagation</a> </li>
<li><a href="https://liuchi.coding.me/2018/01/26/Into-Backpropagation/">Into-Backpropagation</a></li>
<li><a href="https://liuchi.coding.me/2018/01/26/Practice-Backpropagation/">Let’s practice Backpropagation</a></li>
<li><a href="https://liuchi.coding.me/2018/01/26/Further-into-Backpropagation/">Further into Backpropagation</a></li>
<li><a href="https://liuchi.coding.me/2018/01/26/Surpass-Backpropagation/">Surpass Backpropagation</a></li>
</ul>
<p>文章相关代码可于<a href="https://github.com/chi2liu/Backpropagation" target="_blank" rel="noopener">Backpropagation</a>下载</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Surpass-Backpropagation]]></title>
      <url>/2018/01/26/Surpass-Backpropagation/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文相关代码可以从<a href="https://github.com/chi2liu/Backpropagation" target="_blank" rel="noopener">Backpropagation</a>下载</p>
</blockquote>
<p>上篇文章<a href="https://liuchi.coding.me/2018/01/26/Further-into-Backpropagation/">Further into Backpropagation</a>中，我们小试牛刀，将反向传播算法运用到了一个两层的神经网络结构中！然后往往实际中的神经网络拥有3层甚至更多层的结构，我们接下来就已一个三层的神经网络结构为例，分析如何运用<strong>动态规划</strong>来优化反向传播时微分的计算！<br><a id="more"></a></p>
<h1 id="Lets-get-started"><a href="#Lets-get-started" class="headerlink" title="Lets get started!!!"></a>Lets get started!!!</h1><p>如下的网络结构：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-6ecc46969fc8492e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>在正式分析神经网络之前，我们先修改一下权重矩阵的表示形式！</p>
<p>让我们以一个符号开始，它代表网络中任意方式的权重信息。我们将使用<br><img src="http://upload-images.jianshu.io/upload_images/1234352-4a7666f84e7dd2cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>来表示从网络第(l−1)层中第k个神经元指向l层中第j个神经元的连接权重。因此举个例子，下图中的权重就表示从第二层中第四个神经元指向第三层中第二个神经元的权重：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-b003e3eff33154aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这个符号起始比较麻烦，的确需要一些努力才能掌握。但是通过努力你会发现它将变得简单和自然。符号中的一个不容易接受的地方就是j和k的位置关系。你可能认为用j来表示输入神经元，k表示输出神经元，而不是实际定义中反过来的方式。我将在下面解释这样做法的原因。</p>
<p>我将使用相似的符号来表示网络中的偏差和激活。明确地，我们使用blj来表示第l层中第j神经元的偏差，用alj来表示第l层中第j神经元的激活。下面的图将展示这些符号：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-15ce5d78c3a10c57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>有了这些符号，第l层中第j神经元的激活alj就与第(l−1)层中所有激活相关。<br><img src="http://upload-images.jianshu.io/upload_images/1234352-fb5beff863cf469a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>能够用漂亮而简洁的向量格式进行重写<br><img src="http://upload-images.jianshu.io/upload_images/1234352-7b8d803c1321a22d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这个表达式能给我们更多的启发，某一层的激活与上一层的激活是有什么关系：我们只是将权重矩阵应用到激活上，然后再加上一个偏差向量，最后应用σ函数!<strong>顺便说一下，这个表达式诱发了前面提到的wljk符号。如果我们使用j来指示输入神经元，k来指示输出神经元，那么我们就需要替换表达式中的权重矩阵 用权重矩阵的转置。虽然这是一个很小的变化，但是烦人的是，我们将失去解释和思考的简单性“应用权重矩阵到激活上。</strong>这个全局视图非常简单和简洁（使用了很少的下标），相对于一个神经元到一个神经元的方式。也可以将其想象成一种避免下标混乱，而且还能保持精确的方法。这个表达式在实际中非常有用，因为许多矩阵库都能提供快速的矩阵乘法，向量加法和向量化。</p>
<p>我们间接的计算<br><img src="http://upload-images.jianshu.io/upload_images/1234352-23188247cc6c2d2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这个值非常有用，我们将zl命名为：网络l层的加权输入。我们将在本章大量的使用加权输入zl。</p>
<h1 id="Hadamard乘积s⊙t"><a href="#Hadamard乘积s⊙t" class="headerlink" title="Hadamard乘积s⊙t"></a>Hadamard乘积s⊙t</h1><p>后向传播算法是基于通用的线性代数运算——就像向量加法，矩阵乘向量等等。但是有一个操作平常很少用到。特别的，假设s和t是相同维数的两个向量，那么我们使用s⊙t来表示两个向量元素级的乘法。<br><img src="http://upload-images.jianshu.io/upload_images/1234352-4c32d4ba9efdfc85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这种元素级的乘法有时叫做 Hadamard乘积或者Schur乘积。我们将把它叫做Hadamard乘积。好的矩阵库一般都能提供Hadamard乘积的快速实施，因此在实施后向传播时候就非常方便。</p>
<p># </p>
<p>根据前面多篇文章所学，我们如果要写出第l层j个神经元的加权输入的微分应该不难，就是链式法则求导，如下：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-eb16ebf1d52d63cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这里我们假设l层是最后一层，那么此时求出了关于加权输入的微分，就可以继续微分求取关于权重的微分<br>根据<br><img src="http://upload-images.jianshu.io/upload_images/1234352-8f1c85d6dbaf92e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>所以，不难求出关于权重的微分<br><img src="http://upload-images.jianshu.io/upload_images/1234352-6b1ccd4fdd963ec2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>好，现在问题来了，如果我们再往前，求倒数第二层的某个权重，思路也是一致的，也就是要从最后一层一直往回算，为了避免公式太长，我们先求关于第l-1层第j个神经元的加权输入的微分<br><img src="http://upload-images.jianshu.io/upload_images/1234352-5502f1b8aa0821ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>然后再根据<br><img src="http://upload-images.jianshu.io/upload_images/1234352-8f1c85d6dbaf92e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>求取权重的微分！</p>
<p>可以看到，只是倒数第二层而已，我们的求取的公式就已经很长了，如果再有个几层，估计就已经爆炸了！</p>
<p>这个时候，就轮到动态规划出场了，动态规划就是在递归的过程中，保存已有的结果，下次计算的时候就不用再算了，可以直接从内存中红取结果。那么我们如何用在这里呢？</p>
<p>仔细观察第l层和l-1层的权重计算公式，我们不难发现，计算第l-1层要经过l层，而在第l-1层中<br><img src="http://upload-images.jianshu.io/upload_images/1234352-95b0c09ab053268f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们发现前面两个微分<br><img src="http://upload-images.jianshu.io/upload_images/1234352-9ac9202e2ff208e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>不就是第l层的关于加权输入的微分么？也就是说，我们在第l层的权重的微分的计算的时候，就已经计算过这个了，然后在第l-1层的计算的时候还要用到这个。所以我们可以考虑，在第l层计算权重的微分的时候，就把这个值保存下来，这样在后续计算的时候就可以直接用了，这就是动态规划的思想！</p>
<p>我们保存每一层的<br><img src="http://upload-images.jianshu.io/upload_images/1234352-1a7d70f5f4b54d93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们给这个值取了个名字叫敏感度矩阵，或者误差矩阵！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-5355dd0512d09ead.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>然后我们根据误差矩阵来进行反向传播，首先不难求出误差矩阵的初始值，也就是最后一层的误差矩阵，前面我们已经计算过，直接替换就行<br><img src="http://upload-images.jianshu.io/upload_images/1234352-195c12e3fef1751f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>然后就是关键的动态规划的递推式，这个其实我们也已经在前面求解出来了，参照前面已经分析得出的<br><img src="http://upload-images.jianshu.io/upload_images/1234352-95b0c09ab053268f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>会发现，相邻两层间误差矩阵的关系就是激活函数的微分和权重，我们将其简化成向量的形式就是<br><img src="http://upload-images.jianshu.io/upload_images/1234352-3073f820640e0119.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>具体的证明如下，也就是链式法则的运用：<br>首先，<br><img src="http://upload-images.jianshu.io/upload_images/1234352-84fe66b46d4eabd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>然后，<br><img src="http://upload-images.jianshu.io/upload_images/1234352-f911a1e197e0ad6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>得到，<br><img src="http://upload-images.jianshu.io/upload_images/1234352-27e8db018a1fc097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>代入，<br><img src="http://upload-images.jianshu.io/upload_images/1234352-3c92ca036b968c7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>至此，一个完美的反向传播算法基本上已经大功告成了！<br>还差最后一丢丢，就是已经有了每一层的敏感度矩阵，也就是每一层关于加权输入的微分，最后再计算我们需要的每一层关于权重和偏置的微分，自然也是手到擒来，直接利用微分求导：<br>关于权重，<br><img src="http://upload-images.jianshu.io/upload_images/1234352-04c6708680eb4e3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>关于偏置，<br><img src="http://upload-images.jianshu.io/upload_images/1234352-38376267d402a404.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="后向传播算法"><a href="#后向传播算法" class="headerlink" title="后向传播算法"></a>后向传播算法</h1><p>后向传播等式给我们提供了一种计算代价函数梯度的方法。让我们用算法显示的写出它们：</p>
<ol>
<li>输入x：为输入层设置对应的激活a1。</li>
<li>向前反馈：对于每一层l=1,2,3…,计算<img src="http://upload-images.jianshu.io/upload_images/1234352-701a80bc8946903c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>和<img src="http://upload-images.jianshu.io/upload_images/1234352-9055b70868884bf6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>输出层误差δL：计算向量<img src="http://upload-images.jianshu.io/upload_images/1234352-005fa777f95d1de4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>后向传播误差：对每一层l=L-1,L-2,…2计算<img src="http://upload-images.jianshu.io/upload_images/1234352-ed1890dd11590e94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>输出：代价函数的梯度为<img src="http://upload-images.jianshu.io/upload_images/1234352-0613836247b0cd52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ol>
<p>检查这个算法，你能看到为什么它被叫作后向传播。我们从最末一层开始向后计算各层误差δl。看起来将网络向后传播很奇怪。但是如果你再想一下后向传播的证明，向后移动就是因为代价是网络输出的函数。为了理解代价是如何跟随早期的权重和偏差进行的改变，我们需要不断的应用链式规则，向后来获取有用的表达式。</p>
<h1 id="随机梯度下降的后向传播算法"><a href="#随机梯度下降的后向传播算法" class="headerlink" title="随机梯度下降的后向传播算法"></a>随机梯度下降的后向传播算法</h1><p>就像我上面描述那样，后向传播算法计算了某一个样本的代价函数的梯度C=Cx。实际上，通用的方式是将后向传播算法与随机梯度下降算法合并，我们便能计算许多训练样本的梯度。特别的，给出一小批训练样本mm，下面算法将基于小批训练样本进行梯度下降学习步骤：</p>
<ol>
<li>输入训练样本集合</li>
<li><p>对于每一个训练样本x： 设置对应的输入激活，执行以下步骤（参照前文的后向传播算法）：</p>
<ul>
<li>向前反馈：对于每一层l=1,2,3…,计算<img src="http://upload-images.jianshu.io/upload_images/1234352-701a80bc8946903c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>和<img src="http://upload-images.jianshu.io/upload_images/1234352-9055b70868884bf6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>输出层误差δL：计算向量<img src="http://upload-images.jianshu.io/upload_images/1234352-005fa777f95d1de4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>后向传播误差：对每一层l=L-1,L-2,…2计算<img src="http://upload-images.jianshu.io/upload_images/1234352-ed1890dd11590e94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ul>
</li>
<li><p>梯度下降：按照更新法则更新权重和偏置<br><img src="http://upload-images.jianshu.io/upload_images/1234352-c45cb9dcc778a5a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-212d2d6887208b92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>当然，为了实施随机梯度下降，你也许要一个外部循环来产生小批量的训练样本，还需要一个外部循环来实施更多的训练代。我们将为了简化暂且忽略掉这些。</p>
<h1 id="后向传播的实施代码"><a href="#后向传播的实施代码" class="headerlink" title="后向传播的实施代码"></a>后向传播的实施代码</h1><p>抽象上理解了后向传播算法，我们就能根据以上算法，实现一个完整的神经网络的后向传播的算法了！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %load network.py</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">network.py</span></span><br><span class="line"><span class="string">~~~~~~~~~~</span></span><br><span class="line"><span class="string">IT WORKS</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">A module to implement the stochastic gradient descent learning</span></span><br><span class="line"><span class="string">algorithm for a feedforward neural network.  Gradients are calculated</span></span><br><span class="line"><span class="string">using backpropagation.  Note that I have focused on making the code</span></span><br><span class="line"><span class="string">simple, easily readable, and easily modifiable.  It is not optimized,</span></span><br><span class="line"><span class="string">and omits many desirable features.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### Libraries</span></span><br><span class="line"><span class="comment"># Standard library</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># Third-party libraries</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Network</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sizes)</span>:</span></span><br><span class="line">        <span class="string">"""The list ``sizes`` contains the number of neurons in the</span></span><br><span class="line"><span class="string">        respective layers of the network.  For example, if the list</span></span><br><span class="line"><span class="string">        was [2, 3, 1] then it would be a three-layer network, with the</span></span><br><span class="line"><span class="string">        first layer containing 2 neurons, the second layer 3 neurons,</span></span><br><span class="line"><span class="string">        and the third layer 1 neuron.  The biases and weights for the</span></span><br><span class="line"><span class="string">        network are initialized randomly, using a Gaussian</span></span><br><span class="line"><span class="string">        distribution with mean 0, and variance 1.  Note that the first</span></span><br><span class="line"><span class="string">        layer is assumed to be an input layer, and by convention we</span></span><br><span class="line"><span class="string">        won't set any biases for those neurons, since biases are only</span></span><br><span class="line"><span class="string">        ever used in computing the outputs from later layers."""</span></span><br><span class="line">        self.num_layers = len(sizes)</span><br><span class="line">        self.sizes = sizes</span><br><span class="line">        self.biases = [np.random.randn(y, <span class="number">1</span>) <span class="keyword">for</span> y <span class="keyword">in</span> sizes[<span class="number">1</span>:]]</span><br><span class="line">        self.weights = [np.random.randn(y, x)</span><br><span class="line">                        <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(sizes[:<span class="number">-1</span>], sizes[<span class="number">1</span>:])]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">feedforward</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        <span class="string">"""Return the output of the network if ``a`` is input."""</span></span><br><span class="line">        <span class="keyword">for</span> b, w <span class="keyword">in</span> zip(self.biases, self.weights):</span><br><span class="line">            a = sigmoid(np.dot(w, a)+b)</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">SGD</span><span class="params">(self, training_data, epochs, mini_batch_size, eta,</span></span></span><br><span class="line"><span class="function"><span class="params">            test_data=None)</span>:</span></span><br><span class="line">        <span class="string">"""Train the neural network using mini-batch stochastic</span></span><br><span class="line"><span class="string">        gradient descent.  The ``training_data`` is a list of tuples</span></span><br><span class="line"><span class="string">        ``(x, y)`` representing the training inputs and the desired</span></span><br><span class="line"><span class="string">        outputs.  The other non-optional parameters are</span></span><br><span class="line"><span class="string">        self-explanatory.  If ``test_data`` is provided then the</span></span><br><span class="line"><span class="string">        network will be evaluated against the test data after each</span></span><br><span class="line"><span class="string">        epoch, and partial progress printed out.  This is useful for</span></span><br><span class="line"><span class="string">        tracking progress, but slows things down substantially."""</span></span><br><span class="line"></span><br><span class="line">        training_data = list(training_data)</span><br><span class="line">        n = len(training_data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> test_data:</span><br><span class="line">            test_data = list(test_data)</span><br><span class="line">            n_test = len(test_data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(epochs):</span><br><span class="line">            random.shuffle(training_data)</span><br><span class="line">            mini_batches = [</span><br><span class="line">                training_data[k:k+mini_batch_size]</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, n, mini_batch_size)]</span><br><span class="line">            <span class="keyword">for</span> mini_batch <span class="keyword">in</span> mini_batches:</span><br><span class="line">                self.update_mini_batch(mini_batch, eta)</span><br><span class="line">            <span class="keyword">if</span> test_data:</span><br><span class="line">                print(<span class="string">"Epoch &#123;&#125; : &#123;&#125; / &#123;&#125;"</span>.format(j,self.evaluate(test_data),n_test));</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"Epoch &#123;&#125; complete"</span>.format(j))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_mini_batch</span><span class="params">(self, mini_batch, eta)</span>:</span></span><br><span class="line">        <span class="string">"""Update the network's weights and biases by applying</span></span><br><span class="line"><span class="string">        gradient descent using backpropagation to a single mini batch.</span></span><br><span class="line"><span class="string">        The ``mini_batch`` is a list of tuples ``(x, y)``, and ``eta``</span></span><br><span class="line"><span class="string">        is the learning rate."""</span></span><br><span class="line">        nabla_b = [np.zeros(b.shape) <span class="keyword">for</span> b <span class="keyword">in</span> self.biases]</span><br><span class="line">        nabla_w = [np.zeros(w.shape) <span class="keyword">for</span> w <span class="keyword">in</span> self.weights]</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> mini_batch:</span><br><span class="line">            delta_nabla_b, delta_nabla_w = self.backprop(x, y)</span><br><span class="line">            nabla_b = [nb+dnb <span class="keyword">for</span> nb, dnb <span class="keyword">in</span> zip(nabla_b, delta_nabla_b)]</span><br><span class="line">            nabla_w = [nw+dnw <span class="keyword">for</span> nw, dnw <span class="keyword">in</span> zip(nabla_w, delta_nabla_w)]</span><br><span class="line">        self.weights = [w-(eta/len(mini_batch))*nw</span><br><span class="line">                        <span class="keyword">for</span> w, nw <span class="keyword">in</span> zip(self.weights, nabla_w)]</span><br><span class="line">        self.biases = [b-(eta/len(mini_batch))*nb</span><br><span class="line">                       <span class="keyword">for</span> b, nb <span class="keyword">in</span> zip(self.biases, nabla_b)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backprop</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="string">"""Return a tuple ``(nabla_b, nabla_w)`` representing the</span></span><br><span class="line"><span class="string">        gradient for the cost function C_x.  ``nabla_b`` and</span></span><br><span class="line"><span class="string">        ``nabla_w`` are layer-by-layer lists of numpy arrays, similar</span></span><br><span class="line"><span class="string">        to ``self.biases`` and ``self.weights``."""</span></span><br><span class="line">        nabla_b = [np.zeros(b.shape) <span class="keyword">for</span> b <span class="keyword">in</span> self.biases]</span><br><span class="line">        nabla_w = [np.zeros(w.shape) <span class="keyword">for</span> w <span class="keyword">in</span> self.weights]</span><br><span class="line">        <span class="comment"># feedforward</span></span><br><span class="line">        activation = x</span><br><span class="line">        activations = [x] <span class="comment"># list to store all the activations, layer by layer</span></span><br><span class="line">        zs = [] <span class="comment"># list to store all the z vectors, layer by layer</span></span><br><span class="line">        <span class="keyword">for</span> b, w <span class="keyword">in</span> zip(self.biases, self.weights):</span><br><span class="line">            z = np.dot(w, activation)+b</span><br><span class="line">            zs.append(z)</span><br><span class="line">            activation = sigmoid(z)</span><br><span class="line">            activations.append(activation)</span><br><span class="line">        <span class="comment"># backward pass</span></span><br><span class="line">        delta = self.cost_derivative(activations[<span class="number">-1</span>], y) * \</span><br><span class="line">            sigmoid_prime(zs[<span class="number">-1</span>])</span><br><span class="line">        nabla_b[<span class="number">-1</span>] = delta</span><br><span class="line">        nabla_w[<span class="number">-1</span>] = np.dot(delta, activations[<span class="number">-2</span>].transpose())</span><br><span class="line">        <span class="comment"># Note that the variable l in the loop below is used a little</span></span><br><span class="line">        <span class="comment"># differently to the notation in Chapter 2 of the book.  Here,</span></span><br><span class="line">        <span class="comment"># l = 1 means the last layer of neurons, l = 2 is the</span></span><br><span class="line">        <span class="comment"># second-last layer, and so on.  It's a renumbering of the</span></span><br><span class="line">        <span class="comment"># scheme in the book, used here to take advantage of the fact</span></span><br><span class="line">        <span class="comment"># that Python can use negative indices in lists.</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">2</span>, self.num_layers):</span><br><span class="line">            z = zs[-l]</span><br><span class="line">            sp = sigmoid_prime(z)</span><br><span class="line">            delta = np.dot(self.weights[-l+<span class="number">1</span>].transpose(), delta) * sp</span><br><span class="line">            nabla_b[-l] = delta</span><br><span class="line">            nabla_w[-l] = np.dot(delta, activations[-l<span class="number">-1</span>].transpose())</span><br><span class="line">        <span class="keyword">return</span> (nabla_b, nabla_w)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span><span class="params">(self, test_data)</span>:</span></span><br><span class="line">        <span class="string">"""Return the number of test inputs for which the neural</span></span><br><span class="line"><span class="string">        network outputs the correct result. Note that the neural</span></span><br><span class="line"><span class="string">        network's output is assumed to be the index of whichever</span></span><br><span class="line"><span class="string">        neuron in the final layer has the highest activation."""</span></span><br><span class="line">        test_results = [(np.argmax(self.feedforward(x)), y)</span><br><span class="line">                        <span class="keyword">for</span> (x, y) <span class="keyword">in</span> test_data]</span><br><span class="line">        <span class="keyword">return</span> sum(int(x == y) <span class="keyword">for</span> (x, y) <span class="keyword">in</span> test_results)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cost_derivative</span><span class="params">(self, output_activations, y)</span>:</span></span><br><span class="line">        <span class="string">"""Return the vector of partial derivatives \partial C_x /</span></span><br><span class="line"><span class="string">        \partial a for the output activations."""</span></span><br><span class="line">        <span class="keyword">return</span> (output_activations-y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#### Miscellaneous functions</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="string">"""The sigmoid function."""</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>/(<span class="number">1.0</span>+np.exp(-z))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid_prime</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="string">"""Derivative of the sigmoid function."""</span></span><br><span class="line">    <span class="keyword">return</span> sigmoid(z)*(<span class="number">1</span>-sigmoid(z))</span><br></pre></td></tr></table></figure>
<p>以上代码实现了一个完整的神经网络的类，里面包括前向传播，结合小批量随机梯度法实现的后向传播，可以直接应用于神经网络问题的求解！</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>终于，我们从微分开始，讲到链式法则，从单个简单的神经元到嵌套神经元，再到两层的神经网络，最后到多层的神经网络，从微分结合链式法则的暴力进行反向传播的计算，到引入动态规划的计算，引入敏感度函数，真正理解了神经网络的反向传播算法！希望能对读者理解神经网络的反向传播有一定的帮助</p>
<h1 id="Further-reading"><a href="#Further-reading" class="headerlink" title="Further reading"></a>Further reading</h1><ul>
<li><a href="http://neuralnetworksanddeeplearning.com/chap2.html" target="_blank" rel="noopener">How the backpropagation algorithm works</a>. </li>
<li><a href="http://numericinsight.com/uploads/A_Gentle_Introduction_to_Backpropagation.pdf" target="_blank" rel="noopener">A_Gentle_Introduction_to_Backpropagation</a>.</li>
<li><a href="https://jasdeep06.github.io/" target="_blank" rel="noopener">jasdeep06</a></li>
</ul>
<blockquote>
<p>本文相关代码可以从<a href="https://github.com/chi2liu/Backpropagation" target="_blank" rel="noopener">Backpropagation</a>下载</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Further-into-Backpropagation]]></title>
      <url>/2018/01/26/Further-into-Backpropagation/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文相关代码可以从<a href="https://github.com/chi2liu/Backpropagation" target="_blank" rel="noopener">Backpropagation</a>下载</p>
</blockquote>
<p>在上一篇文章<a href="https://liuchi.coding.me/2018/01/26/Practice-Backpropagation/">Let’s practice Backpropagation</a>，我们计算了一个带sigmoid函数的嵌套网络的反向传播！从这篇文章开始，我们正式进入实际的神经网络的反向传播！本文将以一个两层的神经网络结构为例子，并且利用矩阵的方法实现神经网络的反向传播训练算法！<br><a id="more"></a></p>
<h1 id="Lets-get-started"><a href="#Lets-get-started" class="headerlink" title="Lets get started!!!"></a>Lets get started!!!</h1><p>神经网络的结构如下:<br><img src="http://upload-images.jianshu.io/upload_images/1234352-805c2ed90410dabd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>上图的神经网络包括两层网络。第一层是输入层，包括三个神经元，第二层也就是输出层，包括了两个神经元。标准的神经网络中，sigmoid层也就是激活函数，是输出层的一部分，这里为了反向传播时计算微分更直观，就将其分开！</p>
<p>对于不了解基本神经网络的同学可以参考,对于不了解激活函数的同学可以参考<a href="https://www.jianshu.com/p/fa8d5ff9321a" target="_blank" rel="noopener">‘神经网络’初探</a></p>
<p>我们下面来分析这个神经网络。首先，三个输入值被输入到输入层的三个节点中，因此我们的输入，用矩阵表示，应该是三维的。然后输入层将和各自的权重相乘，得到输出层，这里和权重的相乘，可以简化成矩阵的乘法运算。然后再输入到sigmoid函数中，进行激活计算，得到一个0-1之间的输出值。最后输出到cost function中，进行误差的计算，这里的cost function可以选取不同的计算函数，这里我们用交叉熵函数作为代价函数， <a href="https://en.wikipedia.org/wiki/Cross_entropy" target="_blank" rel="noopener">cross-entropy</a> 。单纯对于研究反向传播来说，我们都可以不需要知道这些一层层的函数是干嘛的，因为我们反向传播要求的只是微分而已。只要这些函数是可微的，不管结构在复杂，无非是链式求导的时候多求几个微分而已！反向传播的本质就是在微分的计算！</p>
<h1 id="Aim"><a href="#Aim" class="headerlink" title="Aim"></a>Aim</h1><p>误差当然是越小越好，所以我们训练网络的目标是将cost function的值减小，这和我们之前几篇文章将输出结果增加正好是相反的，其实也很简单，只需要在更新的时候，减去步长和微分的乘积就行，将之前的＋变成－！具体可以参考梯度下降法<br>这里我们要更新的是权重的值，所以更新的方法如下：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-ef7736f44014a161.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这里的Wij代表，第i个输入节点到第j的输出节点的权重！<br>只需要求出costfunction关于每个权重的微分即可！</p>
<p>首先，我们自然要先进行正向传播，也就是正向计算最后的输出cost function！</p>
<h1 id="Forward-Propagation"><a href="#Forward-Propagation" class="headerlink" title="Forward Propagation"></a>Forward Propagation</h1><p>首先，我们将输入矩阵化，就是一个1*3的矩阵：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-e1d1d506ede66626.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果我们有多个样本的输入值，比如有n个输入，那么输入矩阵就可以写成n*3的矩阵！</p>
<p>权重矩阵如下：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-16158fe3ed82fe10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>然后输入层到输出层的计算，就可以简化成，两个矩阵的相乘：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-414d1a79091a5d5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>正好得到一个 1x2 的矩阵，对应输出层的两个神经元，符合我们的预期，然后我们给第一个输出层的神经元标记y1，给第二个神经元标记为y2。<br><img src="http://upload-images.jianshu.io/upload_images/1234352-08c4fe1e9b0d6d55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>然后再进行激活函数的计算<br><img src="http://upload-images.jianshu.io/upload_images/1234352-5694958da9ae7bbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>Cost function<br>得到输出层的输出并进行激活函数计算之后，就要输入到cost function中计算errors！。这里我们采用的交叉熵代价函数， <a href="https://en.wikipedia.org/wiki/Cross_entropy" target="_blank" rel="noopener">cross-entropy</a><br><img src="http://upload-images.jianshu.io/upload_images/1234352-03f5c709542f381a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这里p是预期的值，q是我们经过神经网络计算得到的预测值，具体交叉熵函数的意义，可以参考 <a href="https://en.wikipedia.org/wiki/Cross_entropy" target="_blank" rel="noopener">cross-entropy</a><br><img src="http://upload-images.jianshu.io/upload_images/1234352-03f5c709542f381a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>而我们只要知道我们要将C的值降低，利用反向传播算法，降低C的输出，所以我们就要求得C的微分，首先我们把C展开：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-c792a33bd27a0b96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>然后将我们网络中计算得到的输出层的输出带入进去：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-0b33bac34501394d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这样我们就分析完了怎么进行这个神经网络的正向传播！</p>
<h1 id="Backpropagation"><a href="#Backpropagation" class="headerlink" title="Backpropagation"></a>Backpropagation</h1><p>反向传播之前，我们先回顾一下，每一层的输出结果</p>
<p>激活函数层的输出结果<br><img src="http://upload-images.jianshu.io/upload_images/1234352-2918269745cc3a15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>输出层的输出结果<br><img src="http://upload-images.jianshu.io/upload_images/1234352-6d604a74d9bcdad5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>权重矩阵<br><img src="http://upload-images.jianshu.io/upload_images/1234352-3c180556d5158095.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>输入层<br><img src="http://upload-images.jianshu.io/upload_images/1234352-ef9755a816da0eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>明确了每层的值之后，我们要切记，我们反向传播所需的就是关于权重的微分，也就是<br><img src="http://upload-images.jianshu.io/upload_images/1234352-39cadccfed42f59a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>也就是我们要想办法求出C关于各个权重的微分！<br>求微分的基本思路和之前是一样的，不管网络的结构多复杂，根本都是利用链式法则，一层层的从输出求导到输入！这里，我们会采取矩阵的算法来进行微分的求解，这可以让我们的求解方法更适合于编写程序，并且更直观！</p>
<p>首先我们看输出C是关于sigmoid层的输出y0的函数，然后y0又是关于输出层的输出y的函数，y同时又是输入层x与权重相乘而得来的。所以，基本就明确了，我们需要先求取C关于y0的微分，再求取y0关于y的微分，然后求取y关于w的微分，最后又链式法则相乘在一起，就得到了C关于w的微分!</p>
<ul>
<li>首先从cost function到sigmoid layer<br><img src="http://upload-images.jianshu.io/upload_images/1234352-1daa5e1e67a4ea27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ul>
<p>我们可以很容易写出微分：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-add9eb7969a105c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>写成矩阵的形式<br><img src="http://upload-images.jianshu.io/upload_images/1234352-ff92189f032adf5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>从sigmoid层到输出层的微分，就是求取sigmoid函数的微分<br><img src="http://upload-images.jianshu.io/upload_images/1234352-0a7681f0a7ec2a8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ul>
<p>变成矩阵的形式就是：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-02e8d9f499931cb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>从输出层到输入层的微分就是关于权重的微分，我们先看y关于权重的形式<br><img src="http://upload-images.jianshu.io/upload_images/1234352-6d0baad0ae136528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ul>
<p>从这个形式不难得出关于权重的微分就是：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-ec60b99b42037a0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这样我们就可以运用链式法则，求取C关于权重W的微分了：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-5945054e084d2841.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>将每个微分的值带入：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-e3acde23cf4c8cd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>将六个微分全部求取出来就是：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-bbc00f568ca888a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>不难写成矩阵的形式：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-2abf84524833ff50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这里T代表矩阵的转置，X代表矩阵的乘法，圆圈加点代表矩阵对应元素相乘，也就是element-wise product。</p>
<p>最后，我们就可以得到完整的权重更新的法则：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-20352d755d203ea4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>根据以上计算出的更新法则，编写python代码就很直观了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">derivative_sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.multiply(sigmoid(x), (<span class="number">1</span>-sigmoid(x)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># initialization</span></span><br><span class="line"><span class="comment"># X : 1*3</span></span><br><span class="line">X = np.matrix(<span class="string">"2, 4, -2"</span>)</span><br><span class="line"><span class="comment"># W : 3*2</span></span><br><span class="line">W = np.random.normal(size=(<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># label</span></span><br><span class="line">ycap = [<span class="number">0</span>]</span><br><span class="line"><span class="comment"># number of training of examples</span></span><br><span class="line">num_examples = <span class="number">1</span></span><br><span class="line"><span class="comment"># step size</span></span><br><span class="line">h = <span class="number">0.01</span></span><br><span class="line"><span class="comment"># forward-propogation</span></span><br><span class="line">y = np.dot(X, W)</span><br><span class="line">y_o = sigmoid(y)</span><br><span class="line"><span class="comment"># loss calculation</span></span><br><span class="line">loss = -np.sum(np.log(y_o[range(num_examples), ycap]))</span><br><span class="line">print(loss)     <span class="comment"># outputs 3.6821105514(for you it would be different due to random initialization of weights.)</span></span><br><span class="line"><span class="comment"># backprop starts</span></span><br><span class="line">temp1 = np.copy(y_o)</span><br><span class="line"><span class="comment"># implementation of derivative of cost function with respect to y_o</span></span><br><span class="line">temp1[range(num_examples), ycap] = <span class="number">1</span> / -(temp1[range(num_examples), ycap])</span><br><span class="line">temp = np.zeros_like(y_o)</span><br><span class="line">temp[range(num_examples), ycap] = <span class="number">1</span></span><br><span class="line"><span class="comment"># derivative of cost with respect to y_o</span></span><br><span class="line">dcost = np.multiply(temp, temp1)</span><br><span class="line"><span class="comment"># derivative of y_o with respect to y</span></span><br><span class="line">dy_o = derivative_sigmoid(y)</span><br><span class="line"><span class="comment"># element-wise multiplication</span></span><br><span class="line">dgrad = np.multiply(dcost, dy_o)</span><br><span class="line">dw = np.dot(X.T, dgrad)</span><br><span class="line"><span class="comment"># weight-update</span></span><br><span class="line">W -= h * dw</span><br><span class="line"><span class="comment"># forward prop again with updated weight to find new loss</span></span><br><span class="line">y = np.dot(X, W)</span><br><span class="line">yo = sigmoid(y)</span><br><span class="line">loss = -np.sum(np.log(yo[range(num_examples), ycap]))</span><br><span class="line">print(loss)     <span class="comment"># 3.45476397276 outpus (again for you it would be different!)</span></span><br></pre></td></tr></table></figure>
<p>运行程序，就会看到，进行反向传播，C的值也就是代价函数减少了！（由于初始权重是随机生成的，所以每次运行结果就不尽相同，但可以确定的，反向传播后的输出结果相对之前一定是减小的）</p>
<h1 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h1><p>这篇文章将会在此结束！我们已经成功将反向传播的计算扩展到真实的两层的神经网络中，并且将计算过程矩阵化！下一篇<a href="https://liuchi.coding.me/2018/01/26/Surpass-Backpropagation/">Surpass Backpropagation</a>就是反向传播算法的终结篇，将会实现一个多层的神经网络的反向传播，并且运用动态规划算法对反向传播中微分的计算进行优化！</p>
<blockquote>
<p>本文相关代码可以从<a href="https://github.com/chi2liu/Backpropagation" target="_blank" rel="noopener">Backpropagation</a>下载</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Practice-Backpropagation]]></title>
      <url>/2018/01/26/Practice-Backpropagation/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文相关代码可以从<a href="https://github.com/chi2liu/Backpropagation" target="_blank" rel="noopener">Backpropagation</a>下载</p>
</blockquote>
<p>在上一篇文章<a href="https://liuchi.coding.me/2018/01/26/Into-Backpropagation/">Into-Backpropagation</a><br>，我们研究了一个嵌套神经元的反向传播的计算，了解到反向传播本质就是利用链式法则，求取所需要更新的变量的偏导数！但我们前文所研究的神经元是比较简单的，没有复杂的函数，也没有复杂的结构，而真实的神经网络中，往往神经元的函数和结构都比较复杂！<br><a id="more"></a></p>
<p>为了更好的过渡到复杂的神经网络中的反向传播，本文先引入复杂函数，也就是神经网络中最基本的激活函数，并联系如何计算反向传播，为后续进入神经网络的反向传播计算打下坚实的基础！</p>
<h1 id="Lets-get-started"><a href="#Lets-get-started" class="headerlink" title="Lets get started!!!"></a>Lets get started!!!</h1><p>我们将引入神经网络最常见的激活函数sigmoid函数！<br><img src="http://upload-images.jianshu.io/upload_images/1234352-f58b122fadbd679f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-ae375582d596d1af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>实现这个单一神经元很简单<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br><span class="line">a=<span class="number">-2</span></span><br><span class="line">f=sigmoid(a)</span><br><span class="line">print(f) <span class="comment">#outputs 0.1192</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Aim"><a href="#Aim" class="headerlink" title="Aim"></a>Aim</h1><p>接下来依旧是老套路，我们是=试着使输出值增加。首先我们 就要计算Sigmoid的函数的导数，根据微分的法则，我们可以求出<br><img src="http://upload-images.jianshu.io/upload_images/1234352-841bbbdebf77b559.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>然后，就可以得到更新变量的方程：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-8918ed133a024b0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们用python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.</span>/(<span class="number">1</span>+np.exp(-x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">derivative_sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sigmoid(x) * (<span class="number">1</span> - sigmoid(x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = <span class="number">-2</span></span><br><span class="line">h = <span class="number">0.1</span></span><br><span class="line">a = a + h * derivative_sigmoid(a)</span><br><span class="line">f = sigmoid(a)</span><br><span class="line">print(f)  <span class="comment">#outputs 0.1203</span></span><br></pre></td></tr></table></figure></p>
<p>观察输出结果，0.1203比0.1192大.所以我们的算法成功将输出值增加！</p>
<p>现在我们已经知道如何对一个复杂的函数的神经元进行反向传播，从而改变输出值！那么，接下来我们就将复杂函数放到一个嵌套的神经网络结构中，看看如何进行反向传播的计算：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-85b05d75d2be4d79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这个神经网络的结构就是在前文的基础上增加了一个sigmoid函数！我们先用python实现它的正向传播<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addition</span><span class="params">(x,y)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp( -x ))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a=<span class="number">1</span></span><br><span class="line">b=<span class="number">-2</span></span><br><span class="line">c=<span class="number">-3</span></span><br><span class="line">d=addition(a,b)</span><br><span class="line">e=product(c,d)</span><br><span class="line">f=sigmoid(e)</span><br><span class="line">print(f)  <span class="comment">#outputs 0.952574</span></span><br></pre></td></tr></table></figure></p>
<p>现在我们开始计算反向传播，首先很明确的是，要进行反向传播，就得求得所要更新变量的微分：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-a1fcd76aadde8b3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>所以我们需要的计算就是a，b，c三个变量的偏导数！具体的求解规则和前文一样就是倒着从输出往回推，看看经过了哪些神经元的计算，然后利用链式法则：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-a74cc27ab57cb19d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>希望读者能独立推导出上述的公式！</p>
<p>得到上述微分的计算公式，我们就要开始实际计算这些微分值，不难求出<br><img src="http://upload-images.jianshu.io/upload_images/1234352-8a74c0010e4a6b1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果读者对此推导过程依旧有疑问，请重新阅读前两篇文章即能理解！</p>
<p>最后，就是编写程序来实现反向传播了！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addition</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">derivative_sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sigmoid(x) * (<span class="number">1</span> - sigmoid(x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># initialization</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">-2</span></span><br><span class="line">c = <span class="number">-3</span></span><br><span class="line"><span class="comment"># forward-propogation</span></span><br><span class="line">d = addition(a, b)</span><br><span class="line">e = product(c, d)</span><br><span class="line"><span class="comment"># step size</span></span><br><span class="line">h = <span class="number">0.1</span></span><br><span class="line"><span class="comment"># derivatives</span></span><br><span class="line">derivative_f_e = derivative_sigmoid(e)</span><br><span class="line">derivative_e_d = c</span><br><span class="line">derivative_e_c = d</span><br><span class="line">derivative_d_a = <span class="number">1</span></span><br><span class="line">derivative_d_b = <span class="number">1</span></span><br><span class="line"><span class="comment"># backward-propogation (Chain rule)</span></span><br><span class="line">derivative_f_a = derivative_f_e * derivative_e_d * derivative_d_a</span><br><span class="line">derivative_f_b = derivative_f_e * derivative_e_d * derivative_d_b</span><br><span class="line">derivative_f_c = derivative_f_e * derivative_e_c</span><br><span class="line"><span class="comment"># update-parameters</span></span><br><span class="line">a = a + h * derivative_f_a</span><br><span class="line">b = b + h * derivative_f_b</span><br><span class="line">c = c + h * derivative_f_c</span><br><span class="line">d = addition(a, b)</span><br><span class="line">e = product(c, d)</span><br><span class="line">f = sigmoid(e)</span><br><span class="line">print(f)  <span class="comment"># prints 0.9563</span></span><br></pre></td></tr></table></figure>
<p>输出结果是0.9563比0.9525大，可以看到，经过一次反向传播，我们的输出值成功增加！</p>
<p>经过练习，我们可以发现，不管网络多复杂，无非是链式法则求导是复杂一些，只要我们能求出微分，就能进行反向传播！</p>
<h1 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h1><p>我们目前练习的都还是比较简单的网络，但恭喜你已经了解到反向传播的最核心的思想！下一篇文章<a href="https://liuchi.coding.me/2018/01/26/Further-into-Backpropagation/">Further into Backpropagation</a>，我们会正式引入一个真实的神经网络结构，然后进行反向传播的计算！并且利用矩阵来简化计算过程！</p>
<blockquote>
<p>本文相关代码可以从<a href="https://github.com/chi2liu/Backpropagation" target="_blank" rel="noopener">Backpropagation</a>下载</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Into-Backpropagation]]></title>
      <url>/2018/01/26/Into-Backpropagation/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文相关代码可以从<a href="https://github.com/chi2liu/Backpropagation" target="_blank" rel="noopener">Backpropagation</a>下载</p>
</blockquote>
<p>在上一篇文章<a href="https://liuchi.coding.me/2018/01/26/Towards-Backpropagation/">Towards-Backpropagation</a>，我们学习了如何利用函数的微分来更新变量值，是函数值发生相应的变化！<br><a id="more"></a></p>
<p>例如，对于函数<br><img src="http://upload-images.jianshu.io/upload_images/1234352-882774e49c335a5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>我们想要更新变量a，b的值使f的值增加，就可以根据以下公式来更新<br><img src="http://upload-images.jianshu.io/upload_images/1234352-396f377f270f9705.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>实际上这就是反向传播的最基本的思想！我们试想假设f函数是一个代价函数，神经网络的训练就是将代价函数的值变小，那么就是问题就变成了，对于一个代价函数f，我们将改变f的变量，使其f能减小，而f不就是关于每个神经元权重和偏置的函数么，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">接下来，我们就将问题慢慢复杂化，一步一步接近最终的神经网络中的反向传播！</span><br><span class="line"></span><br><span class="line">前文中，我们利用的是一个神经元，这里我们讲问题变复杂，变成两个神经元，并且是有嵌套关系的两个神经元！如下图：</span><br><span class="line">![image.png](http://upload-images.jianshu.io/upload_images/1234352-273f5828e57e5a23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">，将输入值相加然后输出到第二个神经元，同时第二个神经元还接受输入c，并将两个值相乘，最后输出！</span><br><span class="line">这个简单网络的正向传播很容易写出来：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">def product(x, y):</span><br><span class="line">    return x * y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def addition(x, y):</span><br><span class="line">    return x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def forward(a, b, c):</span><br><span class="line">    d = addition(a, b)</span><br><span class="line">    return product(d, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(forward(5, -6, 7))</span><br></pre></td></tr></table></figure></p>
<p>Our aim is still the same as was in last post viz;we want to manipulate the values of our inputs <code>a</code>,<code>b</code>,<code>c</code> in such a way that the value of output <code>f</code>increases.</p>
<p>现在开始我们的训练吧！<br>目标和之前一样，就是改变输入的<code>a</code>,<code>b</code>,<code>c</code>三个值，使函数<code>f</code>的值增加！之后我们就会发现，在这个过程中，我们会慢慢接触到反向传播的核心思想！<br><a href="https://jasdeep06.github.io/posts/towards-backpropagation/" target="_blank" rel="noopener">previous post</a>.</p>
<p>初看上去，这个网络似乎比之前的要复杂，但依照我们前一篇文章提出的思路！我们先看函数f，函数f是一个关于输入a，b，c的函数，想要让函数f的值增加，直接微分即可，然后加上步长与微分的乘积，如下：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-b5e485d95f5fc6eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>所以，核心问题在此就变成怎么求解函数f关于a,b,c的微分！<br>我们不能向之前一个神经元那样直接计算，因为此处的神经元是相互嵌套的。我们将函数f反着往回写！<br>首先，与函数f直接关联的神经元，就是接受两个输入，一个来自第一个神经元的，一个来自输入c，我们把第一个神经元的输出记作d，那么函数f就可以写成<br><img src="http://upload-images.jianshu.io/upload_images/1234352-4279ea44a13d3dc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>然后我们继续反着往前推，对于d，其实就是第一个神经元的输出，也就是可以直接写成：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-90d97ec17a55336f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这样我们就反向的把函数f简化成了两个函数：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-bfb2f672ea298770.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>熟悉微积分的朋友应该就知道，我们在此可以利用函数求微分的链式法则。<br>首先考虑<img src="http://upload-images.jianshu.io/upload_images/1234352-f9b749935144026a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>分别求微分之后，如下：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-83ece3293d14069a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>然后再对<img src="http://upload-images.jianshu.io/upload_images/1234352-9250c41466accab0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">求微分</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-1c0b5a3fcaa715a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>现在我们有四个微分的值：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-ae50b60c2a290659.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们的目标是求取这三个微分的值：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-56635db1c2b14837.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="Backpropagation"><a href="#Backpropagation" class="headerlink" title="Backpropagation"></a>Backpropagation</h1><p>这个时候，就轮到链式法则出场了！<br>链式法则其实就是：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-427860d0177a4586.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如我们所见，链式法则有点代数的特点；因为莱布尼兹的导数符号表明两个分式中的du可以消掉，所以这个公式很好记忆。如果我们将导数看作变化率的话，直观上也很容易理解：</p>
<p><strong>如果y的变化速度是u的a倍，u的变化速度是x的b倍，那么y的变化速度是x的ab倍。</strong></p>
<p><strong>或者用日常用语来说，如果车的速度是自行车的两倍，自行车的速度是步行的四倍，那么车的速度是步行的2⋅4=8倍。</strong></p>
<p>所以此处我们对a，b应用链式法则，就能求取出微分：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-bc418e270f8b6ed6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-139c8ba60ada8f8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>所以最后求出微分就是：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-5fceaa54d1bf466a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>根据以上求出的微分，我们就能很好的写出变量的更新规则：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-59660d107861efa1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们用python实现上面的更新的过程：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addition</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line">    d = addition(a, b)</span><br><span class="line">    <span class="keyword">return</span> product(d, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(forward(<span class="number">5</span>, <span class="number">-6</span>, <span class="number">7</span>))<span class="comment"># output -7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line">    d = addition(a, b)</span><br><span class="line">    h = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line">    derivative_f_d = c</span><br><span class="line">    derivative_f_c = d</span><br><span class="line">    derivative_d_a = <span class="number">1</span></span><br><span class="line">    derivative_d_b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    derivative_f_a = derivative_f_d * derivative_d_a</span><br><span class="line">    derivative_f_b = derivative_f_d * derivative_d_b</span><br><span class="line"></span><br><span class="line">    a = a + h * derivative_f_a</span><br><span class="line">    b = b + h * derivative_f_b</span><br><span class="line">    c = c + h * derivative_f_c</span><br><span class="line"></span><br><span class="line">    d = addition(a, b)</span><br><span class="line">    <span class="keyword">return</span> product(d, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(update(<span class="number">5</span>, <span class="number">-6</span>, <span class="number">7</span>))<span class="comment"># output -6.0113999999999965</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到更新之后的输出确实增大了！说明我们现在已经可以实现嵌套神经元的变量参数的更新了！离真正的反向传播的又近了一步！</p>
<p>Why did it work?</p>
<p>接下来，我们深入整个更新的过程，一步步分析看看究竟更新的本质是什么。首先，我们从输入到输出，分析一遍，前向传播，输入值为a=5,b=-6,c=7，很容易发现，第一个神经元的输出为d为1，然后第二个神经元输出为-7，所以最后结果就是-7!这就是此网络前向传播的过程！</p>
<p>然后我们开始反向传播，从输出开始分析，我们现在的目标是将输出的值增大，输出值是由-1*7得到的，现在要增加输出值，我们先不看微分，显然就是增加-1，减少7，这样就能使他们的乘积变大！我们再来计算微分，微分结果就是增加d的值，减少c的值。我们继续反向推理，这里d的值又是有a，b的值决定的！我们现在的目标又变成了<br>对于第一个神经元，减少输出值，那么很显然，只要减少a和b的值就行了，我们运用链式法则求取a，b的微分，也能得到相同的结果！<br>我们可以看到，当我们反向传播的时候，一个神经元的输入会变成上一个神经元的输出，然后他们之间相互影响，从而使传播下去！</p>
<p>我们倒着从输出分析到输入的过程就是反向传播的过程！我们通过计算微分可以从输出到输入更新变量的值，以使得输出朝着我们期待的方向的变化！</p>
<h1 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h1><p>本文就在这里结束了！本文将前文的更新变量的算法扩展到嵌套的多个神经元中，并应用到了链式法则求微分！而且在这个过程中，其实我们已经逐渐接触到反向传播的基本思想！</p>
<p>下一篇文章<a href="https://liuchi.coding.me/2018/01/26/Practice-Backpropagation/">Let’s practice Backpropagation</a>，我们会将算法应用到一个标准的神经网络中，让我们看看真正的反向传播算法是什么样的！</p>
<blockquote>
<p>本文相关代码可以从<a href="https://github.com/chi2liu/Backpropagation" target="_blank" rel="noopener">Backpropagation</a>下载</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Towards-Backpropagation]]></title>
      <url>/2018/01/26/Towards-Backpropagation/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文相关代码可以从<a href="https://github.com/chi2liu/Backpropagation" target="_blank" rel="noopener">Backpropagation</a>下载</p>
</blockquote>
<p>想要理解backpropagation反向传播算法，就必须先理解<strong>微分</strong>！本文会以一个简单的神经元的例子来讲解backpropagation反向传播算法中的微分的概念。<br><a id="more"></a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-83a3bde1ba80b0b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这是一个非常简单的神经元，如图所示，接收两个输入a， b，然后在神经元内部对两个神经元进行相乘操作，得到a*b的输出！</p>
<p>然后，我们可以想象这样一个情景，现在对于某个特定的输入a，b，输出结果与预期结果相比较小，为了提高准确率，那我们就要将输出结果增加，以更符合预期的结果！</p>
<p>所以，我们现在的目标就是通过改变a，b的值来增加神经元的输出！</p>
<h1 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h1><p>第一个方法是很直观的，我们就随机的给输入a，b的两个值添加一个随机值，然后用一个步长step来控制增加的程度，用python代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span><span class="params">(a, b)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> a * b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">methodOne</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    b = <span class="number">6</span></span><br><span class="line">    step = <span class="number">0.01</span></span><br><span class="line">    a = a + step * (random.random())</span><br><span class="line">    b = b + step * (random.random())</span><br><span class="line">    print(product(a, b))</span><br><span class="line"></span><br><span class="line">methodOne()</span><br></pre></td></tr></table></figure>
<p>运行程序，我们可以得到输出30.04698146865633（<strong>由于涉及到随机数，所以读者的运行结果会和此处有区别，但一定会是比30大的数</strong>），是比原本的输出30增加了相应值的，说明我们的目标实现了！但是如果我们继续测试，就会发现程序是存在问题的：</p>
<ul>
<li>不可靠！如果我们改变输入值，会发现有时候值会增加，有时候又会减少！，比如以下这个例子:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testTwo</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">-5</span></span><br><span class="line">    b = <span class="number">-6</span></span><br><span class="line">    step = <span class="number">0.01</span></span><br><span class="line">    a = a + step * (random.random())</span><br><span class="line">    b = b + step * (random.random())</span><br><span class="line">    print(product(a, b))</span><br><span class="line"></span><br><span class="line">testTwo()</span><br></pre></td></tr></table></figure>
<p>运行程序，我们会得到结果29.970177554213326，是比原本的输出30小的。只因为我们将输入值a，b变为了负数，这个算法就失效了！究其原因，因为我们对于不同的输入值，变化的都是random()函数，也就是一个在（0，1）之间的正数。而对于负数的输入，增加一个正数，最后反而导致绝对值减小，也就导致输出的结果变小了！</p>
<p>所以，通过以上这个例子，我们可以得出结论：</p>
<p>对于<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = a + step * (random.random())</span><br></pre></td></tr></table></figure></p>
<p>中step后面所乘的系数，我们不能一概而论，而是应该更多的控制它的值，也就是根据不同的输入值来控制，也就是说，step所乘的系数，也就是输入值的变化应该是一个关于输入值的函数</p>
<h1 id="Method-2"><a href="#Method-2" class="headerlink" title="Method 2"></a>Method 2</h1><p>Method 1中的结论是，我们应该有一个step乘以的应该是一个关于输入值的函数。也就是我们需要知道在输入值那个点上，输出结果关于输入值的一个变化率，如果在这个点上，输出结果是随着输入值增加而增加，那么step乘以一个正数即可，反之，则需要乘以一个负数才能使输出结果增加！显然这就是函数在某点上的<strong>微分</strong>的定义！</p>
<p>首先我们将神经元内部的函数写出来<br><img src="http://upload-images.jianshu.io/upload_images/1234352-760c542176c2a704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>神经元输出是一个关于输入的函数！然后我们将输入值a增加一个h</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-58cba2dd010d5eb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>此时新的输出值就变成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(a+h)*b</span><br><span class="line">```，展开就是</span><br></pre></td></tr></table></figure></p>
<p>a<em>b+h</em>b<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">，所以我们可以看到此时输出值相对于原有的输出值的变化就是</span><br></pre></td></tr></table></figure></p>
<p>h*b<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">，只要我们保证</span><br></pre></td></tr></table></figure></p>
<p>h*b<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是正值，就是说可以保证是输出结果增加，而保证正值的方法自然就是h和b同号！更深入的理解，我们将a的值增加h，最后导致输出结果，也就是 函数f的值增加</span><br></pre></td></tr></table></figure></p>
<p>h*b<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">，这时候就可以理解b为函数f在点（a，b）处关于a的变化率！这就是微分的概念了，如果读者有微积分基础，会发现这里实际上f就是一个二元函数的微分，b就是函数f在点（a，b）的微分！微分的实质就是函数在某点的变化率，如果是多元函数就是函数在某点关于某个变量的变化率！多元函数对某一个变量微分时候，通常会将其他变量看作常量！</span><br><span class="line">![image.png](http://upload-images.jianshu.io/upload_images/1234352-aa33fce47827bb8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line">以上公式就是微分的计算方法！</span><br><span class="line"></span><br><span class="line">但实际上，学过微积分，都应该掌握了一套微分的基本法则，我们往往可以根据这套法则，直接写出函数的微分！可以参考[Derivative-rules](https://www.mathsisfun.com/calculus/derivatives-rules.html)</span><br><span class="line">对于我们这里的函数f，我们可以直接写出关于a的微分</span><br><span class="line"></span><br><span class="line">![image.png](http://upload-images.jianshu.io/upload_images/1234352-5915d878aa286509.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">自然，关于b的微分就是</span><br><span class="line"></span><br><span class="line">![image.png](http://upload-images.jianshu.io/upload_images/1234352-05dcf5a4602d489d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">求出了微分，就相当于知道了变量在某点的变化率，那么很自然，a，b的更新规则就是</span><br><span class="line"></span><br><span class="line">![image.png](http://upload-images.jianshu.io/upload_images/1234352-96eb7260f937de54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">def methodTwo(a, b):</span><br><span class="line">    step = 0.01</span><br><span class="line">    a = a + step * b</span><br><span class="line">    b = b + step * a</span><br><span class="line">    print(product(a, b))</span><br><span class="line"></span><br><span class="line">methodTwo(5, 6)</span><br><span class="line">methodTwo(-5, -6)</span><br></pre></td></tr></table></figure></p>
<p>我们发现输出结果30.616035999999998和30.616035999999998，不管输入的值是正是负，都成功将输出结果增加了！而正是利用了微分的概念才能做到，微分实际上就是梯度，梯度就指明了函数上升最快的方向！读者可以参考笔者相关梯度下降的文章<a href="https://liuchi.coding.me/2018/01/17/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"><em>梯度下降</em></a></p>
<p>最后我们来详细分析一下，为什么利用微分更新输入可以做到？</p>
<p>我们深入分析微分几何意义！一个函数对某个变量的微分实际上就是函数在关于这个变量的变化率，变化率的方向是正的，也就是说的变化率，指的是增加的变化率！我们看看我们输入的更新方程</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-26c9f603c20e5829.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<blockquote>
<p>多元函数的微分关于某个变量的微分的意义就是，就是将其他变量全部看成常量，函数关于此变量的变化率，变化率的方向是正的，也就是说上升的方向，如果想要知道下降的变化率，即是负微分</p>
</blockquote>
<p>我们再举一个单变量函数的例子来分析一下如何利用微分更新变量值</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-72bcac57c4c5a496.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们看到上面这个函数关于x先上升，再下降！我们假设两个场景</p>
<p>场景1：</p>
<p>首先，想象我们现在处于A点，我们想要改变变量x的值，从而使函数y的值增加。从图中我们可以清晰的看出，我们只要直接增加x的值，就可以增加函数值。然后结合微分，我们的更新方法就是</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-a4a476c50b12b44b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>场景2：</p>
<p>现在想象我们在C点，也要改变x的值让函数值y增加，这时候我们从图像中可以看到，我们减少x的值，就可以增加函数值！而这正是由函数的微分决定的。我们求取函数关于x在此点的微分，会发现微分是负值，所以我们依然利用场景1中的更新公式，也可以达到增加函数值的目的。</p>
<blockquote>
<p>微分会反映函数的变化趋势，如果我们想要让函数值增加，微分会告诉我们一个正确的更新变量的方向</p>
</blockquote>
<p>场景3：</p>
<p>想象我们此时处于B的左侧，但是非常接近B点！从图像中，我们也会知道此时微分的是正的，也就是我们增加x的值就能使函数值y的值增加！但要注意的一点是，如果我们的step也就是步长如果过大，会导致跑到右边去了，可能还会导致函数值的下降！所以我们就要调整步长！这其实就是一个梯度上升的问题，与梯度下降类似，读者有兴趣可以参考笔者相关文章<a href="https://liuchi.coding.me/2018/01/17/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"><em>梯度下降</em></a></p>
<p>我会在这里结束本文的介绍！希望通过本文读者能对微分有一个理解，同时知道如何将微分利用到更新变量值中，从而改变函数值！</p>
<p><strong>下一篇文章<a href="https://liuchi.coding.me/2018/01/26/Into-Backpropagation/">Into-Backpropagation</a>我会将这个利用微分更新变量的方法，应用到多个神经元的场景中，慢慢读者就会接触到真正的backpropagation反向传播算法</strong></p>
<blockquote>
<p>本文相关代码可以从<a href="https://github.com/chi2liu/Backpropagation" target="_blank" rel="noopener">Backpropagation</a>下载</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初探--神经网络]]></title>
      <url>/2018/01/18/%E5%88%9D%E6%8E%A2-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li>感知器</li>
<li>激活函数</li>
<li>神经网络</li>
<li>小结</li>
</ul>
</blockquote>
<p>本文从感知器开始讲起，引入激活函数，最后引出了神经网络的基本概念和思想，希望能帮助读者对神经网络有一个初步的了解！<br><a id="more"></a></p>
<h1 id="感知器"><a href="#感知器" class="headerlink" title="感知器"></a>感知器</h1><p><strong>人工神经网络的第一个里程碑是感知机perceptron</strong>， 但感知器本质上是用来决策的。 一个感知机其实是对神经元最基本概念的模拟 ，都未必有多少网络概念，他就是一个自动做决策的机器。</p>
<p>感知器纯粹从数学的角度的上看，其实就可以理解为一个黑盒函数，接受若干个输入，产生一个输出的结果，这个结果就代表了感知器所作出的决策！<br><img src="http://upload-images.jianshu.io/upload_images/1234352-ac1b4878f4cd7627.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>举一个简单的例子，假设我们需要判断小明同学是否喜欢一个女生，主要考虑有以下三个因素，女生的颜值(0-10分)，女生的身材(0-10分)，女生的性格(0-10分)，那么对于一个女生我们只需要将这三个因素量化出来，输入到感知器中，然后就能得到感知器给我们决策的结果。而感知器内部决策的原理，其实就是给不同的因素赋予不同的权重，因为不同的因素的重要性对小明来说，自然是不相同的。然后设置一个阈值，如果加权计算之后的结果大于等于这个阈值，就说明可以判断为喜欢，否则则是不喜欢！所以感知器本质上就是一个通过加权计算函数进行决策的工具！<br><img src="http://upload-images.jianshu.io/upload_images/1234352-3f26077775b827db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>根据上面这个公式，我们可以进一步简化，将阈值移到不等式的一边，并且将其称为偏移，那么所有的问题就统一成了一个‘阈值’为0的问题！<br><img src="http://upload-images.jianshu.io/upload_images/1234352-da07e19a87fd741c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>偏移的意义其实就是阈值，你可以将偏移想象成使感知器如何更容易输出 1，或者用更加生物学术语，偏移是指衡量感知器触发的难易程度。对于一个大的偏移，感知器更容易输出 1。如果偏移负值很大，那么感知器将很难输出 1。</strong><br>实际应用中的感知器模型往往更加复杂，如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-99094b0ac37a4463.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h1><p>感知器的学习过程就是通过改变感知器内部的权重和偏移，以使其的输出结果符合期望！但我们仔细观察前文的感知器模型，可以发现，每个感知器的输出可以看作是一个阶跃函数<br><img src="http://upload-images.jianshu.io/upload_images/1234352-e4534d6de98ee2d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>只有两种输出结果，要么是0，要么是1<br>问题就出现了，这样的话，感知器似乎就变成了一个离散的函数！，如果我们稍微改变权重或者偏移，得到的结果就是要么不变，要么就感知器的输出彻底相反。而我们原本期望的是，每个感知器都对输出结果有一定的比重的贡献，单个感知器权重或偏移的变化应该是对输出结果产生微小影响的，而不是剧变。<br><img src="http://upload-images.jianshu.io/upload_images/1234352-092d9017c89196e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>另一方面来讲，感知器模型本质上恶意理解为函数的拟合，如果感知器的输出都是离散的二元状态，并且是前文简单的加权形式，也就是线性的，那么只能进行线性的拟合，不具备处理非线性问题的能力！<br>所以这个时候激活函数就出现了，激活函数就是在感知器加权计算之后，再输入到激活函数中进行计算，得到一个输出！<br>我们以常见的激活函数sigmoid函数为例，<br><img src="http://upload-images.jianshu.io/upload_images/1234352-299e8fd26feff5aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>加入激活函数之后，每个感知器的函数实际上就变成了如下形式<br><img src="http://upload-images.jianshu.io/upload_images/1234352-89790ba63f0c4b67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>我们观察一下，此时感知器函数的图像<br><img src="http://upload-images.jianshu.io/upload_images/1234352-8c4ae1e4706f0748.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>可以对比前文的阶跃的输出图像，我们将一个离散的输出变为一个连续的非线性的输出结果！同时，单个感知器权重和偏移的细微改变，只会对输出结果产生相应的平滑的影响，而不是阶跃式的影响！跟做人一样的道理，不要太武断，太极端，未加入激活函数的感知器模型，就属于非常极端的，要么0，要么1。而加入激活函数后，会是一个在0~1之间的值。</p>
<h1 id="激活函数的理论解释"><a href="#激活函数的理论解释" class="headerlink" title="激活函数的理论解释"></a>激活函数的理论解释</h1><p><strong>激活函数是用来加入非线性因素的，解决线性模型所不能解决的问题。</strong><br>假设这么一个情景：<br>我们有这个需求，就是二分类问题，如我要将下面的三角形和圆形点进行正确的分类，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-c9123094d6158096.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>利用我们单层的感知机, 用它可以划出一条线, 把平面分割开：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-eeb2ce97bbdb540b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>该感知器实现预测的功能步骤如下，就是我已经训练好了一个感知器模型，后面对于要预测的样本点，带入模型中，如果y&gt;0,那么就说明是直线的右侧，也就是正类（我们这里是三角形），如果y&lt;0,那么就说明是直线的左侧，也就是负类（我们这里是圆形</p>
<p>好吧，很容易能够看出，我给出的样本点根本不是线性可分的，一个感知器无论得到的直线怎么动，都不可能完全正确的将三角形与圆形区分出来，那么我们很容易想到用多个感知器来进行组合，以便获得更大的分类问题，好的，下面我们上图，看是否可行：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-16ce6b2ca3f37f33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>好的，我们已经得到了多感知器分类器了，那么它的分类能力是否强大到能将非线性数据点正确分类开呢~我们来分析一下：</p>
<p>我们能够得到<br><img src="http://upload-images.jianshu.io/upload_images/1234352-e41caefeef4a0d3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>化简后就是<br><img src="http://upload-images.jianshu.io/upload_images/1234352-996ff865d32141dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>不管它怎么组合，最多就是线性方程的组合，最后得到的分类器本质还是一个线性方程，该处理不了的非线性问题，它还是处理不了。</p>
<p>所以如果没有激活函数，那么感知器模型实际上就是在拟合一个线性方程而已，这样的话，能够解决的问题，自然就是太局限了！</p>
<p>激活函数的作用就出来了，将一个线性的函数变为一个非线性的函数！我们依然以最常用的sigmoid激活函数为例：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-19861723103250c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>通过这个激活函数映射之后，输出很明显就是一个非线性函数！能不能解决一开始的非线性分类问题不清楚，但是至少说明有可能啊，上面不加入激活函数神经网络压根就不可能解决这个问题~</p>
<p>同理，扩展到多个神经元组合的情况时候，表达能力就会更强~对应的组合图如下：（现在已经升级为三个非线性感知器在组合了）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-94a2ffc7ec27425a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>最后再通过最优化损失函数的做法，我们能够学习到不断学习靠近能够正确分类三角形和圆形点的曲线，到底会学到什么曲线，不知道到底具体的样子，也许是下面这个~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-08dc21cd9a713f80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>所以到这里为止，我们就解释了这个观点，加入激活函数是用来加入非线性因素的，解决线性模型所不能解决的问题。</p>
<h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><p>介绍了感知器和激活函数，实际上我们已经将神经网络的基本概念了解的差不多了。将感知器套上激活函数实际上就是神经网络。<br>和感知器模型一样，神经网络的基本单位是神经元，每个神经元分别接受输入和输出，但与感知器不同的是，除了进行加权计算，还需要利用激活函数输出！</p>
<p>假如我们有如下网络：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-7bad970c59810451.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>就像先前说的，网络的最左边一层被称为输入层，其中的神经元被称为输入神经元。最右边及输出层包含输出神经元，在这个例子中，只有一个单一的输出神经元。中间层被称为隐含层，因为里面的神经元既不是输入也不是输出。“隐含”这个术语可能听起来很神秘——当我第一次听到时候觉得一定有深层的哲学或者数学意义——但实际上它只表示“不是输入和输出”而已。上面的网络只包含了唯一个隐含层，但是一些网络可能有多层。比如，下面的4层网络具有2个隐含层：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-1e1c68927a8bd0e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>神经网络的基本思想就是建立在感知器和激活函数上的。对于多个输入，在神经网络经过多个神经元计算之后，得到多个或者单个输出。检查输出结果是否与期望的一致，如果不一致，就对神经网络中神经元的权重进行调整，我们已经知道，神经元权重的细微调整会引起输出结果的细微变化，这样多个神经元组合起来，逐渐调整，直到符合预期的输出结果，我们就可以认为神经网络训练成功了！这里所说的训练调整的方法，利用到了<a href="https://liuchi.coding.me/2018/01/17/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"><em>梯度下降法</em></a>，对神经网络进行反向传播，我们将在后续的文章进行详细的介绍!</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文从感知器模型开始，继而引入激活函数，最后引出了神经网络的基本结构和思想，后续将会详细介绍神经网络自主学习的原理！</p>
<h1 id="Further-reading"><a href="#Further-reading" class="headerlink" title="Further reading"></a>Further reading</h1><ul>
<li><a href="http://neuralnetworksanddeeplearning.com/index.html" target="_blank" rel="noopener"><em>Neural Networks and Deep Learning</em></a></li>
<li><a href="http://www.faqs.org/faqs/ai-faq/neural-nets/part2/section-10.html" target="_blank" rel="noopener"><em>Why use activation functions</em></a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入浅出--梯度下降法及其实现]]></title>
      <url>/2018/01/17/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li>梯度下降的场景假设</li>
<li>梯度</li>
<li>梯度下降算法的数学解释</li>
<li>梯度下降算法的实例</li>
<li>梯度下降算法的实现</li>
<li>Further reading</li>
</ul>
</blockquote>
<p>本文将从一个下山的场景开始，先提出梯度下降算法的基本思想，进而从数学上解释梯度下降算法的原理，最后实现一个简单的梯度下降算法的实例！<br><a id="more"></a></p>
<h1 id="梯度下降的场景假设"><a href="#梯度下降的场景假设" class="headerlink" title="梯度下降的场景假设"></a>梯度下降的场景假设</h1><blockquote>
<p>梯度下降法的基本思想可以类比为一个下山的过程。假设这样一个场景：一个人被困在山上，需要从山上下来(i.e. 找到山的最低点，也就是山谷)。但此时山上的浓雾很大，导致可视度很低。因此，下山的路径就无法确定，他必须利用自己周围的信息去找到下山的路径。这个时候，他就可以利用梯度下降算法来帮助自己下山。具体来说就是，以他当前的所处的位置为基准，寻找这个位置最陡峭的地方，然后朝着山的高度下降的地方走，同理，如果我们的目标是上山，也就是爬到山顶，那么此时应该是朝着最陡峭的方向往上走。然后每走一段距离，都反复采用同一个方法，最后就能成功的抵达山谷。<br><img src="http://upload-images.jianshu.io/upload_images/1234352-6ae594f795406b8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>我们同时可以假设这座山最陡峭的地方是无法通过肉眼立马观察出来的，而是需要一个复杂的工具来测量，同时，这个人此时正好拥有测量出最陡峭方向的能力。所以，此人每走一段距离，都需要一段时间来测量所在位置最陡峭的方向，这是比较耗时的。那么为了在太阳下山之前到达山底，就要尽可能的减少测量方向的次数。这是一个两难的选择，如果测量的频繁，可以保证下山的方向是绝对正确的，但又非常耗时，如果测量的过少，又有偏离轨道的风险。所以需要找到一个合适的测量方向的频率，来确保下山的方向不错误，同时又不至于耗时太多！</p>
</blockquote>
<h1 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h1><p>梯度下降的基本过程就和下山的场景很类似。</p>
<hr>
<p>首先，我们有一个可<a href="https://en.wikipedia.org/wiki/Differentiable_function" target="_blank" rel="noopener"><em>微分</em></a>的函数。这个函数就代表着一座山。我们的目标就是找到这个函数的最小值，也就是山底。根据之前的场景假设，最快的下山的方式就是找到当前位置最陡峭的方向，然后沿着此方向向下走，对应到函数中，就是找到给定点的<a href="https://en.wikipedia.org/wiki/Gradient" target="_blank" rel="noopener"><em>梯度</em></a> ，然后朝着梯度相反的方向，就能让函数值下降的最快！因为梯度的方向就是函数之变化最快的方向(在后面会详细解释)<br>所以，我们重复利用这个方法，反复求取梯度，最后就能到达局部的最小值，这就类似于我们下山的过程。而求取梯度就确定了最陡峭的方向，也就是场景中测量方向的手段。那么为什么梯度的方向就是最陡峭的方向呢？接下来，我们从微分开始讲起</p>
<h1 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h1><p>看待微分的意义，可以有不同的角度，最常用的两种是：</p>
<ul>
<li>函数图像中，某点的切线的斜率</li>
<li>函数的变化率<br>几个微分的例子：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-0eb0f1bfd7de705b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ul>
<p>上面的例子都是单变量的微分，当一个函数有多个变量的时候，就有了多变量的微分，即分别对每个变量进行求微分<br><img src="http://upload-images.jianshu.io/upload_images/1234352-4029977524e3b365.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h1><p>梯度实际上就是多变量微分的一般化。<br>下面这个例子：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-570afdfc6fabf3b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们可以看到，梯度就是分别对每个变量进行微分，然后用逗号分割开，梯度是用&lt;&gt;包括起来，说明梯度其实一个向量。</p>
<p>梯度是微积分中一个很重要的概念，之前提到过梯度的意义</p>
<ul>
<li>在单变量的函数中，梯度其实就是函数的微分，代表着函数在某个给定点的切线的斜率</li>
<li>在多变量函数中，梯度是一个向量，向量有方向，梯度的方向就指出了函数在给定点的上升最快的方向</li>
</ul>
<p>这也就说明了为什么我们需要千方百计的求取梯度！我们需要到达山底，就需要在每一步观测到此时最陡峭的地方，梯度就恰巧告诉了我们这个方向。梯度的方向是函数在给定点上升最快的方向，那么梯度的反方向就是函数在给定点下降最快的方向，这正是我们所需要的。所以我们只要沿着梯度的方向一直走，就能走到局部的最低点！<br><img src="http://upload-images.jianshu.io/upload_images/1234352-13d969531284a9f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="梯度下降算法的数学解释"><a href="#梯度下降算法的数学解释" class="headerlink" title="梯度下降算法的数学解释"></a>梯度下降算法的数学解释</h1><p>上面我们花了大量的篇幅介绍梯度下降算法的基本思想和场景假设，以及梯度的概念和思想。下面我们就开始从数学上解释梯度下降算法的计算过程和思想！<br><img src="http://upload-images.jianshu.io/upload_images/1234352-f20521a962005299.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>此公式的意义是：J是关于Θ的一个函数，我们当前所处的位置为Θ0点，要从这个点走到J的最小值点，也就是山底。首先我们先确定前进的方向，也就是梯度的反向，然后走一段距离的步长，也就是α，走完这个段步长，就到达了Θ1这个点！<br><img src="http://upload-images.jianshu.io/upload_images/1234352-af8dd9722c762c13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>下面就这个公式的几个常见的疑问：</p>
<ul>
<li>α是什么含义？<br>α在梯度下降算法中被称作为<strong>学习率</strong>或者<strong>步长</strong>，意味着我们可以通过α来控制每一步走的距离，以保证不要步子跨的太大扯着蛋，哈哈，其实就是不要走太快，错过了最低点。同时也要保证不要走的太慢，导致太阳下山了，还没有走到山下。所以α的选择在梯度下降法中往往是很重要的！α不能太大也不能太小，太小的话，可能导致迟迟走不到最低点，太大的话，会导致错过最低点！</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-ba3da0b06da97ddb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>为什么要梯度要乘以一个负号？<br>梯度前加一个负号，就意味着朝着梯度相反的方向前进！我们在前文提到，梯度的方向实际就是函数在此点上升最快的方向！而我们需要朝着下降最快的方向走，自然就是负的梯度的方向，所以此处需要加上负号</li>
</ul>
<h1 id="梯度下降算法的实例"><a href="#梯度下降算法的实例" class="headerlink" title="梯度下降算法的实例"></a>梯度下降算法的实例</h1><p>我们已经基本了解了梯度下降算法的计算过程，那么我们就来看几个梯度下降算法的小实例，首先从单变量的函数开始</p>
<h2 id="单变量函数的梯度下降"><a href="#单变量函数的梯度下降" class="headerlink" title="单变量函数的梯度下降"></a>单变量函数的梯度下降</h2><p>我们假设有一个单变量的函数<br><img src="http://upload-images.jianshu.io/upload_images/1234352-abb73822fb6d2a2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>函数的微分<br><img src="http://upload-images.jianshu.io/upload_images/1234352-66ce0cdcef5e2686.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>初始化，起点为<br><img src="http://upload-images.jianshu.io/upload_images/1234352-8ee36cc5ce832b17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>学习率为<br><img src="http://upload-images.jianshu.io/upload_images/1234352-798b134107b6593d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>根据梯度下降的计算公式<br><img src="http://upload-images.jianshu.io/upload_images/1234352-f20521a962005299.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>我们开始进行梯度下降的迭代计算过程：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-57538d21dbb34e65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>如图，经过四次的运算，也就是走了四步，基本就抵达了函数的最低点，也就是山底<br><img src="http://upload-images.jianshu.io/upload_images/1234352-bb7fa36d116fcadc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="多变量函数的梯度下降"><a href="#多变量函数的梯度下降" class="headerlink" title="多变量函数的梯度下降"></a>多变量函数的梯度下降</h2><p>我们假设有一个目标函数<br><img src="http://upload-images.jianshu.io/upload_images/1234352-a56cfde25c688859.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>现在要通过梯度下降法计算这个函数的最小值。我们通过观察就能发现最小值其实就是 (0，0)点。但是接下来，我们会从梯度下降算法开始一步步计算到这个最小值！<br>我们假设初始的起点为：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-8b1b6f1b200fd7b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>初始的学习率为：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-ccc1493848871074.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>函数的梯度为：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-3d744d9364a4ba40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>进行多次迭代：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-b21bf64600c4e32f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>我们发现，已经基本靠近函数的最小值点<br><img src="http://upload-images.jianshu.io/upload_images/1234352-becdcdfdefb4eab7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="梯度下降算法的实现"><a href="#梯度下降算法的实现" class="headerlink" title="梯度下降算法的实现"></a>梯度下降算法的实现</h1><p>下面我们将用python实现一个简单的梯度下降算法。场景是一个简单的<a href="https://en.wikipedia.org/wiki/Linear_regression" target="_blank" rel="noopener"><em>线性回归</em></a>的例子：假设现在我们有一系列的点，如下图所示<br><img src="http://upload-images.jianshu.io/upload_images/1234352-333f16d34874c230.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们将用梯度下降法来拟合出这条直线！</p>
<p>首先，我们需要定义一个代价函数，在此我们选用<a href="https://en.wikipedia.org/wiki/Least_squares" target="_blank" rel="noopener"><em>均方误差代价函数</em></a><br><img src="http://upload-images.jianshu.io/upload_images/1234352-4e4000e69f05af7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>此公示中</p>
<ul>
<li>m是数据集中点的个数</li>
<li>½是一个常量，这样是为了在求梯度的时候，二次方乘下来就和这里的½抵消了，自然就没有多余的常数系数，方便后续的计算，同时对结果不会有影响</li>
<li>y 是数据集中每个点的真实y坐标的值</li>
<li>h 是我们的预测函数，根据每一个输入x，根据Θ 计算得到预测的y值，即<br><img src="http://upload-images.jianshu.io/upload_images/1234352-acea37db1e02004d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ul>
<p>我们可以根据代价函数看到，代价函数中的变量有两个，所以是一个多变量的梯度下降问题，求解出代价函数的梯度，也就是分别对两个变量进行微分<br><img src="http://upload-images.jianshu.io/upload_images/1234352-bfd1c5136eaaa552.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>明确了代价函数和梯度，以及预测的函数形式。我们就可以开始编写代码了。但在这之前，需要说明一点，就是为了方便代码的编写，我们会将所有的公式都转换为矩阵的形式，python中计算矩阵是非常方便的，同时代码也会变得非常的简洁。</p>
<p>为了转换为矩阵的计算，我们观察到预测函数的形式<br><img src="http://upload-images.jianshu.io/upload_images/1234352-acea37db1e02004d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>我们有两个变量，为了对这个公式进行矩阵化，我们可以给每一个点x增加一维，这一维的值固定为1，这一维将会乘到Θ0上。这样就方便我们统一矩阵化的计算<br><img src="http://upload-images.jianshu.io/upload_images/1234352-a54d53411f945d95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>然后我们将代价函数和梯度转化为矩阵向量相乘的形式<br><img src="http://upload-images.jianshu.io/upload_images/1234352-66b04086dd1f8ba9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="coding-time"><a href="#coding-time" class="headerlink" title="coding time"></a>coding time</h2><p>首先，我们需要定义数据集和学习率<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Size of the points dataset.</span></span><br><span class="line">m = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Points x-coordinate and dummy value (x0, x1).</span></span><br><span class="line">X0 = np.ones((m, <span class="number">1</span>))</span><br><span class="line">X1 = np.arange(<span class="number">1</span>, m+<span class="number">1</span>).reshape(m, <span class="number">1</span>)</span><br><span class="line">X = np.hstack((X0, X1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Points y-coordinate</span></span><br><span class="line">y = np.array([</span><br><span class="line">	<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">12</span>,</span><br><span class="line">	<span class="number">11</span>, <span class="number">13</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">21</span></span><br><span class="line">]).reshape(m, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The Learning Rate alpha.</span></span><br><span class="line">alpha = <span class="number">0.01</span></span><br></pre></td></tr></table></figure></p>
<p>接下来我们以矩阵向量的形式定义代价函数和代价函数的梯度<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_function</span><span class="params">(theta, X, y)</span>:</span></span><br><span class="line">	<span class="string">'''Error function J definition.'''</span></span><br><span class="line">	diff = np.dot(X, theta) - y</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1.</span>/<span class="number">2</span>*m) * np.dot(np.transpose(diff), diff)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_function</span><span class="params">(theta, X, y)</span>:</span></span><br><span class="line">	<span class="string">'''Gradient of the function J definition.'''</span></span><br><span class="line">	diff = np.dot(X, theta) - y</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1.</span>/m) * np.dot(np.transpose(X), diff)</span><br></pre></td></tr></table></figure></p>
<p>最后就是算法的核心部分，梯度下降迭代计算<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span><span class="params">(X, y, alpha)</span>:</span></span><br><span class="line">	<span class="string">'''Perform gradient descent.'''</span></span><br><span class="line">	theta = np.array([<span class="number">1</span>, <span class="number">1</span>]).reshape(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">	gradient = gradient_function(theta, X, y)</span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">not</span> np.all(np.absolute(gradient) &lt;= <span class="number">1e-5</span>):</span><br><span class="line">		theta = theta - alpha * gradient</span><br><span class="line">		gradient = gradient_function(theta, X, y)</span><br><span class="line">	<span class="keyword">return</span> theta</span><br></pre></td></tr></table></figure></p>
<p>当梯度小于1e-5时，说明已经进入了比较平滑的状态，类似于山谷的状态，这时候再继续迭代效果也不大了，所以这个时候可以退出循环！</p>
<p>完整的代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Size of the points dataset.</span></span><br><span class="line">m = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Points x-coordinate and dummy value (x0, x1).</span></span><br><span class="line">X0 = np.ones((m, <span class="number">1</span>))</span><br><span class="line">X1 = np.arange(<span class="number">1</span>, m+<span class="number">1</span>).reshape(m, <span class="number">1</span>)</span><br><span class="line">X = np.hstack((X0, X1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Points y-coordinate</span></span><br><span class="line">y = np.array([</span><br><span class="line">	<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">12</span>,</span><br><span class="line">	<span class="number">11</span>, <span class="number">13</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">21</span></span><br><span class="line">]).reshape(m, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The Learning Rate alpha.</span></span><br><span class="line">alpha = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_function</span><span class="params">(theta, X, y)</span>:</span></span><br><span class="line">	<span class="string">'''Error function J definition.'''</span></span><br><span class="line">	diff = np.dot(X, theta) - y</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1.</span>/<span class="number">2</span>*m) * np.dot(np.transpose(diff), diff)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_function</span><span class="params">(theta, X, y)</span>:</span></span><br><span class="line">	<span class="string">'''Gradient of the function J definition.'''</span></span><br><span class="line">	diff = np.dot(X, theta) - y</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1.</span>/m) * np.dot(np.transpose(X), diff)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span><span class="params">(X, y, alpha)</span>:</span></span><br><span class="line">	<span class="string">'''Perform gradient descent.'''</span></span><br><span class="line">	theta = np.array([<span class="number">1</span>, <span class="number">1</span>]).reshape(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">	gradient = gradient_function(theta, X, y)</span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">not</span> np.all(np.absolute(gradient) &lt;= <span class="number">1e-5</span>):</span><br><span class="line">		theta = theta - alpha * gradient</span><br><span class="line">		gradient = gradient_function(theta, X, y)</span><br><span class="line">	<span class="keyword">return</span> theta</span><br><span class="line"></span><br><span class="line">optimal = gradient_descent(X, y, alpha)</span><br><span class="line">print(<span class="string">'optimal:'</span>, optimal)</span><br><span class="line">print(<span class="string">'error function:'</span>, error_function(optimal, X, y)[<span class="number">0</span>,<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p>
<p>运行代码，计算得到的结果如下<br><img src="http://upload-images.jianshu.io/upload_images/1234352-af64f7e8e5fb3dfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>所拟合出的直线如下<br><img src="http://upload-images.jianshu.io/upload_images/1234352-27806efbd53ced41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>至此，我们就基本介绍完了梯度下降法的基本思想和算法流程，并且用python实现了一个简单的梯度下降算法拟合直线的案例！<br>最后，我们回到文章开头所提出的场景假设:<br><strong>这个下山的人实际上就代表了<a href="https://en.wikipedia.org/wiki/Backpropagation" title="Backpropagation" target="_blank" rel="noopener">反向传播算法</a>，下山的路径其实就代表着算法中一直在寻找的参数Θ，山上当前点的最陡峭的方向实际上就是代价函数在这一点的梯度方向，场景中观测最陡峭方向所用的工具就是<a href="https://en.wikipedia.org/wiki/Derivative" title="Derivative" target="_blank" rel="noopener">微分</a> 。在下一次观测之前的时间就是有我们算法中的学习率α所定义的。</strong><br>可以看到场景假设和梯度下降算法很好的完成了对应！</p>
<h1 id="Further-reading"><a href="#Further-reading" class="headerlink" title="Further reading"></a>Further reading</h1><ul>
<li><a href="https://storage.googleapis.com/supplemental_media/udacityu/315142919/Gradient%20Descent.pdf" target="_blank" rel="noopener">Gradient Descent lecture notes</a> from <a href="https://www.udacity.com/course/machine-learning--ud262" target="_blank" rel="noopener">UD262 Udacity Georgia Tech ML Course</a>. </li>
<li><a href="https://arxiv.org/pdf/1609.04747.pdf" target="_blank" rel="noopener">An overview of gradient descent optimization algorithms</a>.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[程序员面试资料]]></title>
      <url>/2017/12/16/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/</url>
      <content type="html"><![CDATA[<blockquote>
<p>工欲善其事必先利其器</p>
</blockquote>
<p>对于程序员面试来说，所谓“器”其实就是手中的资料文档信息，有一份好的资料，可以少走很多弯路。但现在网上各种资料泛滥，经常让人眼花缭乱。所以就将面试中用的一些好资料分享出来，希望能给同学们提供一个参考，有所帮助！<br><a id="more"></a><br>主要是面对即将毕业的同学准备校招面试，所以更注重基础！</p>
<p>目前主要有：</p>
<ul>
<li>Java语言相关</li>
<li>数据结构算法</li>
<li>数据库</li>
<li>网络</li>
<li>操作系统</li>
<li>场景和系统设计题</li>
<li>面试经验和心得<ul>
<li>设计模式 </li>
</ul>
</li>
</ul>
<p>在github上新建了一个项目，欢迎fork，并分享相关的有价值的资料文档！<br>github地址:<a href="https://github.com/chi2liu/Interview_Material" target="_blank" rel="noopener">https://github.com/chi2liu/Interview_Material</a></p>
]]></content>
      
        <categories>
            
            <category> 面试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何准备校招技术面试+一只小菜鸟的面试之路]]></title>
      <url>/2017/12/16/%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E6%A0%A1%E6%8B%9B%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95-%E4%B8%80%E5%8F%AA%E5%B0%8F%E8%8F%9C%E9%B8%9F%E7%9A%84%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%B7%AF/</url>
      <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><hr>
<blockquote>
<p>秋招一路走来很幸运，从最初的迷茫，到接连被否认，跌入低谷，然后慢慢调整心态，有缺憾才能有进步，正视的自己不足，静下心努力提高，勇敢尝试各种面试机会，因上努力，果上随缘，慢慢看到改变，收获肯定，重拾信心。<br><a id="more"></a><br>校招像一个登山的过程，要一步一个脚印，不能因为某些失败，就半途而废，行百里者半九十，念念不忘，必有回响，只要一路坚持下来，就会有所收获。据身边所见，大部分一直坚持面试下去的同学，最后都拿到了满意的offer。<br>写在这里，是对自己秋招的一次总结和怀念，也希望给那些和我一样迷茫过，怀疑过，失落过的人一些帮助和激励。</p>
</blockquote>
<h1 id="如何准备校招"><a href="#如何准备校招" class="headerlink" title="如何准备校招"></a>如何准备校招</h1><h2 id="需长期积累"><a href="#需长期积累" class="headerlink" title="需长期积累"></a>需长期积累</h2><h3 id="（1）手撕代码能力"><a href="#（1）手撕代码能力" class="headerlink" title="（1）手撕代码能力"></a>（1）手撕代码能力</h3><p>现在大多数大厂的面试基本上都需要手写代码！基本逃不掉！所以这个能力是极其重要的，写得好很加分，写得不好就很可能GG了。<br>建议这方面基础不太好的同学，提前至少半年开始刷题，主要是lintcode和leetcode。等到七八月份再刷题可能就真的来不及了，那时候基本每天都有笔试面试，所以如果算法代码能力不好的同学，一定要尽早刷题，算法是个内功，需要时间慢慢积累，唯一的方法就是多刷题，多写代码。<br>Leetcode刷200道左右，编号前100的题目尽量能刷两遍，尽量做到大部分能独立写bug free的ac代码。<br>现场面试的时候基本是手写代码，所以最好有时间也练一练在纸上写代码，找找感觉，尽量写的简洁干净，不要涂涂改改。</p>
<h3 id="（2）项目经历和实习经历"><a href="#（2）项目经历和实习经历" class="headerlink" title="（2）项目经历和实习经历"></a>（2）项目经历和实习经历</h3><p>项目经历和实力经历是最需要平时积累的。不要仅仅就在完成任务这个层面，不要沉迷在项目的一些业务细节上，多关注框架，架构，优化方面的东西。可以深入去研究项目，比如做某些优化，用设计模式去重构一下，用到前沿的技术优化，比如redis缓存之类的东西，相信只要用心去研究所做的项目，等到面试的时候，去总结项目难点怎么回答就不困难了！</p>
<h2 id="可临时抱佛脚"><a href="#可临时抱佛脚" class="headerlink" title="可临时抱佛脚"></a>可临时抱佛脚</h2><ul>
<li>网络，数据库，操作系统，java或者C++等这些基础知识，面试的时候无非就是常见的那些面试题，都是固定的问题和答案，平常只要稍微关注一下即可，到了面试前花一两个星期临时抱佛脚看一看背一背基本就能应付过去。（如果要真正掌握这些知识，显然是需要花很大精力去钻研的，但就应付面试来说，记一记常考的点，搞清楚常问的点基本就够了）</li>
<li>场景题和系统设计题，很多同学比较怕这类题目，其实这类题目大多涉及一些架构设计的东西，不会要你回答的多么细致，能给出大概的思路即可。而且多是一些高并发高负载的系统设计题。可能大部分应届生都没法接触到这么高难度的开发，所以这时候主要就看你的想法和视野了。尝试去看一些架构方面的书和积累一些面试题就发现其实这类题都是一个套路。看着很难，但实际上只要知道这些技术的基本概念和作用就行了，答出思路基本就没问题，毕竟不会让你现场写一个高并发系统。</li>
</ul>
<h1 id="完整面经-总结"><a href="#完整面经-总结" class="headerlink" title="完整面经+总结"></a>完整面经+总结</h1><h2 id="Cvte提前批"><a href="#Cvte提前批" class="headerlink" title="Cvte提前批"></a>Cvte提前批</h2><ul>
<li>一面（电话）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>介绍你的项目</li>
<li>加密解密了解么？几种算法，讲一下你了解的</li>
<li>多线程了解么？什么是线程安全？</li>
<li>说一个你最熟悉的设计模式</li>
<li>讲一下你项目中用到了哪些设计模式</li>
<li>Java的hashmap的原理</li>
<li>Hashmap的线程安全性，什么是线程安全的？如何实现线程安全</li>
<li>数据库的索引了解么？介绍一下</li>
<li>数据库有哪些优化的方法？讲你自己知道的</li>
<li>为什么事务可以优化数据库？</li>
</ol>
<ul>
<li>二面（视频）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>介绍项目</li>
<li>Mysql的数据库引擎，区别特点</li>
<li>设计模式了解？讲一下最熟悉的</li>
<li>写一个单例模式，答主写的是双检查锁单例，问了为什么用Volatile，synchronize</li>
<li>单例模式在你项目里哪些应用？</li>
<li>数据连接池采用了什么设计模式？意义是什么？</li>
<li>对高负载有了解么</li>
<li>你意向的技术方向是哪块？（答主回答的高并发，然后面试官说他是做高负载的）</li>
<li>对高并发有了解么？</li>
</ol>
<blockquote>
<p>校招首次面试，二面跪。发现存在以下问题：<br>（1）准备不充分（自我介绍，项目介绍，项目难点等需提前准备）（2）基础不扎实（面试中问的数据库相关问题基本没答上来）<br>（3）缺乏亮点（缺乏体现自己能力的东西，比如项目难点如何解决，对一些前沿技术的了解等）<br>庆幸的当时只是八月初，大部分大厂的校招还没开始，有足够的时间去提高，比如深入复习数据库这一块的内容，深入去研究项目，了解一些前沿的新技术等。</p>
</blockquote>
<h2 id="阿里内推"><a href="#阿里内推" class="headerlink" title="阿里内推"></a>阿里内推</h2><ul>
<li>一面（电话）</li>
</ul>
<ol>
<li>听说你有博客，博客里大概有什么内容？</li>
<li>项目介绍，最复杂的表</li>
<li>Hashmap的原理</li>
<li>Hashmap为什么大小是2的幂次</li>
<li>介绍一下红黑树</li>
<li>Arraylist的原理</li>
<li>Arraylist的扩容机制</li>
<li>为什么arraylist扩容是1.5倍</li>
<li>场景题：设计判断论文抄袭的系统</li>
<li>堆排序的原理</li>
<li>抽象工厂和工厂方法模式的区别</li>
<li>工厂模式的思想</li>
<li>object类你知道的方法</li>
<li>哪里用到了工厂模式</li>
<li>Forward和redirect的区别</li>
</ol>
<ul>
<li>二面（视频）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>项目介绍</li>
<li>项目架构</li>
<li>项目难点</li>
<li>Synchronize关键字为什么jdk1.5后效率提高了</li>
<li>线程池的使用时的注意事项</li>
<li>Spring中autowire和resourse关键字的区别</li>
<li>Hashmap的原理</li>
<li>Hashmap的大小为什么指定为2的幂次</li>
<li>讲一下线程状态转移图</li>
<li>消息队列了解么</li>
<li>分布式了解么</li>
</ol>
<blockquote>
<p>阿里作为最想去的公司（毕竟是国内JAVA第一大厂）面试开始比较早，自己还处在面试菜鸟的阶段，最后挂在二面。<br>一面面试官很好，体验不错。最后给我建议：希望我多去深入理解背后的原理，而不是仅仅停留在知道了解的层面。总体一面还是感觉不错。<br>二面是整个秋招表现最不好的一次面试。答的很乱。<br>这次面试看到自己的不足，第一，就是基础很不扎实，很多常问的面试题自己都不知道，第二，要深入去理解背后的原理，比如数据库的隔离级别具体的实现等等，第三，深入琢磨自己做的项目，用一些高大上的技术去装饰。<br>阿里面试后，有了危机感，从0开始研究redis数据库，研究mysql数据库的一些常问的底层实现，以及spring的一些常见的面试题等<br>一个经验：<strong>到了八九月份的时候，遇到一些自己不会的大块，比如数据库，很多人就直接放弃，觉得再学已经来不及，其实不然，面试的时候，问的东西基本是固定的，只要我们对常问的面试问题深入了解就行。所以八九月份发现自己还有东西完全不会的，也不要慌，沉下心去学几天，绝对来得及！</strong></p>
</blockquote>
<h2 id="便利蜂内推（offer）"><a href="#便利蜂内推（offer）" class="headerlink" title="便利蜂内推（offer）"></a>便利蜂内推（offer）</h2><ul>
<li>一面（电话）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>项目介绍</li>
<li>volatile和synchronized </li>
<li>来个算法题：一个无序数组，其中一个数字出现的次数大于其他数字之和，求这个数字 （主元素）</li>
<li>答完再来一个：一个数组，有正有负，不改变顺序的情况下，求和最大的最长子序列 </li>
<li>项目用到什么数据库？隔离级别？每个隔离级别各做了什么</li>
<li>数据库的索引？mysql不同引擎索引的区别 </li>
<li>垃圾回收算法的过程</li>
<li>你了解的垃圾收集器？ Cms收集器的过程</li>
<li>怎样进入老年代？ </li>
<li>平时用到了什么设计模式？ </li>
<li>讲一下你最熟的两个设计模式</li>
<li>用过什么系统？shell写过脚本吗？</li>
<li>讲你知道的Linux命令<blockquote>
<p>便利蜂是校招拿到的第一个offer，虽然公司名气不大，但尽早拿到第一个offer，可以提高信心和稳住心态，对后续的面试很有帮助。<br><strong>所以前期一定要多投简历，能面的尽量面，反正最后你又不一定去，多面几次积累经验，等到大厂的面试开始，已经积累到了足够的面试经验，可以发挥的更好。</strong><br>便利蜂的面试也是幸运女神眷顾。<br>面试前，在牛客网搜索了所有便利蜂java的面经，只找到一篇，就把那篇面经的问题好好研究了一遍。然后奇迹出现了，面试问的问题基本一模一样，估计是同一个面试官，所以答得很顺利。<br>一个小技巧，当面试的时候遇到以前做过的算法题的时候，千万别说自己做过，请假装没做过，不然面试官会换题目的。<br>经验：<br><strong>进入校招之后，多泡泡牛客网，多看看面经很有帮助，面试其实都大同小异，就那么些知识点，所以多看多总结。</strong></p>
</blockquote>
</li>
</ol>
<h2 id="拼多多"><a href="#拼多多" class="headerlink" title="拼多多"></a>拼多多</h2><ul>
<li>一面（现场面）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>项目介绍</li>
<li>手撕算法：一棵二叉排序树，给定一个数，找到与给定数差值绝对值最小的数</li>
<li>场景题：设计一个系统，解决抢购时所需要的大量的短链接的功能，如何保证高并发，如何设计短链接</li>
</ol>
<ul>
<li>二面（现场面）</li>
</ul>
<ol>
<li>代码量多少</li>
<li>给了一张纸，各种名词，会的写出来</li>
<li>然后给它解释那些会的</li>
<li>设计题：设计一个系统，记录qq用户前一天的登录状态，提供16g内存和2tb的硬盘，要做到查询指定qq号的前一天的登录状态，快速查询O(1)复杂度</li>
</ol>
<blockquote>
<p>之前经历了那么多电话面，终于迎来了人生第一次现场技术面！<br>果然第一次总是会有点痛苦，很遗憾的挂了！<br>一面感觉还不错，项目简单聊了一下，感觉面试官兴趣不大。就开始手撕代码，第一次手撕代码，略紧张，最后还是想出来了。然后一个场景题，用到了刚学会的redis，现学现卖，感觉面试官还比较满意。<br>二面一坐下，就感觉对面的面试官气场太强，一坐下，没让自我介绍，直接给了问代码量多少，我准备大概估算一下，结果被面试官打断，让我直接说，讲真，有点慌乱哈哈。就说了大概十万行。然后给了一张纸，大概有几十个专业名词，让我把会的勾出来，然后一个一个的解释。然后就出了一个系统设计题，一直没理解面试官的意思，最后在面试官讨论项目的过程中，面试官问是否可以通过value推到key，一下没经过思考，答了个是，答错了，然后面试官就说面试结束了。<br><strong>很多时候，如果面试官问到一个比较基础的问题，你没答上来，那你就跪了，所以回答之前要三思熟虑，别急着回答，好好想一想。</strong></p>
</blockquote>
<h2 id="多益网络内推（offer）"><a href="#多益网络内推（offer）" class="headerlink" title="多益网络内推（offer）"></a>多益网络内推（offer）</h2><ul>
<li>一面（视频）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>对面向对象的理解</li>
<li>介绍多态</li>
<li>Java新建线程有哪几种方式</li>
<li>线程池的作用</li>
<li>看过框架源码么<blockquote>
<p>多益只有一面视频面，是秋招拿到的第二个offer。<br>整个面试过程，感觉面试官都是问的一些很大的问题，就看你自己发挥了，尽量把知道的都回答，而且尽量回答的专业。<br>在问到对面向对象的理解的时候，可能大部分人都会回答多态继承封装就没了。前几天正好看到面向对象的六原则和一法则，然后就给面试官吹了一波，面试官也没打断我，一直让我说，整个面试答得比较好的就是这里。<br>所以还是要提前准备啊，像这种题目，提前准备过和没准备回答出来的效果完全不一样。</p>
</blockquote>
</li>
</ol>
<h2 id="涂鸦移动内推（offer）"><a href="#涂鸦移动内推（offer）" class="headerlink" title="涂鸦移动内推（offer）"></a>涂鸦移动内推（offer）</h2><ul>
<li>一面（现场）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>项目介绍</li>
<li>数据库的索引原理</li>
<li>索引使用的注意事项</li>
<li>数据库的引擎</li>
<li>Java垃圾回收机制</li>
<li>Java的finalize，finally，final三个关键字的区别和应用场景</li>
<li>String类可以被继承么</li>
<li>手撕算法：假设你是一个专业的窃贼，准备沿着一条街打劫房屋。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：相邻的房子装着相互联系的防盗系统，且 当相邻的两个房子同一天被打劫时，该系统会自动报警。<br>给定一个非负整数列表，表示每个房子中存放的钱， 算一算，如果今晚去打劫，你最多可以得到多少钱 在不触动报警装置的情况下。</li>
</ol>
<ul>
<li>二面（电话）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>对游戏的了解</li>
<li>项目介绍</li>
<li>算法题：给一个整数数组，找到两个数使得他们的和等于一个给定的数 target。</li>
<li>红黑树</li>
<li>Redis的应用<blockquote>
<p>一面面试官说之前仔细看了我的博客，然后面试的内容就是让我讲一讲博客里写的内容，基本就是之前复习准备的数据库的知识，都游刃有余了。但感觉到自己讲的时候还是思维有点混乱，所以表达能力也很重要，有时间自己试着将一些常问的东西，自己私下表达一遍，尽量做到表达清楚专业有条理。<br>然后手撕算法，leetcode原题，打劫房屋，自己当时只记得题目，但方法不记得了，就现场推了一遍动态规划的状态方程，结果很幸运推了出来。（这个还是得靠前期的刷题的积累）<br>二面电话面问的比较简略，又用到了救命稻草redis，发现面试官都很喜欢问这个。可能因为是比较前沿的技术吧，现在企业用的比较多，但实际这个东西不是特别难。所以了解一下redis会很加分。<br>不久之后，收到涂鸦移动的offer，应该是第四个offer，自己也开始慢慢更有信心了。<br><strong>虽然最后没去涂鸦，但面试的过程也学习了不少东西，自己在表达能力方面还需要加强。所以每次面试我们或多或少都能有所收获，多面试多经历多体验！</strong></p>
</blockquote>
</li>
</ol>
<h2 id="中国电信it研发中心（offer）"><a href="#中国电信it研发中心（offer）" class="headerlink" title="中国电信it研发中心（offer）"></a>中国电信it研发中心（offer）</h2><ul>
<li>一面（现场）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>项目介绍</li>
<li>项目里用的什么服务器</li>
<li>自己写一个tomcat服务器，你会怎么写</li>
<li>分布式服务器会出现哪些问题</li>
<li>怎么解决session一致性缓存的问题</li>
<li>Redis的优势和特点</li>
<li>一千万用户并发抢购，怎么设计</li>
<li>如果成功的用户有10万，redis存不下怎么处理</li>
<li>你项目中的难点</li>
</ol>
<ul>
<li>二面（现场）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>项目介绍</li>
<li>介绍spring中的熟悉的注解</li>
<li>让你实现autowire注解的功能你会如何实现</li>
<li>Redis和mysql的区别</li>
<li>Redis的持久化有哪些方式，具体原理<blockquote>
<p>中国电信算是拿到的第一个比较满意的offer，虽然不是互联网大厂，但是薪资地点发展都感觉不错，当时考虑，如果后面没拿到大厂的offer就去电信养老了。<br>电信的面试官年纪偏大，问的问题也比较偏实践和设计，基本没问基础知识。<br>一面一上来就让我写一个tomcat服务器，石化，还好面试官比较和善，慢慢提示我，然后又问我怎么保持session的一致性，这个其实是比较常见的问题，我之前没见过，面试官让我现场想，最后我想到的答案正好是正确答案，然后面试官出的场景题，我就将redis往上面套，无非就是缓存，消息队列这些技术去处理那些高并发的问题。所以答得还不错。<br><strong>可以看出，有时候面到你不会的东西，如果你能在面试官的引导下回答出来是很加分的，可能因为看到你的思考能力吧，更看重你的潜力！</strong><br>二面还是聚焦在redis这一块，（redis救命稻草，如果放假在家那几天没看，感觉后面的offer都可能拿不到了）。</p>
</blockquote>
</li>
</ol>
<h2 id="中兴（offer）"><a href="#中兴（offer）" class="headerlink" title="中兴（offer）"></a>中兴（offer）</h2><ul>
<li>专业面（现场）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>项目介绍</li>
<li>你了解的设计模式，讲两个</li>
<li>Java collection类，集合，讲两个你了解的，说实现原理</li>
<li>Java线程池的作用</li>
<li>你觉得你在你实验室处于什么水平</li>
</ol>
<ul>
<li>综合面试（现场）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>说一下你知道的设计模式</li>
<li>画一个策略模式的uml图</li>
<li>Java多线程的理解</li>
<li>内存屏障是什么</li>
<li>数据库索引</li>
<li>项目中的优化</li>
<li>然后开始聊人生<blockquote>
<p>中兴软件岗的面试比较水，主要看你的学校背景。学校不错基本没问题</p>
</blockquote>
</li>
</ol>
<h2 id="百度（offer）"><a href="#百度（offer）" class="headerlink" title="百度（offer）"></a>百度（offer）</h2><ul>
<li>一面（现场）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>Java中的多态</li>
<li>Object类下的方法</li>
<li>Wait和notify的作用</li>
<li>Finalize的作用和使用场景</li>
<li>Hashcode和equals</li>
<li>为什么要同时重写hashcode和equals</li>
<li>不同时重写会出现哪些问题</li>
<li>Hashmap的原理</li>
<li>Hashmap如何变线程安全，每种方式的优缺点</li>
<li>垃圾回收机制</li>
<li>Jvm的参数你知道的说一下</li>
<li>设计模式了解的说一下啊</li>
<li>手撕一个单例模式</li>
<li>快速排序的思想讲一下</li>
<li>给个数组，模拟快排的过程</li>
<li>手写快排</li>
<li>设计题，一个图书馆管理系统，数据库怎么设计，需求自己定，题目很宽泛，面试官看你能考虑到哪些问题</li>
</ol>
<ul>
<li>二面（现场）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>项目介绍</li>
<li>Redis的特点</li>
<li>分布式事务了解么</li>
<li>反爬虫的机制，有哪些方式</li>
<li>手撕算法：反转单链表</li>
<li>手撕算法：实现类似微博子结构的数据结构，输入一系列父子关系，输出一个类似微博评论的父子结构图</li>
<li>手写java多线程</li>
<li>手写java的soeket编程，服务端和客户端</li>
<li>进程间的通信方式</li>
<li>手撕算法： 爬楼梯，写出状态转移方程</li>
<li>智力题：时针分针什么时候重合</li>
</ol>
<ul>
<li>三面（现场）</li>
</ul>
<ol>
<li>由于三面面试官不懂java，我不熟c加加，所以全程尬聊</li>
<li>自我介绍</li>
<li>项目介绍</li>
<li>项目难点</li>
<li>手撕算法：给定一个数字三角形，找到从顶部到底部的最小路径和。每一步可以移动到下面一行的相邻数字上。</li>
<li>然后继续在这个问题上扩展</li>
<li>求出最短那条的路径</li>
<li>递归求出所有的路径</li>
<li>设计模式讲一下熟悉的</li>
<li>会不会滥用设计模式</li>
<li>多线程条件变量为什么要在while体里，为什么不是if</li>
<li>你遇到什么挫折</li>
</ol>
<blockquote>
<p>百度三轮技术面，每面都在手撕代码，很注重代码能力，还有智力题，也是比较特别的。<br>一面主要聊了聊基础和写了简单的算法<br>二面一开始聊了聊项目，然后就开始手撕代码，先撕了翻转单链表（这个算法算是面试常考了，整个秋招写了三次这个算法），然后就撕了一个比较难的算法，微博子结构，代码比较难写，写的比较慢，面试官催了好几次，但还是写出了，面试官评价：“代码风格不错，但是写的太慢，笔试会吃亏”，确实吃亏，笔试挂了好多哈哈。然后又是一轮写，先写多线程，然后写socket，socket不会写，就直接说了。面试的时候，有些问题答不上来也不要慌，最后问了一个智力题，<br>三面遇到了语言不一样的面试官，于是就一直在写代码。<br>    百度的面试很要求手撕算法的能力，考察的比较全面，智力题场景题均有涉及。</p>
</blockquote>
<h2 id="美团内推（offer）"><a href="#美团内推（offer）" class="headerlink" title="美团内推（offer）"></a>美团内推（offer）</h2><ul>
<li>一面（电话）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>项目介绍</li>
<li>Redis介绍</li>
<li>了解redis源码么</li>
<li>了解redis集群么</li>
<li>Hashmap的原理</li>
<li>hashmap容量为什么是2的幂次</li>
<li>hashset的源码</li>
<li>object类你知道的方法</li>
<li>hashcode和equals</li>
<li>你重写过hashcode和equals么，要注意什么</li>
<li>假设现在一个学生类，有学号和姓名，我现在hashcode方法重写的时候，只将学号参与计算，会出现什么情况？</li>
<li>往set里面put一个学生对象，然后将这个学生对象的学号改了，再put进去，可以放进set么？并讲出为什么</li>
<li>Redis的持久化？有哪些方式，原理是什么？</li>
<li>讲一下稳定的排序算法和不稳定的排序算法</li>
<li>讲一下快速排序的思想</li>
</ol>
<ul>
<li>二面（现场）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>讲一下数据的acid</li>
<li>什么是一致性</li>
<li>什么是隔离性</li>
<li>Mysql的隔离级别</li>
<li>每个隔离级别是如何解决</li>
<li>Mysql要加上nextkey锁，语句该怎么写</li>
<li>Java的内存模型，垃圾回收</li>
<li>线程池的参数</li>
<li>每个参数解释一遍</li>
<li>然后面试官设置了每个参数，给了是个线程，让描述出完整的线程池执行的流程</li>
<li>Nio和IO有什么区别</li>
<li>Nio和aio的区别</li>
<li>Spring的aop怎么实现</li>
<li>Spring的aop有哪些实现方式</li>
<li>动态代理的实现方式和区别</li>
<li>Linux了解么</li>
<li>怎么查看系统负载</li>
<li>Cpu load的参数如果为4，描述一下现在系统处于什么情况</li>
<li>Linux，查找磁盘上最大的文件的命令</li>
<li>Linux，如何查看系统日志文件</li>
<li>手撕算法：leeetcode原题 22，Generate Parentheses</li>
</ol>
<ul>
<li>三面（现场）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>项目介绍</li>
<li>怎么管理项目成员</li>
<li>当意见不一致时，如何沟通开发成员，并举个例子</li>
<li>怎么保证项目的进度</li>
<li>数据库的索引原理</li>
<li>非聚簇索引和聚簇索引</li>
<li>索引的使用注意事项</li>
<li>联合索引</li>
<li>从底层解释最左匹配原则</li>
<li>Mysql对联合索引有优化么？会自动调整顺序么？哪个版本开始优化？</li>
<li>Redis的应用</li>
<li>Redis的持久化的方式和原理</li>
<li>技术选型，一个新技术和一个稳定的旧技术，你会怎么选择，选择的考虑有哪些</li>
<li>说你印象最深的美团技术团队的三篇博客</li>
<li>最近在学什么新技术</li>
<li>你是怎么去接触一门新技术的</li>
<li>会看哪些书</li>
<li>怎么选择要看的书</li>
</ol>
<blockquote>
<p>美团是拿到的第一个大厂offer，也是美团面完后心态更稳了。唉，最有效提升信心的方法就是拿到一个满意的offer！<br>整个美团流程比较长，由于是内推，9.7号接到电话面，电话面基本聊的基础，面试官很好，一直在引导。<br>9.20的现场面，二面一开始太紧张，数据库的四个特性不记得了，一个持久性死活想不起来，还好影响不大，后面答的都比较好，问到数据库的隔离级别，我主动引入到底层实现原理，回答问题的时候，可以主动延伸一下，尽量将自己会的表达出来。<br>面试之前，将牛客网上所有美团的面经扒了下来，看到很多出现率很高的问题，就提前准备了这些问题，果然在面试的时候碰到了，功夫不负有心人，准备工作没有白做。所以多刷牛客，多刷面经才是王道啊！<br>最后就是手撕算法，leetcode原题，生成括号，dfs问题。一贯套路，假装之前没见过这道题，先讲一个暴力法，然后再写出代码！由于leetcode刷了差不多两遍，所以很顺畅的写出来了。（像这类题，如果之前完全没刷过或者没见过，现场写出来并不容易）<br>三面就基本就是聊人生，偶尔带一点技术。<br>现在大厂的面试基本逃不过手写代码，基本上都是leetcode的中等难度的原题或者类似的题目，所以前期一定要多刷题，如果算法能力不强的话，这个只能靠硬实力了。</p>
</blockquote>
<h2 id="华为（offer）"><a href="#华为（offer）" class="headerlink" title="华为（offer）"></a>华为（offer）</h2><ul>
<li>一面（现场）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>项目介绍</li>
<li>项目架构</li>
<li>项目一个完整的执行流程（由于我是搞java的，而面试官是搞c的，所以全程尬聊）</li>
<li>项目优化</li>
</ol>
<ul>
<li>二面（现场）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>项目介绍</li>
<li>怎么管理项目进度</li>
<li>平常的爱好</li>
<li>感觉面试官也不是搞java的，所以又是一阵尬聊</li>
</ol>
<blockquote>
<p>华为软件岗的面试比较水，主要看你的学校背景。学校不错基本没问题</p>
</blockquote>
<h2 id="苏宁内推（offer）"><a href="#苏宁内推（offer）" class="headerlink" title="苏宁内推（offer）"></a>苏宁内推（offer）</h2><ul>
<li>一面（现场）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>项目介绍</li>
<li>面过哪些公司了</li>
<li>有哪些offer了</li>
<li>聊到多益，于是开始聊最近微博上很火的多益老板</li>
<li>得出结论，我和面试官都觉得多益老板三观有问题，但做游戏就是要偏执的人</li>
<li>你博客主要哪方面的</li>
<li>多线程并发包了解么</li>
<li>讲一下countDownLatch</li>
</ol>
<blockquote>
<p>面试过程就是聊人生，面试官先问了你有哪些offer。然后讨论了多益的老板的微博和价值观，估计是因为offer对实力也是一种认可，所以没怎么问技术就结束了，最后顺利拿到offer。（算是秋招拿的最容易的一个offer，就一轮面试聊了聊八卦就过了）但其他认识的同学，有被怼了50分钟技术的。<br>所以啊，面试这个东西看缘分，期望老天保佑遇到对味的面试官。</p>
</blockquote>
<h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><ul>
<li>一面（现场）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>项目介绍</li>
<li>Hibernate的作用，你对hibernate的理解</li>
<li>多线程的理解，如何保证线程安全</li>
<li>mysql数据库的引擎和区别</li>
<li>场景题：千万用户抢购，如何处理高并发，并且有一个链接，指向前一天抢购成功的用户，如何设计这个系统和数据库</li>
<li>如果后台处理抢购请求的服务器，每次最多承受200的负载，系统该怎么设计</li>
<li>手撕算法：最小公倍数和最大公约数</li>
</ol>
<ul>
<li>二面（现场）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>项目介绍</li>
<li>项目里一个完整请求的流程</li>
<li>项目的优化</li>
<li>Hibernate和mybatis的区别</li>
<li>为什么用ssh框架</li>
<li>Mysql的容灾备份</li>
<li>Redis和memcache 的区别</li>
<li>为什么选择redis</li>
<li>Java的full gc</li>
<li>Full gc会导致什么问题<blockquote>
<p>腾讯笔试似乎不怎么刷人（笔试做的很烂，依然收到了面试通知，周围认识的做了腾讯笔试的基本都收到了面试通知）。所以对待腾讯的笔试可以轻松一点。<br>一面是个小姐姐，基本问的都是很大问题，看你的发挥，没怎么问基础。没想到一面能过，二面是一位中年大叔，不言自威，气场略强，感觉答的还可以，最后还是挂了，可能因为真的不招java吧。<br>一面的面试官让我回去看一下分布式事务，然后我就真的看了，然后后面网易的面试都在问这个，如果没来面腾讯，估计后面网易也过不了。所以啊，面试真实一个学习的过程，不要错失大好的学习机会</p>
</blockquote>
</li>
</ol>
<h2 id="招银网络科技（offer）"><a href="#招银网络科技（offer）" class="headerlink" title="招银网络科技（offer）"></a>招银网络科技（offer）</h2><ul>
<li>一面（现场）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>写一个两个有序链表合并成一个有序链表</li>
<li>死锁是什么呢</li>
<li>怎么解决死锁</li>
<li>http请求流程</li>
<li>为什么负载均衡</li>
<li>怎么实现负载均衡</li>
<li>数据库挂了怎么办？除了热备份还有什么方法</li>
<li>讲讲你对spring的理解，不要把ioc和aop背给我听</li>
</ol>
<ul>
<li>二面（现场）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>项目介绍</li>
<li>算法：找出两个数组相等的数，不能用其他数据结构</li>
<li>算法：给定一个数字，一个数组，找出数组中相加等于这两个数的和，不能用数据结构</li>
<li>算法：如何判断一个树是不是另一颗树的子树</li>
<li>如何解决并发访问的错误</li>
</ol>
<blockquote>
<p>招银算是银行类的公司面试最专业的。<br>一面上来就是手撕算法，最后问spring的时候，问我对spring的理解，并且面试官提示我不要把ioc和aop背给我听，我就正好讲了自己的理解，ioc和aop都是为了降低代码侵入性和耦合度。所以，有时候一些常规的问题，我们最好能有自己的思考，如果是千篇一律的答案，并没有什么亮点，将自己的理解讲出来或许更好。<br>二面基本都是在问算法，讲思路就可以了，这个时候就看自己的算法能力了。<br>前期一定要多刷题！</p>
</blockquote>
<h2 id="网易（offer）"><a href="#网易（offer）" class="headerlink" title="网易（offer）"></a>网易（offer）</h2><ul>
<li>一面（现场）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>项目介绍</li>
<li>项目难点（疯狂怼）</li>
<li>I++操作是线程安全的么？怎么保证线程安全</li>
<li>场景题：设计一个下单系统，下单成功后可以给用户发优惠券</li>
<li>接上面场景题：服务器挂了，优惠券还没发怎么办</li>
<li>数据库挂了怎么怎么办</li>
<li>怎么保证一致性</li>
<li>分布式事务知道么</li>
<li>介绍分布式事务</li>
<li>你的职业规划</li>
</ol>
<ul>
<li>二面（现场）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>项目介绍（又是狂怼）</li>
<li>Nio的原理</li>
<li>Channel和buffer</li>
<li>directBuffer和buffer的区别</li>
<li>nio和aio的区别</li>
<li>锁的实现原理</li>
<li>怎么解决缓存和主存的一致性问题</li>
<li>缓存还没更新到主存，服务器挂了怎么办</li>
<li>数据库挂了怎么办</li>
</ol>
<blockquote>
<p>网易的面试感觉运气比较好。也跟自己心态有关，这个时候已经压力不大了，挂了也无所谓，但往往就是这种平常心去面试的时候，发挥的会更好。所以，心态真的很重要。<br>前两天腾讯面试官让下去了解的分布式事务，结果网易一面的场景题基本都是在这一块讨论，最后还具体问了分布式事务，正好现学现卖。所以，多面试，面试官说让你去了解，一定要去了解，多学习肯定没坏处。二面面试官听说我有博客，对我感觉不错，说很多程序员就缺乏总结的能力。平常积累的博客，感觉终于派上用场了，所以如果有空，维护一个技术博客，写写算法题解或者一些技术问题，就当是学习笔记。</p>
</blockquote>
<h2 id="携程（offer）"><a href="#携程（offer）" class="headerlink" title="携程（offer）"></a>携程（offer）</h2><ul>
<li>一面（现场）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>项目介绍</li>
<li>项目难点（讲到用了消息队列优化，被面试官夸了一波）</li>
<li>了解hashmap么？讲讲原理</li>
<li>知道java GC？讲讲过程（又背了一遍）</li>
<li>手撕算法，写二叉的后序非递归遍历</li>
<li>手撕算法，翻转单链表</li>
<li>手撕算法，背包问题<blockquote>
<p>携程的迷之测评，但面试还是相对基础，但也要求算法能力。第一个二叉的后序非递归遍历的算法题，算是校招中唯一一个没写出来的算法，不过最后在面试官提示下还是做出来了。</p>
</blockquote>
</li>
</ol>
<h2 id="今日头条（offer）"><a href="#今日头条（offer）" class="headerlink" title="今日头条（offer）"></a>今日头条（offer）</h2><ul>
<li>一面（视频）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>数据库优化有什么了解</li>
<li>索引的原理</li>
<li>联合索引，如果联合索引（a，b），现在查询a&gt;0,b&gt;0可以用到这个联合索引么？（太久没看，生疏了，答错了，答案应该是不能，只能用到a的索引，范围索引只能用到一列）</li>
<li>数据库优化中，有一个关键字可以分析执行过程，知道么（explain关键字）</li>
<li>Java虚拟机了解么?使用中有什么注意事项？</li>
<li>了解设计模式么？手写一个单例模式</li>
<li>写一个算法吧，一个二维数组，每一行从左到右递增，每一列从上到下递增，给一个数，判断他是否在在二维数组中，在返回下标，不在返回（-1，-1）</li>
<li>比较基础的算法题，要做到最优。</li>
<li>了解nio么？讲一下nio的理解。</li>
<li>Linux命令了解么？查看网络状态的命令，查看内存占用的命令。Awk命令。</li>
</ol>
<ul>
<li>二面（视频）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>http协议的chunk知道么？是干什么的？</li>
<li>http的状态码了解么？说一下</li>
<li>301和302的区别</li>
<li>502和503的区别（这么久没面，早忘了，然后被面试官教育了一番，说没有真正掌握这些知识）</li>
<li>Redis的数据结构的底层实现</li>
<li>Mysql集群数据是怎么同步的</li>
<li>手撕算法：一个链表，奇数位置递增，偶数位置递减，给链表排序。要求O(n)的时间复杂度</li>
<li>Select，poll，epoll的区别</li>
<li>数据库的索引原理</li>
<li>场景题，设计一个高并发的系统。</li>
</ol>
<ul>
<li>三面（视频）</li>
</ul>
<ol>
<li>自我介绍</li>
<li>服务器处理接受一个请求的过程</li>
<li>数据库的索引的原理</li>
<li>Innodb都是聚簇索引么？</li>
<li>设计一个文件分发系统，分发到10000台服务器，做到高效可靠，如何保证高效，如何保证可靠</li>
<li>有什么offer</li>
<li>你的优点缺点</li>
<li>你觉得你在同龄中处于什么水平</li>
</ol>
<blockquote>
<p>面头条的时候已经是十月底了。大半个月没有面试，之前准备的知识点比如http状态码之类的记忆性的东西，早就忘光了。<br>二面的时候问了一堆状态码，全都不记得了。面试官态度很好，跟我说，你现在不记得了，说明你这些知识只是为了面试临时抱佛脚，并没有深入理解，所以时间一长就忘了。确实是这样。<br>总的来说，头条的面试比较注重算法能力，两面都手写了算法，算法不算特别难，但是真正实现好，还是会有很多细节要考虑到，而且要写的代码都比较长。头条也比较喜欢出场景题，感觉面试官也没有标准答案，主要看你的回答和思路。<br>临时抱佛脚背的知识会忘掉，但刷题后的代码能力解题能力却是内功，可以说一劳永逸的，所以多刷题很重要，面试的时候代码写的好或许可以弥补有些问题没答上来。</p>
</blockquote>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>这张图是我对面试一个最直观的感受<br><img src="http://upload-images.jianshu.io/upload_images/1234352-afe83d6ce0d8472f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>回头看整个校招的面试过程，会发现面试就像在登山，你一定是往上爬的，只是爬得快慢之分，越面到后面，面试的越多，你的能力技巧经验都是越来越好！这是很多方面的因素造成的。</p>
<ol>
<li>实力的提升<br>面试同时也是一个学习和提高的机会，面试的越多，积累的经验，个人的能力和知识储备等各方面也都在慢慢提高，所以只要面试后及时总结，并努力去改进，实力就一定会有提升！</li>
<li>心态越来越好<br>传说“80%的offer掌握在20%的人手中”，其实不无道理。实力当然是面试成功拿到offer的重要部分，但心态的影响也是至关重要的，万事开头难，当你拿到第一个满意的offer的时候，后续的面试都会变得顺利起来，offer会越来越好拿，这就是良好的心态起了重要作用。反之，当你迟迟拿不到一个满意的offer，心态就会越来越不稳，offer会变的越来越难拿。<br>总结自己的面试过程，从美团面完基本确定可以拿到offer之后，整个人的心态就完全不一样了，更有底气和信心，反正已经有差不多满意的offer，后续的面试其实过不过反倒无所谓了。而往往就是这种无所谓的心态，也就是平常心，抱着去试一试玩一玩的心态，反而能在面试的时候发挥的更好，反而能在面试的时候显得更有自信更加从容，自然也就能够得到更好的结果。（面试的注意事项，面试的时候一定要保持自信，而不是慌乱，如果面试官感受到你的慌乱紧张而不是自信，那么显然会对你的实力有所怀疑）</li>
<li>运气<br>运气这个东西完全是看天意了。但是如果连续参加五场面试，运气都不好，问的全是不会的，会的全都不问。这个时候一定要稳住！就跟抛硬币一样，连续抛了五次反面，也算是倒霉透顶了，但是要相信概率，总有扔到正面的时候，只要你继续扔下去。同样的道理，只要你坚持面试下去，总会有运气好的时候，面试的越多，机会也就越多，一定要尽早尽量多的参加各种面试，尤其是当你没拿到满意offer的时候。</li>
</ol>
<p>最后在总结一下</p>
<ul>
<li>Offer = 0.3心态 + 0.5实力 + 0.2运气，缺一不可</li>
<li>越早开始准备越好，准备的越充分越好</li>
<li>切忌眼高手低。对于普通同学（大神除外），前期尽量多利用小公司的面试机会来锻炼自己，积累经验。</li>
<li>在面试的过程中找准自己的定位，并且适当的根据面试情况及时调整自己的定位和目标，保持信心，但不能盲目自信。不管是大公司还是小公司，尽早拿到第一个offer。</li>
<li>心态要及时调整好！</li>
<li>不管面试失败还是成功，都一定要及时总结！</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 面试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java源码剖析之LinkedList]]></title>
      <url>/2017/08/06/Java%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8BLinkedList/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li>本文对LinkedList的实现讨论都基于JDK8版本</li>
</ul>
</blockquote>
<p>Java中的LinkedList类实现了List接口和Deque接口，是一种链表类型的数据结构，支持高效的插入和删除操作，同时也实现了Deque接口，使得LinkedList类也具有队列的特性。LinkedList类的底层实现的数据结构是一个双端的链表。<br><a id="more"></a><br>LinkedList类中有一个内部私有类Node，这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。<br>源码中的实现是这样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意这个节点的初始化方法，给定三个参数，分别前驱节点，本节点的值，后继结点。这个方法将在LinkedList的实现中多次调用。</p>
<p>下图是LinkedList内部结构的可视化，能够帮我们更好的理解LinkedList内部的结构。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-017c08bac47cff38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>双端链表由node组成，每个节点有两个reference指向前驱节点和后继结点，第一个节点的前驱节点为null，最后一个节点的后继节点为null。</p>
<p>LinkedList类有很多方法供我们调用。我们不会一一介绍，本文会详细介绍其中几个最核心最基本的方法，LinkedList的创建添加和删除基本都和这几个操作有关。</p>
<ul>
<li>linkFirst() method<br>首先我们介绍第一个方法，linkFirst（），顾名思义，这个方法是插入第一个节点，我们先直接上代码，看看它的具体实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Links e as first element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">        first = newNode;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            last = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我们发现出现了两个变量，first和last这两个变量是LinkedList的成员变量，分别指向头结点和尾节点。他们是如下定义的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to first node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to last node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>
<p>我们可以看到注释中的内容。first和last需要维持一个不变量，也就是first和last始终都要维持两种状态：<br>首先，如果双端链表为空的时候，两个都必须为null<br>如果链表不为空，那么first的前驱节点一定是null，first的item一定不为null，同理，last的后继节点一定是null，last的item一定不为null。</p>
<p>知道了first和last之后，我们就可以开始分析linkFirst的代码了。<br>linkFirst的作用就是在first节点的前面插入一个节点，插入完之后，还要更新first节点为新插入的节点，并且同时维持last节点的不变量。</p>
<p>我们开始分析代码，首先用f来临时保存未插入前的first节点，然后调用的node的构造函数新建一个值为e的新节点，这个节点插入之后将作为first节点，所以新节点的前驱节点为null，值为e，后继节点是f,也就是未插入前的first节点。<br>然后就是维持不变量，首先第一种情况，如果f==null，那就说明插入之前，链表是空的，那么新插入的节点不仅是first节点还是last节点，所以我们要更新last节点的状态，也就是last现在要指向新插入的newNode。<br>如果f!=null那么就说明last节点不变，但是要更新f的前驱节点为newNode，维持first节点的不变量。<br>最后size加一就完成了操作。</p>
<ul>
<li>linkLast() method<br>分析了linkFirst方法，对于 linkLast()的代码就很容易理解了，只不过是变成了插入到last节点的后面。我们直接看代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Links e as last element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>到这里我们发现有这个两个方法，我们已经可以实现一个简单队列的插入操作，上面两个方法就可以理解为插入队头元素和队尾元素，这也说明了LinkedList是实现了Deque接口的。<br>从源码中也可以看出，addfirst和addLast这两个方法内部就是直接调用了linkFirst和LinkLast<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the beginning of this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #add&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>linkBefore(E e, Node<e> succ)<br>下面我们看一个linkBefore方法,从名字可以看出这个方法是在给定的节点前插入一个节点，可以说是linkFirst和linkLast方法的通用版。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts element e before non-null Node succ.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert succ != null;</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</e></li>
</ul>
<p>我们可以看到代码的实现原理基本和前面的两个方法一致，这里是假设插入的这个节点的位置是非空的。</p>
<ul>
<li>add(int index, E element)<br>下面我们看add方法，这个方法就是最常用的，在指定下标插入一个节点。我们先来看下源码的实现，很简单<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the specified position in this list.</span></span><br><span class="line"><span class="comment">     * Shifts the element currently at that position (if any) and any</span></span><br><span class="line"><span class="comment">     * subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == size)</span><br><span class="line">            linkLast(element);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>首先判断给定的index是不是合法的，然后如果index==size，就说明要插入成为最后一个节点，直接调用linklast方法，否则就调用linkBefore方法，我们知道linkBefore需要给定两个参数，一个插入节点的值，一个指定的node，所以我们又调用了Node(index)去找到index的那个node。<br>我们看一下Node<e> node(int index)方法，这个方法就是找到给定index的node并返回，类似于数组的随机读取，但由于这里是链表，所以要进行查找<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></e></p>
<p>我们看到node的实现并不是像我们想象的那样直接就线性从头查找，而是折半查找，有一个小优化，先判断index在前半段还是后半段，如果在前半段就从头开始找，如果在后半段就从后开始找，这样最坏情况也只要找一半就可以了。</p>
<p>LinkedList的源码实现并不复杂，我们只介绍这几个方法，相信你一定对于它的内部实现原理有了一定的了解，并且也学习到了优秀的代码书写风格和优化。<br>对于remove操作，有兴趣的读者可以自行研究代码，它类似于add操作，也是基于三个基本方法来实现的。</p>
<ul>
<li>unlinkFirst(Node<e> f)</e></li>
<li>unlinkLast(Node<e> l)</e></li>
<li>unlink(Node<e> x)</e></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Java_Runtime_Area_Java运行时数据区]]></title>
      <url>/2017/08/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java-Runtime-Area-Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li>Java Runtime Area的分类</li>
<li>从线程的角度理解Java Runtime Area</li>
<li>从存储内容理解Java Runtime Area</li>
<li>方法区中究竟存储了哪些信息？</li>
<li>基本数据类型的成员变量放在jvm的哪块内存区域里？</li>
</ul>
</blockquote>
<h1 id="Java-Runtime-Area的分类"><a href="#Java-Runtime-Area的分类" class="headerlink" title="Java Runtime Area的分类"></a>Java Runtime Area的分类</h1><p>Java Runtime Area主要可以分为六部分 ：</p>
<ul>
<li>Program Counter (PC) Register <strong>程序计数器</strong></li>
<li>Java Virtual Machine Stacks <strong>Java虚拟机栈</strong></li>
<li>Heap Memory <strong>Java堆</strong></li>
<li>Method Area <strong>方法区</strong></li>
<li>Run-time Constant Pool <strong>运行时常量池</strong></li>
<li>Native Method Stacks <strong>本地方法栈</strong></li>
</ul>
<p>具体的每个区域的内容和特点可以参考《深入理解Java虚拟机》,此书已经讲的很详细了。<br>下面我们对这几个数据区域进行分类，分别从不同的视角来分析，加深我们的理解<br><a id="more"></a></p>
<h1 id="从线程的角度理解Java-Runtime-Area"><a href="#从线程的角度理解Java-Runtime-Area" class="headerlink" title="从线程的角度理解Java Runtime Area"></a>从线程的角度理解Java Runtime Area</h1><p>首先，我们从区域是否是线程私有的还是所有线程共享的来分类：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-bb8dfe34ff930c48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>程序计数器</strong> <strong>Java虚拟机栈</strong> <strong>本地方法栈</strong>都是线程私有的<br>而<br><strong>Java堆**</strong>方法区<strong>**运行时常量池</strong>都是所有线程共享的</p>
<p>进一步理解：</p>
<ul>
<li><p>对于线程私有的数据区域<strong>程序计数器</strong> <strong>Java虚拟机栈</strong> <strong>本地方法栈</strong>，他们的生存周期都是一致的，都是<br>随着线程开始，而进行初始化<br>随着线程结束而销毁</p>
</li>
<li><p>而对于线程共享的数据区域<strong>Java堆**</strong>方法区<strong>**运行时常量池</strong>，他们的生存周期都是一致的<br>随着JVM的启动而分配内存<br>随着JVM的关闭而销毁</p>
</li>
</ul>
<h1 id="从存储内容理解Java-Runtime-Area"><a href="#从存储内容理解Java-Runtime-Area" class="headerlink" title="从存储内容理解Java Runtime Area"></a>从存储内容理解Java Runtime Area</h1><p>下面我们再根据不同区域所存储的数据类型进行分类：<br>可以分为三类</p>
<ul>
<li>方法区和常量池存储类的信息</li>
<li>堆内存存储对象信息</li>
<li>程序计数器，Java虚拟机栈，本地方法栈存储线程的信息</li>
</ul>
<p>下图很清楚的说明</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-aaddf27e9f7d6760.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>The heap space holds object data, the method area holds class code, and the native area holds references to the code and object data.</strong><br><strong>堆存储object的data，方法区存储class的信息和code，native区域存储指向class信息和code的引用和指向对象的data的引用</strong></p>
<p>下面这个图更详细的指出了三个区域存储的内容：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-e579520e739ca462.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>下面我们通过一个实际代码的例子，来说明;</p>
<p>看下面这段代码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-ee63b791ee5c52dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这段代码编译之后，就存储成如下这个样子：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-bc710a2b26387c3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="易混淆的Java-Runtime-Area-的问题"><a href="#易混淆的Java-Runtime-Area-的问题" class="headerlink" title="易混淆的Java Runtime Area 的问题"></a>易混淆的Java Runtime Area 的问题</h1><p>下面我们会对关于Java 运行时数据区易混淆的问题进行释疑</p>
<h2 id="方法区中究竟存储了哪些信息？"><a href="#方法区中究竟存储了哪些信息？" class="headerlink" title="方法区中究竟存储了哪些信息？"></a>方法区中究竟存储了哪些信息？</h2><p>栈中存放了局部变量表等与方法有关的信息，但方法中还有指令代码这一重要内容，它既没有放在栈(Stack)中也没放在堆(Heap)中，那它放在哪呢？<br>其实，方法区中除了包括你所说的“已加载的类的基本信息、常量、静态变量等”外，还包括编译器编译后的代码，而且这应该是方法区中主要的一部分，毕竟类中主要是方法和属性，而类中的属性，如果是实例域的话则新建对象后存储在堆(Heap)中，静态的话就如你所说存储在方法区中，因此该区域中方法占主要部分，这应该是此运行时数据区称为方法区的原因吧。</p>
<h2 id="基本数据类型的成员变量放在jvm的哪块内存区域里？"><a href="#基本数据类型的成员变量放在jvm的哪块内存区域里？" class="headerlink" title="基本数据类型的成员变量放在jvm的哪块内存区域里？"></a>基本数据类型的成员变量放在jvm的哪块内存区域里？</h2><p>比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有的朋友可能因为基本数据类型，就认为存储在栈中。但其实是存储在堆中的，因为这是属于对象的信息，每个对象都拥有不同的实例变量，这些实例变量都存储在堆中，不管是基本数据类型还是引用数据类型<br>ava虚拟机栈是线程私有的，生命周期跟线程相同，每个方法调用的时候都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每个方法调用的过程，就代表了一个栈帧在虚拟机栈中入栈到出栈的过程，当进入一个方法时，这个方法在栈中需要分配多大的内存都是完全确定的，方法运行时不会改变局部变量表的大小——《深入理解java虚拟机第二版》<br>很多java程序员一开始就被网上的一些教程所误导：基本数据类型放在栈中，数组和类的实例放在堆中。 这个说法不准确，事实上，如上面的实例变量i，他是存放在java堆中。因为它不是静态的变量，不会独立于类的实例而存在，而该类实例化之后，放在堆中，当然也包含了它的属性i。<br>如果在方法中定义了int i = 0;则在局部变量表创建了两个对象：引用i和0。 这两个对象都是线程私有（安全）的。 比如定义了int[] is = new int[10]. 定义了两个对象，一个是is引用，放在局部变量表中，一个是长度为10的数组，放在堆中，这个数组，只能通过is来访问，方法结束后出栈，is被销毁，根据java的根搜索算法，判断数组不可达，就将它销毁了。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java源码剖析之ArrayList]]></title>
      <url>/2017/08/05/Java%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8BArrayList/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li>ArrayList使用的存储的数据结构</li>
<li>ArrayList的初始化</li>
<li>ArrayList是如何动态增长</li>
<li>ArrayList如何实现元素的移除</li>
<li>ArrayList小结<a id="more"></a>
ArrayList是我们经常使用的一个数据结构，我们通常把其用作一个可变长度的动态数组使用，大部分时候，可以替代数组的作用，我们不用事先设定ArrayList的长度，只需要往里不断添加元素即可，ArrayList会动态增加容量。ArrayList是作为List接口的一个实现。<br>那么ArrayList背后使用的数据结构是什么呢？<br>ArrayList是如何保证动态增加容量，使得能够正确添加元素的呢？</li>
</ul>
</blockquote>
<p>要回答上面的问题，我们就需要对ArrayList的源码进行一番分析，深入了解其实现原理的话，我们就自然能够解答上述问题。</p>
<blockquote>
<p>需要说明的是，本文所分析的源码引用自JDK 8版本</p>
</blockquote>
<h1 id="ArrayList使用的存储的数据结构"><a href="#ArrayList使用的存储的数据结构" class="headerlink" title="ArrayList使用的存储的数据结构"></a>ArrayList使用的存储的数据结构</h1><p>从源码中我们可以发现，ArrayList使用的存储的数据结构是Object的对象数组。<br>其实这也不能想象，我们知道ArrayList是支持随机存取的类似于数组，所以自然不可能是链表结构。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">     * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">     * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure></p>
<p>我想大家一定对这里出现的transient关键字很疑惑，我们都知道ArrayList对象是可序列化的，但这里为什么要用transient关键字修饰它呢？查看源码，我们发现ArrayList实现了自己的readObject和writeObject方法，所以这保证了ArrayList的可序列化。具体序列化的知识我们在此不过多赘述。有兴趣的读者可以参考笔者关于序列化的文章。</p>
<h1 id="ArrayList的初始化"><a href="#ArrayList的初始化" class="headerlink" title="ArrayList的初始化"></a>ArrayList的初始化</h1><p>ArrayList提供了三个构造函数。下面我们依次来分析</p>
<ul>
<li>public ArrayList(int initialCapacity) 当我们初始化的时候，给ArrayList指定一个初始化大小的时候，就会调用这个构造方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; myList = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">7</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>源码中这个方法的实现如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment">     *         is negative</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的EMPTY_ELEMENTDATA 实际上就是一个共享的空的Object数组对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上述代码很容易理解，如果用户指定的初始化容量大于0，就new一个相应大小的数组，如果指定的大小为0，就复制为共享的那个空的Object数组对象。如果小于0，就直接抛出异常。</p>
<ul>
<li>public ArrayList() 默认的空的构造函数。<br>我们一般会这么使用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myList = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>源码中的实现是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中DEFAULTCAPACITY_EMPTY_ELEMENTDATA 定义为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">     * first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注释中解释的很清楚，就是说刚初始化的时候，会是一个共享的类变量，也就是一个Object空数组，当第一次add的时候，这个数组就会被初始化一个大小为10的数组。</p>
<ul>
<li>public ArrayList(Collection&lt;? extends E&gt; c) 如果我们想要初始化一个list，这个list包含另外一个特定的collection的元素，那么我们就可以调用这个构造函数。<br>我们通常会这么使用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		set.add(<span class="number">1</span>);</span><br><span class="line">		set.add(<span class="number">2</span>);</span><br><span class="line">		set.add(<span class="number">3</span>);</span><br><span class="line">		set.add(<span class="number">4</span>);</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(set);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>源码中是这么实现的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment">     * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment">     * iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>首先调用给定的collection的toArray方法将其转换成一个Array。<br>然后根据这个array的大小进行判断，如果不为0，就调用Arrays的copyOf的方法，复制到Object数组中，完成初始化，如果为0，就直接初始化为空的Object数组。</p>
<h1 id="ArrayList是如何动态增长"><a href="#ArrayList是如何动态增长" class="headerlink" title="ArrayList是如何动态增长"></a>ArrayList是如何动态增长</h1><p>当我们像一个ArrayList中添加数组的时候，首先会先检查数组中是不是有足够的空间来存储这个新添加的元素。如果有的话，那就什么都不用做，直接添加。如果空间不够用了，那么就根据原始的容量增加原始容量的一半。<br>源码中是如此实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>ensureCapacityInternal的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>DEFAULT_CAPACITY为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<p>这也就实现了当我们不指定初始化大小的时候，添加第一个元素的时候，数组会扩容为10.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数判断是否需要扩容，如果需要就调用grow方法扩容<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment">     * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到grow方法将数组扩容为原数组的1.5倍，调用的是Arrays.copy<br>方法。<br>在jdk6及之前的版本中，采用的还不是右移的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> newCapacity = (oldCapacity * <span class="number">3</span>)/<span class="number">2</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>现在已经优化成右移了。</p>
<h1 id="ArrayList如何实现元素的移除"><a href="#ArrayList如何实现元素的移除" class="headerlink" title="ArrayList如何实现元素的移除"></a>ArrayList如何实现元素的移除</h1><p>我们移除元素的时候，有两种方法，一是指定下标，二是指定对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.remove(<span class="number">3</span>);<span class="comment">//index</span></span><br><span class="line">list.remove(<span class="string">"aaa"</span>);<span class="comment">//object</span></span><br></pre></td></tr></table></figure></p>
<p>下面先来分析第一种，也就是</p>
<ul>
<li>public E remove(int index)<br>源码中是如此实现的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the element at the specified position in this list.</span></span><br><span class="line"><span class="comment">     * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment">     * indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the element that was removed from the list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对于数组的元素删除算法我们应该很熟悉，删除一个数组元素，我们需要将这个元素后面的元素全部向前移动，并将size减1.<br>我们看到源码中，首先检查下标是否在可用范围内。然后调用System.arrayCopy方法将右边的数组向左移动，并且将size减一，并置为null。</p>
<ul>
<li>public boolean remove(Object o)<br>源码中实现如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the first occurrence of the specified element from this list,</span></span><br><span class="line"><span class="comment">     * if it is present.  If the list does not contain the element, it is</span></span><br><span class="line"><span class="comment">     * unchanged.  More formally, removes the element with the lowest index</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;(o==null ? get(i)==null : o.equals(get(i)))&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list</span></span><br><span class="line"><span class="comment">     * contained the specified element (or equivalently, if this list</span></span><br><span class="line"><span class="comment">     * changed as a result of the call).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，这个remove方法会移除数组中第一个符合的给定对象，如果不存在就什么也不做，如果存在多个只移除第一个。<br>fastRemove方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the first occurrence of the specified element from this list,</span></span><br><span class="line"><span class="comment">     * if it is present.  If the list does not contain the element, it is</span></span><br><span class="line"><span class="comment">     * unchanged.  More formally, removes the element with the lowest index</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;(o==null ? get(i)==null : o.equals(get(i)))&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list</span></span><br><span class="line"><span class="comment">     * contained the specified element (or equivalently, if this list</span></span><br><span class="line"><span class="comment">     * changed as a result of the call).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以理解为简化版的remove（index）方法。</p>
<h1 id="ArrayList小结"><a href="#ArrayList小结" class="headerlink" title="ArrayList小结"></a>ArrayList小结</h1><ul>
<li><p>ArrayList是List接口的一个可变大小的数组的实现</p>
</li>
<li><p>ArrayList的内部是使用一个Object对象数组来存储元素的</p>
</li>
<li><p>初始化ArrayList的时候，可以指定初始化容量的大小，如果不指定，就会使用默认大小，为10</p>
</li>
<li><p>当添加一个新元素的时候，首先会检查容量是否足够添加这个元素，如果够就直接添加，如果不够就进行扩容，扩容为原数组容量的1.5倍</p>
</li>
<li><p>当删除一个元素的时候，会将数组右边的元素全部左移</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入解析Java垃圾回收机制]]></title>
      <url>/2017/08/05/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li>引入垃圾回收</li>
<li>哪些内存需要回收？<ul>
<li>引用计数法<ul>
<li>可达性分析</li>
</ul>
</li>
</ul>
</li>
<li>如何回收<ul>
<li>Marking 标记</li>
<li>Normal Deletion 清除</li>
<li>Deletion with Compacting 压缩</li>
</ul>
</li>
<li>为什么需要分代收集？</li>
<li>JVM的分代<ul>
<li>新生代</li>
<li>老年代</li>
<li>永久代</li>
</ul>
</li>
<li>分代垃圾收集过程详述<a id="more"></a>
</li>
</ul>
</blockquote>
<h1 id="引入垃圾回收"><a href="#引入垃圾回收" class="headerlink" title="引入垃圾回收"></a>引入垃圾回收</h1><blockquote>
<p>程序计数器、 虚拟机栈、 本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。 每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器<br>进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。 而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存—–《深入理解Java虚拟机》</p>
</blockquote>
<p>自动垃圾回收机制就是寻找Java堆中的对象，并对对象进行分类判别，寻找出正在使用的对象和已经不会使用的对象，然后把那些不会使用的对象从堆上清除。<br>自动垃圾回收机制就是要解决三个问题：</p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
<h1 id="哪些内存需要回收？"><a href="#哪些内存需要回收？" class="headerlink" title="哪些内存需要回收？"></a>哪些内存需要回收？</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>对于第一个问题，也就是判断是否还需要使用，最简单的方法就是通过目前是否有引用指向这个对象，如果没有就说明这个对象不会再被使用了，如果有就说明这个对象可能还会继续被使用，这种通过引用是否存在的方法就叫做引用计数法，但这个方法存在一个问题就是无法解决对象循环引用的问题，因此又出现了可达性分析的方法来判断对象是否可以被会回收。</p>
<p>##可达性分析<br>这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。<br>在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
</ul>
<h1 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h1><p>垃圾收集器通常会帮我们在后台自动进行垃圾回收。关于具体的回收过程只要有以下这些步骤</p>
<ul>
<li>Step 1: Marking 标记</li>
</ul>
<p>第一步就是标记，也就是垃圾收集器会找出那些需要回收的对象所在的内存和不需要回收的对象所在的内存，并把它们标记出来，简单的说，也就是先找出垃圾在哪</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-420049faf427a7ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>所有堆中的对象都会被扫描一遍，以此来确定回收的对象，所以这通常会是一个相对比较耗时的过程</p>
<ul>
<li>Step 2: Normal Deletion<br>垃圾收集器会清除掉上一步标记出来的那些需要回收的对象区域</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-8a00dad3f360aaae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>存在的问题就是碎片问题：<br>标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程<br>序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 </p>
<ul>
<li>Step 2a: Deletion with Compacting 压缩<br>由于简单的清除可能会存在碎片的问题，所以又出现了压缩清除的方法，也就是先清除需要回收的对象，然后再对内存进行压缩操作，将内存分成可用和不可用两大部分</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-9a5942233a60c0bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="为什么需要分代收集？"><a href="#为什么需要分代收集？" class="headerlink" title="为什么需要分代收集？"></a>为什么需要分代收集？</h1><p>就像前文所述，标记对象和压缩内存的过程在JVM中是不高效的，分配的对象越多，垃圾收集的时间就越长。但是，经过一些经验型性的统计分析表明，一个程序中大部分对象都是短命的！</p>
<p>下图就是一个类似的统计数据，纵坐标表示分配对象所占用的内存大小，横坐标表示自分配对象过去的时间</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-32fa64dd7cfd57a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从图中我们看到，大部分对象没活多久就死了，存活较久的只是少类对象</p>
<h1 id="JVM的分代"><a href="#JVM的分代" class="headerlink" title="JVM的分代"></a>JVM的分代</h1><p>为了增大垃圾收集的效率，所以JVM将堆进行分代，分为不同的部分，一般有三部分，新生代，老年代和永久代</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-80d8ad7f6a126106.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><p>所有新new出来的对象都会最先出现在新生代中，当新生代这部分内存满了之后，就会发起一次垃圾收集事件，这种发生在新生代的垃圾收集称为Minor collections。这种收集通常比较快，因为新生代的大部分对象都是需要回收的，那些暂时无法回收的就会被移动到老年代。</p>
<p><strong>Stop the World</strong>事件-所有minor garbage collections都是<strong>Stop the World</strong>事件，也就是意味着所有的应用线程都需要停止，直到垃圾回收的操作全部完成。类似于<br>“你妈妈在给你打扫房间的时候，肯定也会让你老老实实地在椅子上或者房间外待着，如果她一边打扫，你一边乱扔纸屑，这房间还能打扫完？”</p>
<h2 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h2><p>老年代用来存储那些存活时间较长的对象。一般来说，我们会给新生代的对象限定一个存活的时间，当达到这个时间还没有被收集的时候就会被移动到老年代中。老年代区域的垃圾收集叫做major garbage collection</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-b08bf6069ee7366c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>Major garbage collection也是一个<strong>Stop the World</strong>事件。通常Major garbage collection都相对比较慢，因为老年代的收集包括了对所有对象的收集，也就是同时需要收集新生代和老年代的对象。</p>
<h2 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h2><p>The Permanent generation contains metadata required by the JVM to describe the classes and methods used in the application. The permanent generation is populated by the JVM at runtime based on classes in use by the application. In addition, Java SE library classes and methods may be stored here.</p>
<p>Classes may get collected (unloaded) if the JVM finds they are no longer needed and space may be needed for other classes. The permanent generation is included in a full garbage collection.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-f7f32e39af803854.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="分代垃圾收集过程详述"><a href="#分代垃圾收集过程详述" class="headerlink" title="分代垃圾收集过程详述"></a>分代垃圾收集过程详述</h1><p>我们已经知道垃圾回收所需要的方法和堆内存的分代，那么接下来我们就来具体看一下垃圾回收的具体过程</p>
<ul>
<li>第一步 所有new出来的对象都会最先分配到新生代区域中，两个survivor区域初始化是为空的</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-ed812d174ca6c8c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>第二步，当eden区域满了之后，就引发一次 minor garbage collection</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-d3746363a41a7c3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>第三步，当在minor garbage collection，存活下来的对象就会被移动到S0survivor区域</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-eb04dc5ddf426ba1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>第四步，然后当eden区域又填满的时候，又会发生下一次的垃圾回收，存活的对象会被移动到survivor区域而未存活对象会被直接删除。但是，不同的是，在这次的垃圾回收中，存活对象和之前的survivor中的对象都会被移动到s1中。一旦所有对象都被移动到s1中，那么s2中的对象就会被清除，仔细观察图中的对象，数字表示经历的垃圾收集的次数。目前我们已经有不同的年龄对象了。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-2ef7443435b7de67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>第五步，下一次垃圾回收的时候，又会重复上次的步骤，清除需要回收的对象，并且又切换一次survivor区域，所有存活的对象都被移动至s0。eden和s1区域被清除。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-c4ca47aa891ffeb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>第六步，重复以上步骤，并记录对象的年龄，当有对象的年龄到达一定的阈值的时候，就将新生代中的对象移动到老年代中。在本例中，这个阈值为8.</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-3a5073d424ad3778.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>第七步，接下来垃圾收集器就会重复以上步骤，不断的进行对象的清除和年代的移动</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-038cdad64f06b7a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>最后，我们观察上述过程可以发现，大部分的垃圾收集过程都是在新生代进行的，直到老年代中的内存不够用了才会发起一次 major GC，会进行标记和整理压缩。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-a4fee4707be5d7e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈Java为什么需要NIO]]></title>
      <url>/2017/08/01/%E6%B5%85%E8%B0%88Java%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81NIO/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li>IO</li>
<li>NIO</li>
<li>小结<a id="more"></a>
<h1 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h1>I/O ? 或者输入/输出 ? 指的是计算机与外部世界或者一个程序与计算机的其余部分的之间的接口。它对于任何计算机系统都非常关键，因而所有 I/O 的主体实际上是内置在操作系统中的。单独的程序一般是让系统为它们完成大部分的工作。<br>在 Java 编程中，直到最近一直使用 流 的方式完成 I/O。所有 I/O 都被视为单个的字节的移动，通过一个称为 Stream 的对象一次移动一个字节。流 I/O 用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象。<br>传统流IO的好处是使用简单，将底层的机制都抽象成流，但缺点就是性能不足。而且IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。<br>以socket.read()为例子：<br>传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。</li>
</ul>
</blockquote>
<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h2 id="为什么要使用-NIO"><a href="#为什么要使用-NIO" class="headerlink" title="为什么要使用 NIO?"></a>为什么要使用 NIO?</h2><p>NIO 的创建目的是为了让 Java 程序员可以实现高速 I/O 而无需编写自定义的本机代码。NIO 将最耗时的 I/O 操作(即填充和提取缓冲区)转移回操作系统，因而可以极大地提高速度。</p>
<h2 id="流与块的比较"><a href="#流与块的比较" class="headerlink" title="流与块的比较"></a>流与块的比较</h2><p>原来的 I/O 库(在 java.io.*中) 与 NIO 最重要的区别是数据打包和传输的方式。正如前面提到的，原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。<br>面向流 的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。<br>一个 面向块 的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<h2 id="NIO的buffer机制"><a href="#NIO的buffer机制" class="headerlink" title="NIO的buffer机制"></a>NIO的buffer机制</h2><p>NIO性能的优势就来源于缓冲的机制，不管是读或者写都需要以块的形式写入到缓冲区中。NIO实际上让我们对IO的操作更接近于操作系统的实际过程。<br>所有的系统I/O都分为两个阶段：等待就绪和操作。举例来说，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。<br>以socket为例：<br>先从应用层获取数据到内核的缓冲区，然后再从内核的缓冲区复制到进程的缓冲区。所以实际上底层的机制也是不断利用缓冲区来读写数据的。即使传统IO抽象成了从流直接读取数据，但本质上也依然是利用缓冲区来读取和写入数据。<br>所以，为了更好的理解nio，我们就需要知道IO的底层机制，这样对我们将来理解channel和buffer就打下了基础。这里简单提一下，我们可以把bufffer就理解为内核缓冲区，所以不论读写，自然都要经过这个区域，读的话，先从设备读取数据到内核，再读到进程缓冲区，写的话，先从进程缓冲区写到内核，再从内核写回设备。</p>
<h2 id="NIO的非阻塞机制"><a href="#NIO的非阻塞机制" class="headerlink" title="NIO的非阻塞机制"></a>NIO的非阻塞机制</h2><p>NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<p>下图是几种常见I/O模型的对比：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-59ba30bb45c8b91e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>以socket.read()为例子：</p>
<p>传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。</p>
<p>对于NIO，如果TCP RecvBuffer有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。所以我们可以NIO实现同时监听多个IO通道，然后不断的轮询寻找可以读写的设备。</p>
<p>NIO的IO模型可以理解为是IO多路复用模型和非阻塞模型，同时还有事件驱动模型。<br>这里需要知道一点，就是IO多路复用是一定需要实现非阻塞的。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>NIO相对于IO流的优势：</p>
<ul>
<li>非阻塞</li>
<li>buffer机制</li>
<li>流替代块</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">https://tech.meituan.com/nio.html</a></li>
<li><a href="http://www.importnew.com/19816.html" target="_blank" rel="noopener">http://www.importnew.com/19816.html</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> NIO </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaNIO之Channel和Buffer]]></title>
      <url>/2017/08/01/JavaNIO%E4%B9%8BChannel%E5%92%8CBuffer/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li>Channel</li>
<li>Channel Characteristics</li>
<li>Java NIO Channel Classes</li>
<li>buffer</li>
<li>什么是缓冲区？</li>
<li>缓冲区类型</li>
<li>缓冲区内部细节</li>
<li>NIO Buffer Characteristics</li>
<li>How to Read from NIO Buffer</li>
<li>How to Write to NIO Buffer</li>
<li>Java NIO 读写文件实例程序<a id="more"></a>
<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1></li>
</ul>
</blockquote>
<p>Java NIO中，channel用于数据的传输。类似于传统IO中的流的概念。channel的两端是buffer和一个entity，不同于IO中的流，channel是双向的，既可以写入，也可以读取。而流则是单向的，所以channel更加灵活。我们在读取数据或者写入数据的时候，都必须经过channel和buffer，也就是说，我们在读取数据的时候，先利用channel将IO设备中的数据读取到buffer，然后从buffer中读取，我们在写入数据的时候，先将数据写入到buffer，然后buffer中的数据再通过channel传到IO设备中。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-eda4f3ff7b1c587f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们知道NIO的特点就是将IO操作更加类似于底层IO的流程。<br>我们可以通过底层IO的机制更好的理解channel。</p>
<p>所有的系统I/O都分为两个阶段：等待就绪和操作。</p>
<ul>
<li>等待就绪就是从IO设备将数据读取到内核中的过程。</li>
<li>操作就是将数据从内核复制到进程缓冲区的过程。</li>
</ul>
<p>channel就可以看作是IO设备和内核区域的一个桥梁，凡是与IO设备交互都必须通过channel，而buffer就可以看作是内核缓冲区。这样整个过程就很好理解了。</p>
<p>我们看一下读取的过程<br>先从IO设备，网卡或者磁盘将内容读取到内核中，对应于NIO就是从网卡或磁盘利用channel将数据读到buffer中<br>然后就是内核中的数据复制到进程缓冲区，对应于就是从buffer中读取数据</p>
<p>写入的过程则是：<br>先从进程将数据写到内核中，对应于就是进程将数据写入到buffer中，<br>然后内核中的数据再写入到网卡或者磁盘中，对应于就是，buffer中的数据利用channel传输到IO设备中。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-aac9fc85b511344e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>以上其实就是NIO基本的利用channel和buffer进行读取和写入的流程。</p>
<h2 id="Channel-Characteristics"><a href="#Channel-Characteristics" class="headerlink" title="Channel Characteristics"></a>Channel Characteristics</h2><ul>
<li>与传统IO中的流不同，channel是双向的，可读可写</li>
<li>channel从buffer中读取数据，写入数据也是先写入到buffer</li>
<li>channel可以实现异步读写操作</li>
<li>channel可以设置为阻塞和非阻塞的模式</li>
<li>非阻塞模式意味着，当读不到数据或者缓冲区已满无法写入的时候，不会把线程睡眠</li>
<li>只有socket的channel可以设置为非阻塞模式，文件的channel是无法设置的。文件的IO一定是阻塞的</li>
<li>如果是文件channel的话，channel可以在channel之间传输数据</li>
</ul>
<h2 id="Java-NIO-Channel-Classes"><a href="#Java-NIO-Channel-Classes" class="headerlink" title="Java NIO Channel Classes"></a>Java NIO Channel Classes</h2><p>channel主要有两大类，四个具体的类</p>
<ul>
<li>FileChannel<br>文件的读写是不可以设置为非阻塞模式</li>
<li>SocketChannel<br>根据tcp和udp，服务端和客户端，又可以分为, SocketChannel, ServerSocketChannel and DatagramChannel.它们是可以设置为非阻塞模式的</li>
</ul>
<h1 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h1><h2 id="什么是缓冲区？"><a href="#什么是缓冲区？" class="headerlink" title="什么是缓冲区？"></a>什么是缓冲区？</h2><p>Buffer 是一个对象， 它包含一些要写入或者刚读出的数据。 在 NIO 中加入 Buffer 对象，体现了新库与原 I/O 的一个重要区别。在面向流的 I/O 中，您将数据直接写入或者将数据直接读到 Stream 对象中。<br>在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。任何时候访问 NIO 中的数据，您都是将它放到缓冲区中。<br>缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不 仅仅 是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>
<h2 id="缓冲区类型"><a href="#缓冲区类型" class="headerlink" title="缓冲区类型"></a>缓冲区类型</h2><p>最常用的缓冲区类型是 ByteBuffer。一个 ByteBuffer 可以在其底层字节数组上进行 get/set 操作(即字节的获取和设置)。<br>ByteBuffer 不是 NIO 中唯一的缓冲区类型。事实上，对于每一种基本 Java 类型都有一种缓冲区类型：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<p>每一个 Buffer 类都是 Buffer 接口的一个实例。 除了 ByteBuffer，每一个 Buffer 类都有完全一样的操作，只是它们所处理的数据类型不一样。因为大多数标准 I/O 操作都使用 ByteBuffer，所以它具有所有共享的缓冲区操作以及一些特有的操作。</p>
<h2 id="缓冲区内部细节"><a href="#缓冲区内部细节" class="headerlink" title="缓冲区内部细节"></a>缓冲区内部细节</h2><p>本节将介绍 NIO 中两个重要的缓冲区组件：状态变量和访问方法 (accessor)。<br>状态变量是前一节中提到的”内部统计机制”的关键。每一个读/写操作都会改变缓冲区的状态。通过记录和跟踪这些变化，缓冲区就可能够内部地管理自己的资源。<br>在从通道读取数据时，数据被放入到缓冲区。在有些情况下，可以将这个缓冲区直接写入另一个通道，但是在一般情况下，您还需要查看数据。这是使用 访问方法 get() 来完成的。同样，如果要将原始数据放入缓冲区中，就要使用访问方法 put()。</p>
<p>状态变量<br>可以用三个值指定缓冲区在任意时刻的状态：position，limit，capacity<br>这三个变量一起可以跟踪缓冲区的状态和它所包含的数据。我们将在下面的小节中详细分析每一个变量，还要介绍它们如何适应典型的读/写(输入/输出)进程。在这个例子中，我们假定要将数据从一个输入通道拷贝到一个输出通道。</p>
<h1 id="Position"><a href="#Position" class="headerlink" title="Position"></a>Position</h1><p>您可以回想一下，缓冲区实际上就是美化了的数组。在从通道读取时，您将所读取的数据放到底层的数组中。 position 变量跟踪已经写了多少数据。更准确地说，它指定了下一个字节将放到数组的哪一个元素中。因此，如果您从通道中读三个字节到缓冲区中，那么缓冲区的 position 将会设置为3，指向数组中第四个元素。<br>同样，在写入通道时，您是从缓冲区中获取数据。 position 值跟踪从缓冲区中获取了多少数据。更准确地说，它指定下一个字节来自数组的哪一个元素。因此如果从缓冲区写了5个字节到通道中，那么缓冲区的 position 将被设置为5，指向数组的第六个元素。</p>
<h1 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h1><p>limit 变量表明还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。<br>position 总是小于或者等于 limit。</p>
<h1 id="Capacity"><a href="#Capacity" class="headerlink" title="Capacity"></a>Capacity</h1><p>缓冲区的 capacity 表明可以储存在缓冲区中的最大数据容量。实际上，它指定了底层数组的大小 ― 或者至少是指定了准许我们使用的底层数组的容量。<br>limit 决不能大于 capacity。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-553045fec72083d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>实例：<br>我们首先观察一个新创建的缓冲区。出于本例子的需要，我们假设这个缓冲区的 总容量 为8个字节。 Buffer 的状态如下所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-75380a8047e102db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>回想一下 ，limit 决不能大于 capacity，此例中这两个值都被设置为 8。我们通过将它们指向数组的尾部之后(如果有第8个槽，则是第8个槽所在的位置)来说明这点。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-443566d784dc0d96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>position 设置为0。如果我们读一些数据到缓冲区中，那么下一个读取的数据就进入 slot 0 。如果我们从缓冲区写一些数据，从缓冲区读取的下一个字节就来自 slot 0 。 position 设置如下所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-bb1f13fae9d3ef88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>由于 capacity 不会改变，所以我们在下面的讨论中可以忽略它。<br>第一次读取<br>现在我们可以开始在新创建的缓冲区上进行读/写操作。首先从输入通道中读一些数据到缓冲区中。第一次读取得到三个字节。它们被放到数组中从 position 开始的位置，这时 position 被设置为 0。读完之后，position 就增加到 3，如下所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-cfb535306b23cb1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>limit 没有改变。<br>第二次读取<br>在第二次读取时，我们从输入通道读取另外两个字节到缓冲区中。这两个字节储存在由 position 所指定的位置上， position 因而增加 2：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-cab77cc8c51a1e2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>limit 没有改变。<br>flip<br>现在我们要将数据写到输出通道中。在这之前，我们必须调用 flip() 方法。这个方法做两件非常重要的事：<br>它将 limit 设置为当前 position。<br>它将 position 设置为 0。<br>前一小节中的图显示了在 flip 之前缓冲区的情况。下面是在 flip 之后的缓冲区：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-956df795cdba92e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们现在可以将数据从缓冲区写入通道了。 position 被设置为 0，这意味着我们得到的下一个字节是第一个字节。 limit 已被设置为原来的 position，这意味着它包括以前读到的所有字节，并且一个字节也不多。<br>第一次写入<br>在第一次写入时，我们从缓冲区中取四个字节并将它们写入输出通道。这使得 position 增加到 4，而 limit 不变，如下所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-c031745b924091a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>第二次写入<br>我们只剩下一个字节可写了。 limit在我们调用 flip() 时被设置为 5，并且 position<br> 不能超过 limit。所以最后一次写入操作从缓冲区取出一个字节并将它写入输出通道。这使得 position增加到 5，并保持 limit 不变，如下所示：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-00546b8671ae31c3.gif?imageMogr2/auto-orient/strip" alt="Position advanced to 5, limit unchanged"></p>
<p>clear<br>最后一步是调用缓冲区的 clear() 方法。这个方法重设缓冲区以便接收更多的字节。 Clear 做两种非常重要的事情：<br>它将 limit 设置为与 capacity 相同。<br>它设置 position 为 0。<br>下图显示了在调用 clear() 后缓冲区的状态：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-25c165036e42db01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>缓冲区现在可以接收新的数据了。</p>
<h2 id="NIO-Buffer-Characteristics"><a href="#NIO-Buffer-Characteristics" class="headerlink" title="NIO Buffer Characteristics"></a>NIO Buffer Characteristics</h2><ul>
<li>buffer是java NIO中的块的基础</li>
<li>buffer可以提供一个固定大小的容器来读取和写入数据</li>
<li>任意一个buffer都是可读的，只有选中的buffer才可写</li>
<li>buffer是channel的端点</li>
<li>在只读的模式下，buffer的内容不可变，但是的他/她的几个变量，position，limit都是可变的</li>
<li>默认情况下，buffer不是线程安全的</li>
</ul>
<h2 id="How-to-Read-from-NIO-Buffer"><a href="#How-to-Read-from-NIO-Buffer" class="headerlink" title="How to Read from NIO Buffer"></a>How to Read from NIO Buffer</h2><ul>
<li><p>首先创建一个指定大小的buffer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>将buffer转换为读模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byteBuffer.flip();</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后从channel中读取数据到buffer中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numberOfBytes = fileChannel.read(byteBuffer);</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户从buffer中读取数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = (<span class="keyword">char</span>)byteBuffer.get();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="How-to-Write-to-NIO-Buffer"><a href="#How-to-Write-to-NIO-Buffer" class="headerlink" title="How to Write to NIO Buffer"></a>How to Write to NIO Buffer</h2><ul>
<li><p>Create a buffer by allocating a size.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">512</span>);<span class="comment">//512 becomes the capacity</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Put data into buffer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byteBuffer.put((<span class="keyword">byte</span>) <span class="number">0xff</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Java-NIO-读写文件实例程序"><a href="#Java-NIO-读写文件实例程序" class="headerlink" title="Java NIO 读写文件实例程序"></a>Java NIO 读写文件实例程序</h1><p>下面的程序实现了一个简单的利用buffer和channel读取数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.StandardOpenOption;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		Path path = Paths.get(<span class="string">"temp.data"</span>);</span><br><span class="line">		write(path);</span><br><span class="line">		read(path);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		String input = <span class="string">"NIO Buffer Hello World!"</span>;</span><br><span class="line">		<span class="keyword">byte</span>[] inputBytes = input.getBytes();</span><br><span class="line">		ByteBuffer byteBuffer = ByteBuffer.allocate(inputBytes.length);</span><br><span class="line">		byteBuffer.put(inputBytes);</span><br><span class="line">		byteBuffer.flip();</span><br><span class="line">		FileChannel channelWrite = FileChannel.open(path,</span><br><span class="line">				StandardOpenOption.CREATE, StandardOpenOption.WRITE);</span><br><span class="line">		channelWrite.write(byteBuffer);</span><br><span class="line">		channelWrite.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		FileChannel channelRead = FileChannel.open(path);</span><br><span class="line">		ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">		<span class="keyword">int</span> readBytes = channelRead.read(byteBuffer);</span><br><span class="line">		<span class="keyword">if</span>(readBytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			byteBuffer.flip();</span><br><span class="line">			<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.remaining()];</span><br><span class="line">			byteBuffer.get(bytes);</span><br><span class="line">			String fileContent = <span class="keyword">new</span> String(bytes, <span class="string">"utf-8"</span>);</span><br><span class="line">			System.out.println(<span class="string">"File Content: "</span> + fileContent);</span><br><span class="line">		&#125;</span><br><span class="line">		channelRead.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://javapapers.com/java/java-nio-buffer/" target="_blank" rel="noopener">http://javapapers.com/java/java-nio-buffer/</a></li>
<li><a href="http://www.importnew.com/19816.html" target="_blank" rel="noopener">http://www.importnew.com/19816.html</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> NIO </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[细谈Select,Poll,Epoll]]></title>
      <url>/2017/07/31/%E7%BB%86%E8%B0%88Select-Poll-Epoll/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li>阻塞 io 模型 blocking IO</li>
<li>非阻塞 io 模型 nonblocking IO</li>
<li>io多路复用模型 IO multiplexing</li>
<li>细谈 io 多路复用技术 select 和poll</li>
<li>细谈事件驱动–epoll</li>
<li>总结<a id="more"></a>
操作系统在处理io的时候，主要有两个阶段：</li>
<li>等待数据传到io设备</li>
<li>io设备将数据复制到user space</li>
</ul>
</blockquote>
<p>我们一般将上述过程简化理解为：</p>
<ul>
<li>等到数据传到kernel内核space</li>
<li>kernel内核区域将数据复制到user space（理解为进程或者线程的缓冲区）</li>
</ul>
<p>而根据这两个阶段而不同的操作方法，就会产生多种io模型，本文只讨论select，poll，epoll，所以只引出三种io模型。</p>
<h1 id="阻塞-io-模型-blocking-IO"><a href="#阻塞-io-模型-blocking-IO" class="headerlink" title="阻塞 io 模型 blocking IO"></a>阻塞 io 模型 blocking IO</h1><p>最常用的也就是阻塞io模型。默认情况下，所有文件操作都是阻塞的。我们以套接字接口为例来讲解此模型，在进程空间调用recvfrom，其系统调用知道数据包到达并且被复制到进程缓冲中或者发生错误时才会返回，在此期间会一直阻塞，所以进程在调用recvfrom开始到它返回的整段时间都是阻塞的，因此称之为阻塞io模型。</p>
<p>注意：<strong>在阻塞狀態下，程序是不會浪費CPU的</strong>，cpu只是不执行io操作了，还会去做别的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-933dce992cd84ec2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>应用层有数据过来，会调用recvfrom方法，但是这个时候应用层的数据还没复制到kernel中，将应用层数据复制到kerne这个阶段是需要时间的，所以recvfrom方法会阻塞，当内核中的数据准备好之后，recvfrom方法还不会返回，而是会发起一个系统调用将kernel中的数据复制到进程的缓冲区中，也就是user space，当这个工作完成之后，recvfrom才会返回并解除程序的阻塞。</p>
<p>所以我们总结可以发现，主要就是上面两个阶段</p>
<ul>
<li>应用层数据到kernel</li>
<li>kernel复制到user space</li>
</ul>
<p>阻塞io模型就是将这个两个过程合并在一起，一起阻塞。<br>而非阻塞模型则是将第一个过程的阻塞变成非阻塞，第二个阶段是系统调用，是必须阻塞的，所以非阻塞模型也是同步的，因为它们在kernel里的数据准备好之后，进行系统调用，将数据拷贝到进程缓冲区中。</p>
<h1 id="非阻塞-io-模型-nonblocking-IO"><a href="#非阻塞-io-模型-nonblocking-IO" class="headerlink" title="非阻塞 io 模型 nonblocking IO"></a>非阻塞 io 模型 nonblocking IO</h1><p>就是对于第一个阶段，也就是应用层数据到kernel的过程中，recvfrom会轮询检查，如果kernel数据没有准备还，就返回一个EWOULDBLOCK错误。不断的轮询检查，直到发现kernel中的数据准备好了，就返回，然后进行系统调用，将数据从kernel拷贝到进程缓冲区中。有點類似busy-waiting的方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-a8cda4332dfdb9b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="io多路复用模型-IO-multiplexing"><a href="#io多路复用模型-IO-multiplexing" class="headerlink" title="io多路复用模型 IO multiplexing"></a>io多路复用模型 IO multiplexing</h1><ul>
<li><p>目的：因为阻塞模型在没有收到数据的时候就会阻塞卡住，如果一次需要接受多个socket fd的时候，就会导致必须处理完前面的fd，才能处理后面的fd，即使可能后面的fd比前面的fd还要先准备好，所以这样就会造成客户端的严重延迟。为了处理多个请求，我们自然先想到用多线程来处理多个socket fd，但是这样又会启动大量的线程，造成资源的浪费，所以这个时候就出现了io多路复用技术。就是用一个进程来处理多个fd的请求。</p>
</li>
<li><p>应用：适用于针对大量的io请求的情况，对于服务器必须在同时处理来自客户端的大量的io操作的时候，就非常适合</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-d316a5ae52112a55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="细谈-io-多路复用技术-select-和poll"><a href="#细谈-io-多路复用技术-select-和poll" class="headerlink" title="细谈 io 多路复用技术 select 和poll"></a>细谈 io 多路复用技术 select 和poll</h1><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>select的工作流程：<br>单个进程就可以同时处理多个网络连接的io请求（同时阻塞多个io操作）。基本原理就是程序呼叫select，然后整个程序就阻塞了，这时候，kernel就会轮询检查所有select负责的fd，当找到一个client中的数据准备好了，select就会返回，这个时候程序就会系统调用，将数据从kernel复制到进程缓冲区。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-b3bdbf32bda44544.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>下图为select同时从多个客户端接受数据的过程</p>
<p>虽然服务器进程会被select阻塞，但是select会利用内核不断轮询监听其他客户端的io操作是否完成。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-d3e456f3bfda4979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="Poll介绍"><a href="#Poll介绍" class="headerlink" title="Poll介绍"></a>Poll介绍</h2><p>poll的原理与select非常相似，差别如下：</p>
<ul>
<li>描述fd集合的方式不同，poll使用 pollfd 结构而不是select结构fd_set结构，所以poll是链式的，没有最大连接数的限制</li>
<li>poll有一个特点是水平触发，也就是通知程序fd就绪后，这次没有被处理，那么下次poll的时候会再次通知同个fd已经就绪。</li>
</ul>
<h2 id="select缺点"><a href="#select缺点" class="headerlink" title="select缺点"></a>select缺点</h2><ul>
<li><p>根据fd_size的定义，它的大小为32个整数大小（32位机器为32*32，所有共有1024bits可以记录fd），每个fd一个bit，所以最大只能同时处理1024个fd</p>
</li>
<li><p>每次要判断【有哪些event发生】这件事的成本很高，因为select（polling也是）采取主动轮询机制</p>
</li>
</ul>
<p>1.每一次呼叫 select( ) 都需要先从 user space把 FD_SET复制到 kernel（约线性时间成本）<br>为什么 select 不能像epoll一样，只做一次复制就好呢?<br>每一次呼叫 select()前，FD_SET都可能更动，而 epoll 提供了共享记忆存储结构，所以不需要有 kernel 與 user之间的数据沟通</p>
<p>2.然后kernel还要轮询每个fd，约线性时间</p>
<ul>
<li>假设现实中，有1百万个客户端同时与一个服务器保持着tcp连接，而每一个时刻，通常只有几百上千个tcp连接是活跃的，这时候我们仍然使用select/poll机制，kernel必须在搜寻完100万个fd之后，才能找到其中状态是active的，这样资源消耗大而且效率低下。</li>
</ul>
<p>对于select和poll的上述缺点，就引进了一种新的技术，epoll技术</p>
<h1 id="细谈事件驱动–epoll"><a href="#细谈事件驱动–epoll" class="headerlink" title="细谈事件驱动–epoll"></a>细谈事件驱动–epoll</h1><p>epoll 提供了三个函数：</p>
<ul>
<li><p>int epoll_create(int size);<br>建立一個 epoll 对象，并传回它的id</p>
</li>
<li><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);<br>事件注册函数，将需要监听的事件和需要监听的fd交给epoll对象</p>
</li>
<li><p>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);<br>等待注册的事件被触发或者timeout发生</p>
</li>
</ul>
<p>epoll解决的问题：</p>
<ul>
<li><p>epoll没有fd数量限制<br>epoll没有这个限制，我们知道每个epoll监听一个fd，所以最大数量与能打开的fd数量有关，一个g的内存的机器上，能打开10万个左右</p>
</li>
<li><p>epoll不需要每次都从user space 将fd set复制到内核kernel<br>epoll在用epoll_ctl函数进行事件注册的时候，已经将fd复制到内核中，所以不需要每次都重新复制一次</p>
</li>
<li><p>select 和 poll 都是主動輪詢機制，需要拜訪每一個 FD；<br>epoll是被动触发方式，给fd注册了相应事件的时候，我们为每一个fd指定了一个回调函数，当数据准备好之后，就会把就绪的fd加入一个就绪的队列中，epoll_wait的工作方式实际上就是在这个就绪队列中查看有没有就绪的fd，如果有，就唤醒就绪队列上的等待者，然后调用回调函数。</p>
</li>
</ul>
<ul>
<li>虽然epoll。poll。epoll都需要查看是否有fd就绪，但是epoll之所以是被动触发，就在于它只要去查找就绪队列中有没有fd，就绪的fd是主动加到队列中，epoll不需要一个个轮询确认。<br>换一句话讲，就是select和poll只能通知有fd已经就绪了，但不能知道究竟是哪个fd就绪，所以select和poll就要去主动轮询一遍找到就绪的fd。而epoll则是不但可以知道有fd可以就绪，而且还具体可以知道就绪fd的编号，所以直接找到就可以，不用轮询。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>select, poll是为了解決同时大量IO的情況（尤其网络服务器），但是随着连接数越多，性能越差</li>
<li>epoll是select和poll的改进方案，在 linux 上可以取代 select 和 poll，可以处理大量连接的性能问题</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解--异步和非阻塞]]></title>
      <url>/2017/07/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-%E5%BC%82%E6%AD%A5%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E/</url>
      <content type="html"><![CDATA[<p>异步和非阻塞的概念实际上已经出现了很长一段时间。但是异步真正开始流行起来，是因为AJAX技术逐渐成为主流的web开发技术。非阻塞的概念真正流行起来，是当java引入NIO,也可以称作非阻塞IO的API，开始走进主流的开发人员的视线，真正流行起来，也可以认为是node.js带来的。</p>
<p> 同步 ，异步，阻塞，非阻塞这几个概念相互之间联系紧密，很难区分。很多程序员都不知道它们之间的具体的不同。本文就会详细讨论这个问题，希望能帮助读者更好的了解这几个概念<br><a id="more"></a></p>
<h1 id="同步和阻塞"><a href="#同步和阻塞" class="headerlink" title="同步和阻塞"></a>同步和阻塞</h1><p>首先，我们先开始介绍与异步和非阻塞对立的两个概念：同步和阻塞</p>
<p> 对于web开发者来说，理解同步的概念相对比较容易，因为HTTP协议就是一个同步的协议。web浏览器向服务器发送一个请求并且等待它的响应。收到响应之后，浏览器才可以继续向服务器发送下一个请求，并且等待响应，周而复始的重复这个过程。在发送下一个请求之前必须等待响应的到达才行，这就成为了HTTP协议的一个巨大的性能瓶颈，当然为了解决这个问题，后来就出现了异步的AJAX技术。</p>
<p>阻塞的概念相对也是比较容易理解的。我们通过Java中的InputStream类的read方法来介绍阻塞的概念，文档中是这样描述read方法的：</p>
<blockquote>
<p>If no byte is available because the end of the stream has been reached, the value -1 is returned. This method blocks until input data is available, the end of the stream is detected, or an exception is thrown.<br>意思就是，如果已经到了流的末尾没有可读取的数据，那么就会返回-1。这个方法会一直阻塞，直到有可读取的数据，或者已经读到了流的末尾，或者抛出一个异常。</p>
</blockquote>
<p>这个方法的调用会一直阻塞，因为他会一直等待直到输入的数据可以用来读取。这通常会造成性能的瓶颈，因为这个方法会阻塞，导致无法继续执行随后的操作。</p>
<h1 id="异步和非阻塞"><a href="#异步和非阻塞" class="headerlink" title="异步和非阻塞"></a>异步和非阻塞</h1><p>异步和非阻塞就是同步和阻塞的相反面。在直觉上，可能会感觉这两个概念会有一些类似，因为他们都可以允许你们的线程在等待结果或者返回的时候不需要挂起整个线程。但是他们又有不同，因为异步调用通常需要包括一个回调机制或者事件机制，去主动通知调用方此时响应的结果已经可用了。而非阻塞调用往往会先返回一个任意的结果，然后调用者会不定时的反复去尝试获取返回的结果，直到结果已经可用了。这里的区别就是一个主动通知和被动去询问。举个例子，你去音乐店买周杰伦的专辑，但老板告诉你，现在没货，你就回去了，等到货到了，准备好了，老板会主动打电话通知你，专辑已经到啦，快来买吧，这就是异步机制，是主动通知的。而非阻塞则是，老板不会主动通知你，而是你自己隔个一两天就去这家店主动问问，专辑到了么，直到有一次你询问的时候，终于发现专辑到了。非阻塞的概念常常用于I/O中，而异步的概念则相对应用的比较广泛。</p>
<blockquote>
<p>特别的，异步I/O，意味着I/O操作是独立于当前的那个线程的操作而进行的。可以理解为，另外新开启了一个线程去执行I/O操作，当I/O操作完成之后会主动直接将结果返回。这里说的更详细一点就是，我们知道底层数据准备好之后，还要从内核区域拷贝到线程的缓冲区，非阻塞操作在这种意义上来说，又是同步的，因为非阻塞不会将这个拷贝数据的过程完成，而是当数据准备好了，告诉线程，你可以执行系统调用，将内核区域的数据拷贝到线程的缓冲区了，当然这个过程是同步，而且由于是系统调用，所以这个拷贝的过程也是阻塞的。而异步操作则不是，系统会开启一个线程当数据准备好了，这个线程还会完成这个从内核区将数据拷贝到线程缓冲区的过程，当数据拷贝完成了，才通知调用者，这时候调用者就直接可以用了。</p>
</blockquote>
<p>我们在看一个更详细的异步I/O的例子：</p>
<blockquote>
<p>我们假设同步I/O意味着发出一个I/O命令，然后一直等待，直到I/O操作完成。也就是说，你发出一个read命令，然后这个线程接下来的执行操作会一直等待，直到已经读到了内容。异步I/O则是你发出一个I/O命令，然后这个I/O不会立即完成。你可以先去执行接下来的程序。异步会实现一个接口，允许IO操作不阻塞当前的线程，而且当操作完成之后，会主动通知你操作已经完成。</p>
</blockquote>
<p>Non-blocking 在这里有一个很好的解释： <a href="http://stackoverflow.com/a/9489547/34956" target="_blank" rel="noopener">this StackOverflow answer</a>:</p>
<blockquote>
<p>This term is mostly used with IO. What this means is that when you make a system call, it will return immediately with whatever result it has without putting your thread to sleep (with high probability). For example non-blocking read/write calls return with whatever they can do and expect caller to execute the call again. try_lock for example is non-blocking call. It will lock only if lock can be acquired. Usual semantics for systems calls is blocking. read will wait until it has some data and put calling thread to sleep.<br>非阻塞I/O意味着当你发起一个系统调用的时候，他会立即返回一个结果，而不是将你的线程睡眠。非阻塞的读写操作，会收到一个立即的返回值，然后请求者会反复去重试，不断的去尝试，直到可以开始读写操作了。类似于忙等的状态，不断的测试，但是线程没有被阻塞。try_lock就是一个非阻塞的调用，他会尝试去获取锁，直到锁可以获取。通常来说，系统调用会进入内核，一般都是阻塞的，所以read操作往往是阻塞的，会等待可用数据，并且将线程休眠。</p>
</blockquote>
<p>现在，我们应该对于异步和非阻塞的概念已经有所了解了。下面我们就举个现实中的例子来加强理解：</p>
<blockquote>
<p>例如，传统的sockets API中，一个非阻塞的socket，通常会立即返回一个”would block” 的错误信息，然后需要调用独立的函数select or poll 去轮询检查什么时候可以再次尝试去读取。<br>但是异步的sockets （windows的sockets支持异步操作），.Net框架中也有异步I/O模型。你调用一个方法开始某个操作，然后 框架会在这个操作完成的时候，回调通知你，操作完成了。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之代理模式（Proxy模式）]]></title>
      <url>/2017/07/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li>代理模式的引入</li>
<li>代理模式的实例程序</li>
<li>代理模式的分析</li>
</ul>
</blockquote>
<h1 id="代理模式的引入"><a href="#代理模式的引入" class="headerlink" title="代理模式的引入"></a>代理模式的引入</h1><p>Proxy是代理人的意思，指的是代替别人进行工作的人。当不一定需要本人亲自去做的工作的时候，就可以寻找代理人去完成。<br>但在代理模式中，往往是相反的，通常是代理人碰到工作，就交给被代理的对象去完成，代理人只完成一些准备工作或者收尾工作。<br>如果读者了解过spring框架的话，就会知道aop也就是面向切面编程其实运用的就是动态代理模式，这可以让被代理的对象专注于完成自己的本职工作，而代理对象可以进行工作前的日志记录，时间计算，在工作之后进行日志记录，收尾工作等附加的功能，需要正式做工作的时候就交给被代理去做。就像插了两个刀到这个被代理的对象前后。所以形象的叫做面向切面编程。<br>关于动态代理模式和静态代理模式，感兴趣的读者可以参考笔者的另一篇博文：<br>Java动态代理与静态代理<a href="http://www.jianshu.com/p/b5e340ec9551" target="_blank" rel="noopener">http://www.jianshu.com/p/b5e340ec9551</a><br><a id="more"></a></p>
<h1 id="代理模式的实例程序"><a href="#代理模式的实例程序" class="headerlink" title="代理模式的实例程序"></a>代理模式的实例程序</h1><p>我们会实现一个打印机，向屏幕打印一串字符串，然后交给代理对象去完成这个功能。</p>
<p>首先看一下类图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-c61ad151085fc555.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>Printer类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Printer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        heavyJob(<span class="string">"正在生成Printer的实例"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Printer</span><span class="params">(String name)</span> </span>&#123;                   <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        heavyJob(<span class="string">"正在生成Printer的实例("</span> + name + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrinterName</span><span class="params">(String name)</span> </span>&#123;       <span class="comment">// 设置名字</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrinterName</span><span class="params">()</span> </span>&#123;                <span class="comment">// 获取名字</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String string)</span> </span>&#123;              <span class="comment">// 显示带打印机名字的文字</span></span><br><span class="line">        System.out.println(<span class="string">"=== "</span> + name + <span class="string">" ==="</span>);</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heavyJob</span><span class="params">(String msg)</span> </span>&#123;             <span class="comment">// 重活</span></span><br><span class="line">        System.out.print(msg);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"结束。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Printable接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setPrinterName</span><span class="params">(String name)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getPrinterName</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String string)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PrinterProxy类,利用反射机制，动态生成被代理的对象，并且延迟初始化到需要调用它的时候再初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrinterProxy</span> <span class="keyword">implements</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;            <span class="comment">// 名字</span></span><br><span class="line">    <span class="keyword">private</span> Printable real;         <span class="comment">// “本人”                 </span></span><br><span class="line">    <span class="keyword">private</span> String className;       <span class="comment">// “本人”的类名       </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrinterProxy</span><span class="params">(String name, String className)</span> </span>&#123;      <span class="comment">// 构造函数     </span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.className = className;                                                 </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setPrinterName</span><span class="params">(String name)</span> </span>&#123;  <span class="comment">// 设置名字</span></span><br><span class="line">        <span class="keyword">if</span> (real != <span class="keyword">null</span>) &#123;</span><br><span class="line">            real.setPrinterName(name);  <span class="comment">// 同时设置“本人”的名字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrinterName</span><span class="params">()</span> </span>&#123;    <span class="comment">// 获取名字</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String string)</span> </span>&#123;  <span class="comment">// 显示</span></span><br><span class="line">        realize();</span><br><span class="line">        real.print(string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">realize</span><span class="params">()</span> </span>&#123;   <span class="comment">// 生成“本人”</span></span><br><span class="line">        <span class="keyword">if</span> (real == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;                                                                       </span><br><span class="line">                real = (Printable)Class.forName(className).newInstance();               </span><br><span class="line">                real.setPrinterName(name);                                              </span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;                                        </span><br><span class="line">                System.err.println(<span class="string">"没有找到 "</span> + className + <span class="string">" 类。"</span>);      </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;                                                     </span><br><span class="line">                e.printStackTrace();                                                    </span><br><span class="line">            &#125;                                                                           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Main类测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Printable p = <span class="keyword">new</span> PrinterProxy(<span class="string">"Alice"</span>, <span class="string">"Proxy.Printer"</span>);                 </span><br><span class="line">        System.out.println(<span class="string">"现在的名字是"</span> + p.getPrinterName() + <span class="string">"。"</span>);</span><br><span class="line">        p.setPrinterName(<span class="string">"Bob"</span>);</span><br><span class="line">        System.out.println(<span class="string">"现在的名字是"</span> + p.getPrinterName() + <span class="string">"。"</span>);</span><br><span class="line">        p.print(<span class="string">"Hello, world."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-83d27bd12876e5f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="代理模式分析"><a href="#代理模式分析" class="headerlink" title="代理模式分析"></a>代理模式分析</h1><p>代理模式中的角色：</p>
<ul>
<li><p>Subject（主体）<br>Subject角色定义了使proxy和realsubject角色之间具有一致性的接口。这个接口提供了一个使用的好处，就是client不必却分它使用的是代理对象还是真实对象。<br>对应实例中Printable角色</p>
</li>
<li><p>Proxy（代理人）<br>Proxy角色会尽量处理来自Client角色的请求。只有当自己不能处理的时候，就交给工作交给真实对象。代理对象只有在有必要时才会生成真实的对象。<br>实例中对应的是PrinterProxy对象。</p>
</li>
<li><p>RealSubject(真实对象)<br>就是实际完成工作的对象，对应实例中的Printer对象。</p>
</li>
</ul>
<p>代理模式的类图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-02859d251c15f7b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><p>用代理人来提升速度<br>关键就在于延迟初始化。<br>我们可以等到需要使用到真实对象的功能才初始化。这样的好处就是可以提升性能。从我们的实例中可能看不出这个优势，假设我们有一个大型系统，如果我们都在系统启动的时候，把所有功能初始化，所有实例初始化，那么显然系统的启动将会变得很慢。但如果我们采用代理模式，那么就会在必须的时候，在初始化对象。这样就加快了系统的启动速度。</p>
</li>
<li><p>代理和委托<br>其实我们学习了那么多设计模式，是不是感觉委托简直无处不在。几乎每个设计模式都会用到委托，代理模式也不意外，就是代理了对象委托了真实对象。<br>因为委托可以是对象之间发生联系，互相调用。所以委托在很多设计模式中都存在。</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一篇文章搞懂面试中leetcode位操作算法题]]></title>
      <url>/2017/07/20/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E9%9D%A2%E8%AF%95%E4%B8%ADleetcode%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li>Single Number落单的数</li>
<li>落单的数 IISingle Number II</li>
<li>Single Number III落单的数 III</li>
<li>Number of 1 Bits</li>
<li>Counting Bits</li>
<li>Reverse Bits</li>
<li>Missing Number</li>
<li>Sum of Two Integers</li>
<li>Power of Two</li>
<li>Power of Four</li>
</ul>
</blockquote>
<p>本文将根据题目总结常用的位操作常用的解决算法问题的技巧<br>如读者对基本的位操作概念还不熟悉，可以先参考笔者的文章浅谈程序设计中的位操作<a href="http://www.jianshu.com/p/294fc6605bb1" target="_blank" rel="noopener">http://www.jianshu.com/p/294fc6605bb1</a><br><a id="more"></a></p>
<h1 id="Single-Number落单的数"><a href="#Single-Number落单的数" class="headerlink" title="Single Number落单的数"></a>Single Number落单的数</h1><p>给出2*n + 1 个的数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字。</p>
<p>思路：<br>一个数字和自己进行异或操作会是0，由于异或操作满足交换定律，一个数和0进行异或操作还是本身。所以这道题目的思路就来了，将所有出现两次的数异或就都变成了0，最后剩的那个数和0异或就还是本身。直接将数组所有数异或，就可以找出那个落单的数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="落单的数-IISingle-Number-II"><a href="#落单的数-IISingle-Number-II" class="headerlink" title="落单的数 IISingle Number II"></a>落单的数 IISingle Number II</h1><p>给出3*n + 1 个的数字，除其中一个数字之外其他每个数字均出现三次，找到这个数字。</p>
<p>思路：<br>java中int是32位的，所以我们利用一个32的数组，分别记录每一位1的情况，如果出现三次就清0，最后留下来的就是那个只出现1次的数字在那一位上的情况，然后进行移位复原<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;A.length;j++) &#123;</span><br><span class="line">                bits[i] += (A[j]&gt;&gt;i) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            res = res | ((bits[i]%<span class="number">3</span>) &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果要找出现4次或者出现5次等的情况，只要%5就行了。</p>
<h1 id="Single-Number-III落单的数-III"><a href="#Single-Number-III落单的数-III" class="headerlink" title="Single Number III落单的数 III"></a>Single Number III落单的数 III</h1><p>给出2*n + 2个的数字，除其中两个数字之外其他每个数字均出现两次，找到这两个数字。</p>
<p>思路<br>如果能把这两个不同的数字分开，那么直接采取落单的数1的方法异或就可以了。<br>所以，我们先考虑将所有数异或，最后得到的结果是两个不同的数的异或结果，然后我们找到最后一位为1的位，为1代表这两个数在这一位上是不同的。然后用这个位与数组中每个数相与，就可以把数分成两部分，一部分里有第一个不同的数，另一部分有第二个不同的数，所以这个时候我们只要直接异或就可以得到结果了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length;i++) &#123;</span><br><span class="line">            xor ^= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// a&amp;(a-1)将最后为1的一位变成0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lastbit = xor - (xor &amp; (xor -<span class="number">1</span>)); <span class="comment">//取出最后一个为1的位</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> group0 = <span class="number">0</span>, group1 = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>((lastbit &amp; A[i]) == <span class="number">0</span>)</span><br><span class="line">                group0 ^= A[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                group1 ^= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;group0,group1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Number-of-1-Bits"><a href="#Number-of-1-Bits" class="headerlink" title="Number of 1 Bits"></a>Number of 1 Bits</h1><p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the <a href="http://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="noopener">Hamming weight</a>).<br>For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011<br>, so the function should return 3.</p>
<p>思路：<br>依次拿每一位与1进行比较，统计1的个数，然后逻辑右移，不能用算数右移，算数右移会在高位加一。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">while</span>(n!=<span class="number">0</span>) &#123;</span><br><span class="line">    		ones += (n &amp; <span class="number">1</span>);</span><br><span class="line">            n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有一种方法，我们知道n&amp;(n-1)会把n中最后为1的一位变成0。<br>所以我们调用n&amp;(n-1),看看调几次这个数会变成0，就说明有几个1.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">            </span><br><span class="line">            n = n &amp; (n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Counting-Bits"><a href="#Counting-Bits" class="headerlink" title="Counting Bits"></a>Counting Bits</h1><p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.</p>
<p>Example:<br>For num = 5 you should return [0,1,1,2,1,2].</p>
<p>思路：<br>我们当然可以利用上一题的方法，直接每个数计算一次<br>但也发现是存在规律的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-4ce9356e7612a5a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">            res[i] = res[i&gt;&gt;<span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Reverse-Bits"><a href="#Reverse-Bits" class="headerlink" title="Reverse Bits"></a>Reverse Bits</h1><p>Reverse bits of a given 32 bits unsigned integer.</p>
<p>For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).</p>
<p>思路：<br>利用位操作，先交换相邻的两位，再交换的四位，再交换相邻的八位。<br>举个例子；<br>我们交换12345678<br>可以先变成 21436587<br>再变成43218765<br>最后87654321，交换成功</p>
<p>对于32位也是如此的思路。<br>关键如何用位操作实现，首先交换两位的话，可以先分别取出前一位<br>x &amp; （10101010101010101101010。。。。）<br>换成16进制就是<br>x &amp; (0xaaaaaaaa)取出前一位，因为要与要有后一位交换，所以右移一位，因为只是单纯的交换，所以是逻辑右移<br>（x &amp; 0xaaaaaaaa） &gt;&gt;&gt; 1<br>然后对后一位也进行相应的操作，很容易得出<br>(x &amp; 0x555555555)  &lt;&lt; 1<br>最后分别将前一位后一位合起来，使用或操作就可以了<br>所以，第一次交换后<br>x = ((x &amp; 0xaaaaaaaa) &gt;&gt;&gt; 1) | ((x &amp; 0x55555555) &lt;&lt; 1);</p>
<p>然后进行第二次交换：<br>取出前两位<br>x &amp; (1100110011001100……)也就是 x &amp; 0xcccccccc.<br>后面的步骤都是一样的思路<br> x = ((x &amp; 0xcccccccc) &gt;&gt;&gt; 2) | ((x &amp; 0x33333333) &lt;&lt; 2);</p>
<p>第三次交换<br>x = ((x &amp; 0xf0f0f0f0) &gt;&gt;&gt; 4) | ((x &amp; 0x0f0f0f0f) &lt;&lt; 4);</p>
<p>第四次交换<br>x = ((x &amp; 0xff00ff00) &gt;&gt;&gt; 8) | ((x &amp; 0x00ff00ff) &lt;&lt; 8);</p>
<p>第四次交换<br>x = ((x &amp; 0xffff0000) &gt;&gt;&gt; 16) | ((x &amp; 0x0000ffff) &lt;&lt; 16);<br>交换成功</p>
<p>代码就是上面的交换的过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        x = ((x &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt;&gt; <span class="number">1</span>) | ((x &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        x = ((x &amp; <span class="number">0xcccccccc</span>) &gt;&gt;&gt; <span class="number">2</span>) | ((x &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">        x = ((x &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt;&gt; <span class="number">4</span>) | ((x &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">        x = ((x &amp; <span class="number">0xff00ff00</span>) &gt;&gt;&gt; <span class="number">8</span>) | ((x &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">        x = ((x &amp; <span class="number">0xffff0000</span>) &gt;&gt;&gt; <span class="number">16</span>) | ((x &amp; <span class="number">0x0000ffff</span>) &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Missing-Number"><a href="#Missing-Number" class="headerlink" title="Missing Number"></a>Missing Number</h1><p>给出一个包含 0 .. N 中 N 个数的序列，找出0 .. N 中没有出现在序列中的那个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">		xor = xor ^ i ^ nums[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> xor ^ i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Sum-of-Two-Integers"><a href="#Sum-of-Two-Integers" class="headerlink" title="Sum of Two Integers"></a>Sum of Two Integers</h1><p>位操作实现A+B的操作是常见的算法题。<br>lintcode上就有一道容易题是这样。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * param a: The first integer</span></span><br><span class="line"><span class="comment">     * param b: The second integer</span></span><br><span class="line"><span class="comment">     * return: The sum of a and b</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">aplusb</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here, try to do it without arithmetic operators.</span></span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">0</span>)<span class="keyword">return</span> b;  </span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> a;  </span><br><span class="line">        <span class="keyword">int</span> x1 = a^b;  </span><br><span class="line">        <span class="keyword">int</span> x2 = (a&amp;b)&lt;&lt;<span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">return</span> aplusb(x1,x2); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上述代码就实现了不用+操作符，利用位操作实现两个数的相加操作。<br>现在我们来讲解位操作实现两个数相加的原理<br>首先，十进制中，我们知道，7+8，不进位和是5，进位是1，然后我们可以根据不进位和和进位5+1*10算出最后的结果15。<br>类似二进制也可以采取这种方法<br>比如<br>a = 3，b = 6<br>a : 0011<br>b : 0110<br>不进位和： 0101 也就是5<br>进位：0010 也就是2<br>所以a+b变成5 + （2&lt;&lt;1）<br>5　　　　0101<br>2&lt;&lt;1 　　0100<br>不进位和 0001 = 1<br>进位 0100 = 4<br>因此 a + b就变成了1 + 4 &lt;&lt; 1<br>然后有<br>1　　　　0001<br>4&lt;&lt;1 　　1000<br>不进位和 1001 = 9<br>进位 0000 = 0<br>当时进位为0时，不进位和为9即a + b之和。</p>
<p>可以发现上述是一个递归的过程，所以也就不难写出代码了。求两个数的不进位和实际上就是将两个数异或操作即可。</p>
<h1 id="Power-of-Two"><a href="#Power-of-Two" class="headerlink" title="Power of Two"></a>Power of Two</h1><p>Given an integer, write a function to determine if it is a power of two.<br>要为2的次方<br>1，2，4，8，16<br>也就是每位分别单独为1<br>1<br>10<br>100<br>1000<br>10000<br>所以n &amp; (n-1)必须为0<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &amp; (n-<span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Power-of-Four"><a href="#Power-of-Four" class="headerlink" title="Power of Four"></a>Power of Four</h1><p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.<br>按照上一题的思路，我们先列举出几个4的次方数，观察他门的规律<br>1<br>100<br>10000<br>1000000<br>我们发现不仅要2的次方的性质，还要满足 1所在的位必须是奇数位，所以我们取出奇数位，由于，1只在奇数位，所以取出奇数位后，应该还和原来的数相等<br>取奇数位的方法在反转bit那题中已经讲过，就是x &amp; 0x55555555</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (num &gt; <span class="number">0</span>) &amp;&amp; ((num &amp; (num - <span class="number">1</span>)) == <span class="number">0</span>) &amp;&amp; ((num &amp; <span class="number">0x55555555</span>) == num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 数据结构与算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一篇文章搞懂红黑树的原理及实现]]></title>
      <url>/2017/07/13/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h1 id="2-3-4-Tree-2-3-4树"><a href="#2-3-4-Tree-2-3-4树" class="headerlink" title="2-3-4 Tree(2-3-4树)"></a>2-3-4 Tree(2-3-4树)</h1><p>二叉查找树（Binary Search Tree，简称BST）是一棵二叉树，它的左子节点的值比父节点的值要小，右节点的值要比父节点的值大。它的高度决定了它的查找效率。<br>我们知道二叉查找树。每个节点只可以有一个key，而2-3-4树就是将节点的key的数量增加，可以有多个key，并且2-3-4树可以保持完美平衡（Perfect balance. Every path from root to leaf has same length）<br><a id="more"></a><br>什么是完美平衡（Perfect balance）？实际上就是每条从根节点到叶节点的路径的高度都是一样的（Every path from root to leaf has same length）</p>
<p>2-3-4树的名字是根据子节点数来确定的。<br>我们看2-3-4树的key的种类。</p>
<ul>
<li>2-node: one key, two children.一个key值，两个儿子节点</li>
<li>3-node: two keys, three children。两个key值，三个儿子节点</li>
<li>4-node: three keys, four children.三个key值，四个儿子节点</li>
</ul>
<p>其中2-node的左孩子就代表比key小，右孩子就代表比key大，<br>3-node的左孩子代表比第一个key小，中间的孩子代表值位于第一个key和第二个key之间，右孩子代表值大于第二个key<br>4-node同理</p>
<p>我们看一棵2-3-4树的例子</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-80e8412ffc8bfa41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="2-3-4树的查找（Search-in-a-2-3-4-Tree）"><a href="#2-3-4树的查找（Search-in-a-2-3-4-Tree）" class="headerlink" title="2-3-4树的查找（Search in a 2-3-4 Tree）"></a>2-3-4树的查找（Search in a 2-3-4 Tree）</h2><p>2-3-4的查找类似于BST的查找，只要递归找到所在的子树就可以。</p>
<ul>
<li>比较要查找的key与当前节点中的key值</li>
<li>根据key值选择要查找的key所存在的子树区间</li>
<li>重复上述步骤（递归实现），直到查找到key</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-1c615e5112534937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="2-3-4的插入（Insertion-in-a-2-3-4-Tree）"><a href="#2-3-4的插入（Insertion-in-a-2-3-4-Tree）" class="headerlink" title="2-3-4的插入（Insertion in a 2-3-4 Tree）"></a>2-3-4的插入（Insertion in a 2-3-4 Tree）</h2><p>2-3-4的插入有几种情况，下面我们会一一的讨论。</p>
<p>首先，如果是向一个2-node插入节点的话，那么直接将它转换为3-node就可以了。 </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-1525cca37c3488e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-b707686b54e08fbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果我们是向3-node插入，就将3-node变成4-node即可</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-9cf4a9bcd9e0c934.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-3809bdb008539f1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>那么问题就来了，如果我们向4-node插入呢?<br>显然我们无法直接插入，因为4-node已经是最大的节点了。<br>这时，我们就需要对节点进行一些变换</p>
<p>最常用的方法就是将4-node的中间节点向上移动，移动到父节点中。这样就可以插入了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-c447ed63143a9853.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-d149a3166937c7a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-667f7ed9e4158e9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-950d991e80b458bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>但这个方法有一个问题，就是如果父节点是4-node，那么就无法切分中间节点了。</p>
<p> <strong> 一种解决的方法就是ensures that the “current” node is not a 4-node<br>，我们做出保证父节点永远不会是4-node，就是说4-node不会出现在最后一层以外的层上。</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-5100136e0758ec2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>所以我们需要维持一个不变的条件，当前的父节点永远不会是4-node</p>
<p>也就是，4-node的子节点中又有一个子节点是不可能的<br>最底部的节点中不可能出现4-node，只可能出现2-node和3-node</p>
<p>下面分别分析切分4-node的几种不同情况</p>
<p>首先，4-node 的父节点是2-node 的情况，同样是把中间节点向上移动</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-3ca719a29c82c8e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-c3ed19a13945a193.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>对于4-node的父节点是3-node的情况，也是同样处理，将middle中间节点向上移动</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-9256538d4051e046.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-735c841c8872824b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们看一下如何从空开始插入建立一个2-3-4树</p>
<p>下面，我们通过动态添加一个完整的2-3-4的过程，说明2-3-4树的插入和构建过程</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-33363fe24c79fd4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-2a973a850782c9a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-a84a3ba8197f9a74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-e74eae0540a8c39b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们发现，2-3-4树所有叶子节点都在同一个高度上。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-022f76ac86a2c899.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们分析2-3-4树的效率：</p>
<ul>
<li>2-3-4的高度的最坏情况（全是2-node），也就相当于演变成了平衡二叉树 ： 相当于平衡二叉树 lgN</li>
<li>2-3-4树高度的最好情况（全是4-node），log4 N = 1/2 lg N（但我们知道这种情况是不可能出现的，因为我们要求4-node的父节点或者子节点不能是4-node）</li>
<li>对于100万个节点，2-3-4树的高度会在10~20之间</li>
<li>对于10亿的节点，2-3-4树的高度会在15~30之间</li>
</ul>
<p>由此来看，2-3-4树的效率比平衡二叉树要好，但是问题在于，2-3-4树并不好实现</p>
<ul>
<li>首先，我们需要用三种不同类型的节点代表2-3-4node</li>
<li>然后，在插入节点的时候，我们可能需要进行大量的切分4-node的工作</li>
<li>我们可能也需要频繁的在三种节点之间进行转换</li>
</ul>
<p>一个简单的伪码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void insert(Key key, Val val)</span><br><span class="line">&#123;</span><br><span class="line">Node x = root;</span><br><span class="line">while (x.getTheCorrectChild(key) != null)</span><br><span class="line">&#123;</span><br><span class="line">x = x.getTheCorrectChild(key);</span><br><span class="line">if (x.is4Node()) x.split();</span><br><span class="line">&#125;</span><br><span class="line">if (x.is2Node()) x.make3Node(key, val);</span><br><span class="line">else if (x.is3Node()) x.make4Node(key, val);</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了更好的利用2-3-4树平衡高度的特点，同时又更好的便于实现，我们就引入了红黑树。</p>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><ul>
<li>我们用最常见的平衡二叉树来代表2-3-4树</li>
<li>我们通过给节点区分红色和黑色来区分三种不同的节点。（红边指向下的节点为红节点）</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-9491479c12ac4885.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-9113e1726303dea2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这样我们就可以BST来代表2-3-4树了。看下面的例子</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-632cb5a46e914117.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>但是存在一个问题，就是对于一棵2-3-4树可能有多种不同的表示，这是在于对于3-node的表示，红色的边可以向左倾，也可以向右倾。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-a93b161e029f3adf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>所以就要考虑很多情况。</p>
<p>但我们在此只考虑左倾的情况，所以这种树也叫做左倾红黑树<br>这样，对于任何一棵2-3-4树，我们都可以得到一棵唯一对应的左倾红黑树</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-146857a811783c59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>对于左倾红黑树，我们还有以下要求，就是不能以下情况的节点情况：</p>
<ul>
<li>首先，由于是左倾的，就不能出现右倾的3-node</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-161326d60bee054c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>其次，不允许出现两个红边连在一起的情况，变成2-3-4树的情况就是不允许两个3-node相互连接</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-369b7dc2afb8046f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="左倾红黑树的ADT"><a href="#左倾红黑树的ADT" class="headerlink" title="左倾红黑树的ADT"></a>左倾红黑树的ADT</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class BST&lt;Key extends Comparable&lt;Key&gt;, Value&gt;</span><br><span class="line">&#123;</span><br><span class="line">private static final boolean RED = true;</span><br><span class="line">private static final boolean BLACK = false;</span><br><span class="line">private Node root;</span><br><span class="line">private class Node</span><br><span class="line">&#123;</span><br><span class="line">Key key;</span><br><span class="line">Value val;</span><br><span class="line">Node left, right;</span><br><span class="line">boolean color;</span><br><span class="line">Node(Key key, Value val, boolean color)</span><br><span class="line">&#123;</span><br><span class="line">this.key = key;</span><br><span class="line">this.val = val;</span><br><span class="line">this.color = color;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public Value get(Key key)</span><br><span class="line">// Search method.</span><br><span class="line">public void put(Key key, Value val)</span><br><span class="line">// Insert method.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean isRed(Node x)</span><br><span class="line">&#123;</span><br><span class="line">if (x == null) return false;</span><br><span class="line">return (x.color == RED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>红黑树的get方法和BST是一样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Value get(Key key)</span><br><span class="line">&#123;</span><br><span class="line">Node x = root;</span><br><span class="line">while (x != null)</span><br><span class="line">&#123;</span><br><span class="line">int cmp = key.compareTo(x.key);</span><br><span class="line">if (cmp == 0) return x.val;</span><br><span class="line">else if (cmp &lt; 0) x = x.left;</span><br><span class="line">else if (cmp &gt; 0) x = x.right;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Key min()</span><br><span class="line">&#123;</span><br><span class="line">Node x = root;</span><br><span class="line">while (x != null) x = x.left;</span><br><span class="line">if (x == null) return null;</span><br><span class="line">else return x.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="左倾红黑树的插入"><a href="#左倾红黑树的插入" class="headerlink" title="左倾红黑树的插入"></a>左倾红黑树的插入</h2><p>插入操作是红黑树中最复杂的操作之一。因为不仅要插入还要维持红黑颜色的。</p>
<p>首先，我们先介绍如何对红黑树的一些节点进行转换操作</p>
<ul>
<li>左旋操作<br>左旋操作就是将右倾的3-node变成左倾的3-node</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-c1e88e1f0e0eb15d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private Node rotateLeft(Node h)</span><br><span class="line">&#123;</span><br><span class="line">Node x = h.right;</span><br><span class="line">h.right = x.left;</span><br><span class="line">x.left = h;</span><br><span class="line">x.color = x.left.color;</span><br><span class="line">x.left.color = RED;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>右旋操作<br>就是与左旋操作相反</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-7f7345d921527165.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private Node rotateRight(Node h)</span><br><span class="line">&#123;</span><br><span class="line">Node x = h.left;</span><br><span class="line">h.left = x.right;</span><br><span class="line">x.right = h;</span><br><span class="line">x.color = x.right.color;</span><br><span class="line">x.right.color = RED;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们来具体分析插入操作</p>
<p>当我们要向红黑树的底部插入一个节点的时候，就可能出现多种情况</p>
<p>如果我们向2-node的节点插入的话，有两种情况，如果插入左孩子，那么直接插入就可以，但如果插入的是右孩子，为了保持左倾，插入之后，我们需要进行一个左旋操作</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-f1b42bab623ca092.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们可以看到这种情况对应于2-3-4树就是想2-node插入变成3-node</p>
<p>下面一种情况，就是我们向3-node插入一个节点，那么我们就需要将它变成2-3-4树中对应的树节点<br>这也是为什么我们之前定义的不允许的情况中的第二种，不允许两条红边连在一起，也就是不允许两个红节点互为父子节点，因为插入的节点一定是红节点。</p>
<p>向3-node插入有三种情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-8921ae62ff8237eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>向4-node插入：</p>
<p>根据我们之前在2-3-4树中学习的可以知道，我们需要对4-node进行切分，切分的方法就是将4-node的中间节点向上移动到父节点中。</p>
<p>首先，当父节点是2-node时候：</p>
<p>有两种情况</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-0803021127d69531.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们发现在红黑树中进行切分工作很简单，只要将两个红节点变成黑，然后父节点变成红就可以了。这个变换的过程，我们叫做 color flip。</p>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Node colorFlip(Node h)</span><br><span class="line">&#123;</span><br><span class="line">x.color = !x.color;</span><br><span class="line">x.left.color = !x.left.color;</span><br><span class="line">x.right.color = !x.right.color;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>过程如下图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-a2054eae3889a76a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>对于父节点为3-node的情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-e11b876b32ed79f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>观察这五种情况，我们发现首先都是先惊醒color flip操作，然后就变成了之前的操作，左旋和右旋。</p>
<p>我们可以把上面这些插入操作总结，然后实现一个统一适用的插入算法</p>
<ul>
<li>首先，向空节点插入一个节点，一定为红节点</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-3a355aa2adfd6aa7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (h == null)</span><br><span class="line">return new Node(key, value, RED);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果出现了4-node的情况，我们我们就进行color flip</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-c5fdd5bac29c4982.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (isRed(h.left) &amp;&amp; isRed(h.right))</span><br><span class="line">colorFlip(h);</span><br></pre></td></tr></table></figure>
<ul>
<li>调整右倾的节点</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-5d5b1cca45c154b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (isRed(h.right))</span><br><span class="line">h = rotateLeft(h);</span><br></pre></td></tr></table></figure>
<ul>
<li>对连续的两个红节点进行转换</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-9a7646e6e7a96855.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (isRed(h.left) &amp;&amp; isRed(h.left.left))</span><br><span class="line">h = rotateRight(h);</span><br></pre></td></tr></table></figure>
<h2 id="左倾红黑树插入算法的实现"><a href="#左倾红黑树插入算法的实现" class="headerlink" title="左倾红黑树插入算法的实现"></a>左倾红黑树插入算法的实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (h == null)</span><br><span class="line">return new Node(key, val, RED);</span><br><span class="line">if (isRed(h.left) &amp;&amp; isRed(h.right))</span><br><span class="line">colorFlip(h);</span><br><span class="line">int cmp = key.compareTo(h.key);</span><br><span class="line">if (cmp == 0) h.val = val;</span><br><span class="line">else if (cmp &lt; 0)</span><br><span class="line">h.left = insert(h.left, key, val);</span><br><span class="line">else</span><br><span class="line">h.right = insert(h.right, key, val);</span><br><span class="line">if (isRed(h.right))</span><br><span class="line">h = rotateLeft(h);</span><br><span class="line">if (isRed(h.left) &amp;&amp; isRed(h.left.left))</span><br><span class="line">h = rotateRight(h);</span><br><span class="line">return h;</span><br></pre></td></tr></table></figure>
<p>这里代码的执行顺序是很重要的。</p>
<p>比如如果我们把colorfilp移到最后，那么会出现什么情况？</p>
<p>由于每次在最后都将4-node 进行color flip了，那么自然红黑树中不存在4-node了，所以就变成了2-3树的红黑树</p>
<p>我们可以对比普通红黑树的插入算法的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private Node insert(Node x, Key key, Value val, boolean sw)</span><br><span class="line">&#123;</span><br><span class="line">if (x == null)</span><br><span class="line">return new Node(key, value, RED);</span><br><span class="line">int cmp = key.compareTo(x.key);</span><br><span class="line">if (isRed(x.left) &amp;&amp; isRed(x.right))</span><br><span class="line">&#123;</span><br><span class="line">x.color = RED;</span><br><span class="line">x.left.color = BLACK;</span><br><span class="line">x.right.color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line">if (cmp == 0) x.val = val;</span><br><span class="line">else if (cmp &lt; 0))</span><br><span class="line">&#123;</span><br><span class="line">x.left = insert(x.left, key, val, false);</span><br><span class="line">if (isRed(x) &amp;&amp; isRed(x.left) &amp;&amp; sw)</span><br><span class="line">x = rotR(x);</span><br><span class="line">if (isRed(x.left) &amp;&amp; isRed(x.left.left))</span><br><span class="line">&#123;</span><br><span class="line">x = rotR(x);</span><br><span class="line">x.color = BLACK; x.right.color = RED;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else // if (cmp &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">x.right = insert(x.right, key, val, true);</span><br><span class="line">if (isRed(h) &amp;&amp; isRed(x.right) &amp;&amp; !sw)</span><br><span class="line">x = rotL(x);</span><br><span class="line">if (isRed(h.right) &amp;&amp; isRed(h.right.right))</span><br><span class="line">&#123;</span><br><span class="line">x = rotL(x);</span><br><span class="line">x.color = BLACK; x.left.color = RED;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return x;</span><br></pre></td></tr></table></figure></p>
<h1 id="左倾红黑树的删除操作"><a href="#左倾红黑树的删除操作" class="headerlink" title="左倾红黑树的删除操作"></a>左倾红黑树的删除操作</h1><p>首先我们介绍一下，删除完成之后，如何调整红黑树为左倾的红黑树？<br>这里有一个方法，主要就是进行三个调整的步骤<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private Node fixUp(Node h)</span><br><span class="line">&#123;</span><br><span class="line">if (isRed(h.right))</span><br><span class="line">h = rotateLeft(h);</span><br><span class="line">if (isRed(h.left) &amp;&amp; isRed(h.left.left))</span><br><span class="line">h = rotateRight(h);</span><br><span class="line">if (isRed(h.left) &amp;&amp; isRed(h.right))</span><br><span class="line">colorFlip(h);</span><br><span class="line">return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="删除操作的原则"><a href="#删除操作的原则" class="headerlink" title="删除操作的原则"></a>删除操作的原则</h2><ul>
<li>删除的当前节点不能是2-node</li>
<li>如果有必要可以变换成4-node</li>
<li>从底部删除节点</li>
<li>向上的fix过程中，消除4-node</li>
</ul>
<p>红黑树的删除操作与插入操作一样，极其复杂，所以先从相对容易的情况开始考虑</p>
<h2 id="删除最大节点"><a href="#删除最大节点" class="headerlink" title="删除最大节点"></a>删除最大节点</h2><p>显然最大节点一定是在最右边</p>
<p>如果我们删除的节点在3-node或者4-node中，我们直接删除掉就可以了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-cd44384632545d93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>最复杂的情况，是我们要删除的节点是2-node，如果我门直接删除就会破坏红黑树的平衡，所以我们再删除之前，要进行一定的变换，变成3-node或者4-node，也就是借一个或者两个节点过来。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-f927a676b1de85e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>根据父节点的不同。3-node或者4-node和兄弟节点的不同可以分为六种情况，但其中又可以分为两类</p>
<ul>
<li>第一种处理方法就是兄弟节点不是2-node，就可以直接从兄弟节点借一个节点过来</li>
<li>第二种处理方法兄弟节点是2-node，则从父节点中借一个过来，然后和兄弟节点合并成一个4-node</li>
</ul>
<p>这六种情况的条件根据2-3-4树转换成红黑树，就是h.right和h.right.left均为黑色。<br>但其中有需要分为两种<br>对于上述提到的第二种处理方法，处理比较简单，直接color flip即可</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-6a008334453c9961.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>其中这种情况的条件就是左子节点为2-node，也就是h.left.left为黑。</p>
<p>对于h.left.left为红的情况，就对应上述的第一种处理方法，首先color filp，然后还要借一个节点过来</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-ee596b5870e61927.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>所以将上面两种方法合并：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private Node moveRedRight(Node h)</span><br><span class="line">&#123;</span><br><span class="line">colorFlip(h);</span><br><span class="line">if (isRed(h.left.left))</span><br><span class="line">&#123;</span><br><span class="line">h = rotateRight(h);</span><br><span class="line">colorFlip(h);</span><br><span class="line">&#125;</span><br><span class="line">return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们就可以得到删除最大节点的算法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void deleteMax()</span><br><span class="line">&#123;</span><br><span class="line">root = deleteMax(root);</span><br><span class="line">root.color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line">private Node deleteMax(Node h)</span><br><span class="line">&#123;</span><br><span class="line">if (isRed(h.left))</span><br><span class="line">h = rotateRight(h);</span><br><span class="line">if (h.right == null)</span><br><span class="line">return null;</span><br><span class="line">if (!isRed(h.right) &amp;&amp; !isRed(h.right.left))</span><br><span class="line">h = moveRedRight(h);</span><br><span class="line">h.left = deleteMax(h.left);</span><br><span class="line">return fixUp(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-1e547c3b549ec1e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>流程就是：</p>
<ul>
<li>首先如果左旋则变为右旋，因为找最大节点在最右边</li>
<li>如果，已经到了最底部，那么直接移除就行，移除的要求是最底部的节点一定是red</li>
<li>如果遇到了2-node就借一个节点</li>
<li>继续往下递归查找</li>
<li>删除完毕，就恢复红黑树</li>
</ul>
<p>我们下面看两个例子</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-3dcddf5c89b5a530.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-0457a5550a6c0108.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="删除红黑树最小节点"><a href="#删除红黑树最小节点" class="headerlink" title="删除红黑树最小节点"></a>删除红黑树最小节点</h1><p>最小节点的方法与最大节点的类似，只不过是从最右边变成了最左边</p>
<p>思想还是一样的</p>
<p>首先，不变量，就是h或者h的left一定是红色的。遇到底部的红节点，就直接删除了。</p>
<p>然后就是对于2-node需要从兄弟节点中借一个节点变成3-node或者4-node<br>2-node的条件就是，h.left和h.left.left均为黑色的。<br>然后其中又有两种情况，如果h.right.left为黑，则说明兄弟节点也是2-node，就从父节点借节点，直接color flip即可</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-4308264e344ddf81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果h.right.left为红，则可以直接从兄弟节点借一个节点过来。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-3de63234971e982c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>代码是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private Node moveRedLeft(Node h)</span><br><span class="line">&#123;</span><br><span class="line">colorFlip(h);</span><br><span class="line">if (isRed(h.right.left))</span><br><span class="line">&#123;</span><br><span class="line">h.right = rotateRight(h.right);</span><br><span class="line">h = rotateLeft(h);</span><br><span class="line">colorFlip(h);</span><br><span class="line">&#125;</span><br><span class="line">return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后归纳得到删除最小节点的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void deleteMin()</span><br><span class="line">&#123;</span><br><span class="line">root = deleteMin(root);</span><br><span class="line">root.color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line">private Node deleteMin(Node h)</span><br><span class="line">&#123;</span><br><span class="line">if (h.left == null)</span><br><span class="line">return null;</span><br><span class="line">if (!isRed(h.left) &amp;&amp; !isRed(h.left.left))</span><br><span class="line">h = moveRedLeft(h);</span><br><span class="line">h.left = deleteMin(h.left);</span><br><span class="line">return fixUp(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>流程如下</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-7e9162ea1fee7d11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>两个删除最小节点的例子：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-873febfd1b613477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="删除任意节点"><a href="#删除任意节点" class="headerlink" title="删除任意节点"></a>删除任意节点</h1><p>我们学习了怎么删除最大节点和最小节点，下面我们开始研究最复杂的情况，就是删除任意节点<br>其实思路是一样的，如果所要删除的节点在3-node或者4-node中，根据2-3-4树的性质直接删除就可以了。<br>最复杂的情况是如果是2-node，那么删除就会引起不平衡。所以就得从兄弟节点中借一个节点，但由于是任意节点，不像删除最大最小的情况，确定是左边或者右边，而是有很多种情况。<br>根据理论研究，9 <em> 6 + 27 </em> 9 + 81 * 12 = 1269多种情况（我也不知道咋算的哈哈，有兴趣去看论文）<br>所以单纯的这种思路是不行的。</p>
<p>我们变换想法，类似于堆，我们如果要删除一个节点，把要删除的那个节点和最底部的节点交换，然后就变成删除最底部的节点，就可以转换成删除最大节点或者最小节点了。这也就是我们为什么要先讲最大节点和最小节点。同时这样也把问题简化了，因为删除最大和最小节点的方法我们已经分析出来了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-031c57c983791aaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果我们要删除D节点，我们可以选择用D节点左子树的最大节点或者右子树的最小节点来替换D的值，然后再删除最大节点或者最小节点就可以了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-989719dfce5f9a19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-2b8fb4ed307f0503.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-8117e821cddfbc99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h.key = min(h.right);</span><br><span class="line">h.value = get(h.right, h.key);</span><br><span class="line">h.right = deleteMin(h.right);</span><br></pre></td></tr></table></figure></p>
<p>对于删除的节点在最底部的情况，则我们可以直接利用前面最大节点和最小节点的方法往下搜索就行了，如果所删除的节点比当前节点大，就往右搜索，采取删除最大节点的搜索路径，反之，就往左搜索。</p>
<h2 id="红黑树删除任意节点的代码"><a href="#红黑树删除任意节点的代码" class="headerlink" title="红黑树删除任意节点的代码"></a>红黑树删除任意节点的代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private Node delete(Node h, Key key)</span><br><span class="line">&#123;</span><br><span class="line">int cmp = key.compareTo(h.key);</span><br><span class="line">if (cmp &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">if (!isRed(h.left) &amp;&amp; !isRed(h.left.left))</span><br><span class="line">h = moveRedLeft(h);</span><br><span class="line">h.left = delete(h.left, key);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if (isRed(h.left)) h = leanRight(h);</span><br><span class="line">if (cmp == 0 &amp;&amp; (h.right == null))</span><br><span class="line">return null;</span><br><span class="line">if (!isRed(h.right) &amp;&amp; !isRed(h.right.left))</span><br><span class="line">h = moveRedRight(h);</span><br><span class="line">if (cmp == 0)</span><br><span class="line">&#123;</span><br><span class="line">h.key = min(h.right);</span><br><span class="line">h.value = get(h.right, h.key);</span><br><span class="line">h.right = deleteMin(h.right);</span><br><span class="line">&#125;</span><br><span class="line">else h.right = delete(h.right, key);</span><br><span class="line">&#125;</span><br><span class="line">return fixUp(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程图如下：<br><img src="http://upload-images.jianshu.io/upload_images/1234352-68efb3408371be41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我们就基本讲完了红黑树的基本原理和实现。<br>我们首先从2-3-4树开始讲起，然后引出红黑树其实就是2-3-4树的BST的表示。接着介绍插入和删除算法。<br>很少需要我们自己手动实现红黑树，但我们需要对红黑树的基本原理，作用，算法的思路有一个基本的了解。这篇文章的目的就在此。</p>
<p>本文主要基于<a href="http://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf" target="_blank" rel="noopener">http://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf</a><br>这篇文章来讲解的，有兴趣的可以参考</p>
]]></content>
      
        <categories>
            
            <category> 数据结构与算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 红黑树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之桥接模式（Bridge_模式）]]></title>
      <url>/2017/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Bridge-%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li>类的功能层次</li>
<li>类的实现层次</li>
<li>桥接模式的具体事例</li>
<li>小结</li>
</ul>
</blockquote>
<p>Bridge的意思是桥梁，作用就是将两边连接起来。桥接模式的作用也是如此，桥接模式分别<strong>类的功能层次</strong>和<strong>类的实现层次</strong>连接起来。</p>
<p>这里出现了两个可能有点陌生的词汇，类的功能层次和类的实现层次。</p>
<p>所以我们先来介绍这两种的层次结构，因为桥接模式就是为了连接这两种层次结构。<br><a id="more"></a></p>
<h1 id="类的功能层次"><a href="#类的功能层次" class="headerlink" title="类的功能层次"></a>类的功能层次</h1><p>用于添加的新的功能，假如现在有一个类，我们想在这个类中添加一个新的功能，同时又不改变原有的类，那么我们可以采用继承的方法，继承自这个类，然后在继承的类中添加一个具体的新的方法。这就是类的功能层次。</p>
<ul>
<li>父类拥有基本的功能</li>
<li>子类对类的功能进行扩展，添加的新的功能</li>
</ul>
<p>注意：类的功能层次不能太深</p>
<h1 id="类的实现层次"><a href="#类的实现层次" class="headerlink" title="类的实现层次"></a>类的实现层次</h1><p>用于添加新的实现。假如我们现在有一个抽象类或者接口，里面定义了相应的方法，但是没有实现，对于不同的具体的实现我们需要继承这个抽象类或者实现接口，这就是类的实现层次。</p>
<ul>
<li>父类通过声明抽象方法来定义接口</li>
<li>子类通过实现具体方法来实现接口</li>
</ul>
<h1 id="类的层次结构的混杂与分离"><a href="#类的层次结构的混杂与分离" class="headerlink" title="类的层次结构的混杂与分离"></a>类的层次结构的混杂与分离</h1><p>所以学习了类的功能层次和实现层次之后，我们在编写子类的就可以考虑一个问题，我们要添加功能还是添加实现。当类的层次结构只有一层的时候，功能层次结构与实现层次结构是混在一起的，这样就容易是类的层次结构变得复杂难以理解。<br>因此，我们需要将类的功能层次和实现层次分离为两个独立的层次结构，但又不能的简单的分开，分开之后又要添加某种联系，这种联系就是桥梁，也就是我们本文要讲的桥接模式。</p>
<h1 id="桥接模式的具体实例"><a href="#桥接模式的具体实例" class="headerlink" title="桥接模式的具体实例"></a>桥接模式的具体实例</h1><p>这个实例的功能就是打印显示某个东西。</p>
<ul>
<li>我们先考虑类的功能层次</li>
</ul>
<p>类的功能层次只需要考虑具体需要考虑哪些，具体的实现交给实现层次去实现，那么功能层次为了调用实现层次，就需要持有一个实现层次的对象，就是委托。</p>
<p>功能层次的基类Display<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Bridge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> DisplatImpl impl;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Display</span><span class="params">(DisplatImpl impl)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.impl = impl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		impl.rawOpen();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		impl.rawPrint();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		impl.rawClose();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		open();</span><br><span class="line">		print();</span><br><span class="line">		close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们给这个类添加功能，可以多次显示的功能<br>COuntPlay:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Bridge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDisplay</span> <span class="keyword">extends</span> <span class="title">Display</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CountDisplay</span><span class="params">(DisplatImpl impl)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(impl);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiDisplay</span><span class="params">(<span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line">		open();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;times;i++)</span><br><span class="line">			print();</span><br><span class="line">		close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>类的实现层次</li>
</ul>
<p>首先，类的实现层次的基类应该是一个接口或者抽象类，他定义了需要实现的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Bridge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DisplatImpl</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">rawOpen</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">rawPrint</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">rawClose</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们看一个真正的具体实现，实现了上述的接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDisplayImpl</span> <span class="keyword">extends</span> <span class="title">DisplayImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String string;                              <span class="comment">// 要显示的字符串</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width;                                  <span class="comment">// 以字节单位计算出的字符串的宽度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringDisplayImpl</span><span class="params">(String string)</span> </span>&#123;           <span class="comment">// 构造函数接收要显示的字符串string</span></span><br><span class="line">        <span class="keyword">this</span>.string = string;                           <span class="comment">// 将它保存在字段中</span></span><br><span class="line">        <span class="keyword">this</span>.width = string.getBytes().length;          <span class="comment">// 把字符串的宽度也保存在字段中，以供使用。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rawOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printLine();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rawPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"|"</span> + string + <span class="string">"|"</span>);         <span class="comment">// 前后加上"|"并显示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rawClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printLine();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"+"</span>);                          <span class="comment">// 显示用来表示方框的角的"+"</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width; i++) &#123;               <span class="comment">// 显示width个"-"</span></span><br><span class="line">            System.out.print(<span class="string">"-"</span>);                      <span class="comment">// 将其用作方框的边框</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"+"</span>);                        <span class="comment">// 显示用来表示方框的角的"+"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后我们来调用这两个层次：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Display d1 = <span class="keyword">new</span> Display(<span class="keyword">new</span> StringDisplayImpl(<span class="string">"Hello, China."</span>));</span><br><span class="line">        Display d2 = <span class="keyword">new</span> CountDisplay(<span class="keyword">new</span> StringDisplayImpl(<span class="string">"Hello, World."</span>));</span><br><span class="line">        CountDisplay d3 = <span class="keyword">new</span> CountDisplay(<span class="keyword">new</span> StringDisplayImpl(<span class="string">"Hello, Universe."</span>));</span><br><span class="line">        d1.display();</span><br><span class="line">        d2.display();</span><br><span class="line">        d3.display();</span><br><span class="line">        d3.multiDisplay(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-10837c15ff603da8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>上述实例的类图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-22d6130b3a418ba0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>Bridge模式的类图也是类似的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-3139c3b3f60223a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>分开后更容易扩展<br>桥接模式的特点是将类的功能层次和实现层次分开。分开之后的好处就是有利于对它们进行扩展，当要添加新的功能的时候，只要在功能层次添加类就可以了。不必对类的实现层次做任何修改。而且增加的功能可以被所有的实现使用。</li>
</ul>
<p>例如，如果我们程序中依赖操作系统的部分划分为max，windows和linux版，我们就可以利用类的桥接层次中的实现层次来表现这些依赖操作系统的部分。</p>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP/IP之路由算法]]></title>
      <url>/2017/06/05/TCP-IP%E4%B9%8B%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>网络层的重要功能就是路由和转发。而路由是根据路由器根据所维护的路由表进行路由选择。所以，如果创建和更新转发表就是一个很重要的问题。通常，在路由时，我们总是选取所需代价最小的一条路由。<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/1234352-27d2e536e2aefc4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>首先，我们需要将网络进行抽象，最常见的抽象就是，将网络抽象成图结构。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-a0d219dad5e8d197.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>每段链路的费用可以总是1，或者是，带宽的倒数、拥塞程度等。</p>
<p>关键问题: 源到目的（如u到z）的最小费用路径是什么？<br>所谓的路由算法: 寻找最小费用路径的算法。</p>
<h1 id="路由算法的分类"><a href="#路由算法的分类" class="headerlink" title="路由算法的分类"></a>路由算法的分类</h1><h2 id="静态路由-vs-动态路由"><a href="#静态路由-vs-动态路由" class="headerlink" title="静态路由 vs 动态路由"></a>静态路由 vs 动态路由</h2><p>静态路由就是所有路由信息由人工静态配置好，以后需要更新的话，就要重新配置。</p>
<ul>
<li>手工配置</li>
<li>路由更新慢</li>
<li>优先级高</li>
</ul>
<p>动态路由就是在网络随时根据网络拓扑结构的结构的变化，进行动态更新</p>
<ul>
<li>路由更新快</li>
<li>定期更新</li>
<li>及时响应链路费用或网络拓扑变化</li>
</ul>
<h2 id="全局信息-vs-分散信息"><a href="#全局信息-vs-分散信息" class="headerlink" title="全局信息 vs 分散信息"></a>全局信息 vs 分散信息</h2><p>有的路由算法需要所有路由器掌握完整的网络拓扑和链路费用信息，也就是对网络的全局有一个了解<br>最有代表性的就是链路状态(LS)路由算法。</p>
<p>有的路由算法只需要路由器只掌握物理相连的邻居以及链路费用。通过邻居间信息交换、运算的迭代过程来更新路由信息。<br>最有代表性的就是距离向量(DV)路由算法。</p>
<h1 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h1><p><img src="http://upload-images.jianshu.io/upload_images/1234352-391dfc3db94ea6b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>首先将网络抽象，然后利用图算法中的最短路径算法，Dijkstra 算法。</p>
<p>所有结点(路由器)掌握网络拓扑和链路费用</p>
<ul>
<li>通过“链路状态广播”</li>
<li>所有结点拥有相同信息</li>
</ul>
<p>利用Dijkstra 算法计算从一个结点(“源” )到达所有其他结点的最短路径。从而可以获得该节点的转发表。<br>然后对不同的节点进行迭代，就可以使所有节点都得到自己的转发表。</p>
<ul>
<li>c(x,y): 结点x到结点y链路费用；如果x和y不直接相连，则=∞</li>
<li>D(v): 从源到目的v的当前路径费用值</li>
<li>p(v): 沿从源到v的当前路径， v的前序结点</li>
<li>N’: 已经找到最小费用路径的结点集合</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 初始化:</span><br><span class="line">2 N&apos; = &#123;u&#125;</span><br><span class="line">3 for 所有结点v</span><br><span class="line">4 if v毗邻u</span><br><span class="line">5 then D(v) = c(u,v)</span><br><span class="line">6 else D(v) = ∞</span><br><span class="line">7</span><br><span class="line">8 Loop</span><br><span class="line">9 找出不在 N’中的w ，满足D(w)最小</span><br><span class="line">10 将w加入N&apos;</span><br><span class="line">11 更新w的所有不在N’中的邻居v的D(v) :</span><br><span class="line">12 D(v) = min( D(v), D(w) + c(w,v) )</span><br><span class="line">13 /*到达v的新费用或者是原先到达v的费用，或者是</span><br><span class="line">14 已知的到达w的最短路径费用加上w到v的费用 */</span><br><span class="line">15 until 所有结点在N’中</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-15b14c1ea8f193ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-6a903961381b1370.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>算法复杂性: n个结点</p>
<ul>
<li>每次迭代: 需要检测所有不在集合N’中的结点w</li>
<li>n(n+1)/2次比较: O(n2)</li>
<li>更高效的实现: O(nlogn)</li>
</ul>
<p>算法可能存在震荡现象</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-a8f000104e2daebf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>当链路状态更新的太快并且不断变化的时候，假设我们发出一个分组，结果还没到目的地，路由表就更新了，然后这个数据报就一直在路由间切换，最后由于ttl到0，直接丢弃。这就是震荡现象。</p>
<h1 id="距离向量-Distance-Vector-路由算法"><a href="#距离向量-Distance-Vector-路由算法" class="headerlink" title="距离向量(Distance Vector)路由算法"></a>距离向量(Distance Vector)路由算法</h1><p><img src="http://upload-images.jianshu.io/upload_images/1234352-91fa22cc07f0ab31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-9ecfce52d6bd8763.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>重点：结点获得最短路径的下一跳, 该信息用于转发表中！</p>
<p>核心思想:</p>
<ul>
<li>每个结点不定时地将其自身的DV估计发送给其邻居</li>
<li>当x接收到邻居的新的DV估计时， 即依据B-F更新其自身的距离向量估计：</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-5b426d39ad5c2bff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>Dx(y)将最终收敛于实际的最小费用 dx(y)</p>
<p>异步迭代:</p>
<ul>
<li>引发每次局部迭代的因素</li>
<li>局部链路费用改变</li>
<li>来自邻居的DV更新</li>
</ul>
<p>分布式:</p>
<ul>
<li>每个结点只当DV变化时才通告给邻居</li>
<li>邻居在必要时（其DV更新后发生改变）再通告它们的邻居</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-5b05d5ab9981a609.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="距离向量路由算法：举例"><a href="#距离向量路由算法：举例" class="headerlink" title="距离向量路由算法：举例"></a>距离向量路由算法：举例</h2><p><img src="http://upload-images.jianshu.io/upload_images/1234352-b3c54ae919fe4113.png" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-128e51633d0561c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果链路发生变化，距离向量节点会怎么样呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-3bea61354428f743.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>链路费用变化:</p>
<ul>
<li>结点检测本地链路费用变化</li>
<li>更新路由信息，重新计算距离向量</li>
<li>如果DV改变，通告所有邻居</li>
</ul>
<p>交换过程</p>
<ul>
<li>t0 : y检测到链路费用改变 ，更新DV，通告其邻居.</li>
<li>t1 : z收到y的DV更新，更新其距离向量表，计算到达x的最新最小费用，更新其DV，并发送给其所有邻居.</li>
<li>t2 : y收到z的DV更新， 更新其距离向量表，重新计算y的DV，未发生改变，不再向z发送DV.</li>
</ul>
<p>“好消息传播快！ ”<br>“坏消息会怎么样呢？ ”<br>如果是坏消息，很可能就会出现无穷计数的问题：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-c91226605f50df2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-54986c8006904ad7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们发现 <strong>坏消息传播慢！—“无穷计数(count to infinity)”问题！</strong></p>
<h2 id="无穷计数问题的解决方法"><a href="#无穷计数问题的解决方法" class="headerlink" title="无穷计数问题的解决方法"></a>无穷计数问题的解决方法</h2><h3 id="毒性逆转-poisoned-reverse"><a href="#毒性逆转-poisoned-reverse" class="headerlink" title="毒性逆转(poisoned reverse):"></a>毒性逆转(poisoned reverse):</h3><p>如果一个结点(e.g. Z)到达某目的(e.g.X)的最小费用路径是通过某个邻居(e.g.Y)，则<br>通告给该邻居结点到达该目的的距离为无穷大</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-44118bb7dc4551b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>毒性逆转能否彻底解决无穷计数问题？<br>显然是不行的，如果过于复杂的网络，我们发现毒性逆转也需要经过很多的步骤。</p>
<h3 id="定义最大度量-maximum-metric"><a href="#定义最大度量-maximum-metric" class="headerlink" title="定义最大度量(maximum metric)"></a>定义最大度量(maximum metric)</h3><p>定义一个最大的有效费用值，如15跳步， 16跳步表示∞</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-1f316e098d7005b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h1><p>我们前面的算法是将网络抽象成一张图，但实际上，网络都是很大的，节点数量远超过我们想象，如果我们单纯的使用以上的算法显然是不可行的。</p>
<p>将任意规模网络抽象为一个图计算路由-过于理想化</p>
<ul>
<li>标识所有路由器</li>
<li>“扁平”网络<br>——在实际网络（尤其是大规模网络）中， 不可行！</li>
</ul>
<p>网络规模： 考虑6亿目的结点的网络</p>
<ul>
<li>路由表几乎无法存储！</li>
<li>路由计算过程的信息（ e.g. 链路状态分组、DV）交换量巨大，会淹没链路！</li>
</ul>
<p>另一方面，就是网络管理自治的问题，不同的网络可以采取不同的方法进行路由。<br>管理自治：</p>
<ul>
<li>每个网络的管理可能都期望自主控制其网内的路由</li>
<li>互联网(internet) = 网络之网络(network of networks)</li>
</ul>
<p>层次路由就是解决这样的问题，和网络领域中的问题是一样，继续抽象出一层网络。<br>聚合路由器为一个区域：自治系统AS(autonomous systems)<br>然后再把自治系统看成节点进行路由，对于自治系统内就采取自己的路由方法。这就是抽象成了两层。</p>
<p>同一AS内的路由器运行相同的路由协议(算法)</p>
<ul>
<li>自治系统内部路由协议(“ intra-AS” routing protocol)</li>
<li>不同自治系统内的路由器可以运行不同的AS内部路由协议</li>
</ul>
<p>网关路由器(gateway router):</p>
<ul>
<li>位于AS“边缘”</li>
<li>通过链路连接其他AS的网关路由器</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-27732fb953907b97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>转发表由AS内部路由算法与AS间路由算法共同配置</p>
<ul>
<li>AS内部路由算法设置AS内部目的网络路由入口(entries)</li>
<li>AS内部路由算法与AS间路由算法共同设置AS外部目的网络路由入口</li>
</ul>
<p>假设AS1内某路由器收到一个目的地址在AS1之外的数据报:<br>路由器应该将该数据报转发给哪个网关路由器呢？</p>
<p>AS1必须:<br>1.学习到哪些目的网络可以通过AS2到达，哪些可以通过AS3到达<br>2.将这些网络可达性信息传播给AS1内部路由器</p>
<p>以上这些都是<br><img src="http://upload-images.jianshu.io/upload_images/1234352-7634ae012e22ea5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="例-路由器1d的转发表设置"><a href="#例-路由器1d的转发表设置" class="headerlink" title="例: 路由器1d的转发表设置"></a>例: 路由器1d的转发表设置</h1><p><img src="http://upload-images.jianshu.io/upload_images/1234352-f0a3eba9be55973c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>假设AS1学习到(通过AS间路由协议)：子网x可以通过AS3 (网关 1c)到达，但不能通过AS2到达，AS间路由协议向所有内部路由器传播该可达性信息</p>
<p>为了配置转发表，路由器1d必须确定应该将去往子网x的数据报转发给哪个网关？这个任务也是由AS间路由协议完成!</p>
<ul>
<li>假设AS1通过AS间路由协议学习到：子网x通过AS3和AS2均可到达</li>
<li>为了配置转发表，路由器1d必须确定应该将去往子网x的数据报转发给哪个网关？</li>
<li>这个任务也是由AS间路由协议完成!</li>
<li>热土豆路由: 将分组发送给最近的网关路由器.</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-811011a4f843e9fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
      
        <categories>
            
            <category> 网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP/IP之拥塞控制]]></title>
      <url>/2017/05/31/TCP-IP%E4%B9%8B%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>拥塞(Congestion)<br>给一个非正式定义就是：“太多发送主机发送了太多数据或者发送速度太快，以至于网络无法处理”<br>如果网络中发生了拥塞，会出现如下表现：</p>
<ul>
<li>分组丢失（路由器缓存溢出）</li>
<li>分组延迟过大（在路由器缓存中排队）</li>
</ul>
<p>和可靠数据传输一样都是网络领域中的top-10的问题。</p>
<p>拥塞现象是指到达[通信子网]中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象，严重时甚至会导致网络通信业务陷入停顿，即出现[死锁]现象。这种现象跟公路网中经常所见的交通拥挤一样，当节假日公路网中车辆大量增加时，各种走向的车流相互干扰，使每辆车到达目的地的时间都相对增加（即延迟增加）,甚至有时在某段公路上车辆因堵塞而无法开动(即发生局部[死锁]<br><a id="more"></a><br>我们先讨论一下拥塞的成因和代价</p>
<h1 id="拥塞的成因和代价"><a href="#拥塞的成因和代价" class="headerlink" title="拥塞的成因和代价"></a>拥塞的成因和代价</h1><p>我们通过假设不同的场景渐进式分析拥塞的成因和代价</p>
<h2 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h2><p>我们假设</p>
<ul>
<li>两个senders,两个receivers</li>
<li>一个路由器, 无限缓存</li>
<li>没有重传</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-633e06d49b76e9cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>我们假设原始数据的发送速度为in,到达接受方的速度为out，由于路由器的速度限制，即使无限缓存，到达的最大速度也无法超过路由器的速度</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-caccd52f69f04de2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>即使发送速度再快，到达速度也无法超过路由器的速度，所以时延在拥塞发生的时候会无限增大。</p>
<ul>
<li>拥塞时分组延迟太大</li>
<li>达到最大throughput</li>
</ul>
<h2 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h2><p>我们假设</p>
<ul>
<li>一个路由器, 有限buffers</li>
<li>Sender重传分组</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-4934e1910db79f2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>可以分为一下几种情况讨论</p>
<ul>
<li>情况a: Sender能够通过某种机制获知路由器buffer信息，有空闲才发</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-f4479718fef3e222.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>情况b: 丢失后才重发，显然这样到达速度会减小</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-bbaf1b32f02cfd58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>情况c：分组丢失和定时器超时后都重发，显然到达速度进一步减小</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-2d10eb5ce7d1f4a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>拥塞的代价:</p>
<ul>
<li>对给定的”goodput”，要做更多的工作 (重传)</li>
<li>造成资源的浪费</li>
</ul>
<h2 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h2><ul>
<li>四个发送方</li>
<li>多跳</li>
<li>超时/重传</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-09ab8147393a990f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>随着拥塞的严重，整个网络可能陷入瘫痪，到达速度趋近于0，类似于死锁的状态</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-207f707812cd6e81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>拥塞的另一个代价:</p>
<ul>
<li>当分组被drop时，任何用于该分组的“上游”传输能力全都被浪费掉，相当于白传了，浪费了资源和传输能力</li>
</ul>
<h1 id="拥塞控制的方法"><a href="#拥塞控制的方法" class="headerlink" title="拥塞控制的方法"></a>拥塞控制的方法</h1><p>端到端拥塞控制：</p>
<ul>
<li>网络层不需要显式的提供支持</li>
<li>端系统通过观察loss，delay等<br>网络行为判断是否发生拥塞</li>
<li>TCP采取这种方法<br><em>网络辅助的拥塞控制：
</em>路由器向发送方显式地反馈网络<br>拥塞信息<br><em>简单的拥塞指示(1bit)：SNA,DECbit, TCP/IP ECN, ATM)
</em>指示发送方应该采取何种速度</li>
</ul>
<h2 id="案例：ATM-ABR拥塞控制"><a href="#案例：ATM-ABR拥塞控制" class="headerlink" title="案例：ATM ABR拥塞控制"></a>案例：ATM ABR拥塞控制</h2><ul>
<li>ABR：available bit rate<br> “弹性服务”<br> 如果发送方路径“underloaded”<br>使用可用带宽<br> 如果发送方路径拥塞<br>将发送速率降到最低保障速率</li>
<li>RM(resource management)cells<br> 发送方发送<br> 交换机设置RM cell位(网络辅助)<br>• NI bit: rate不许增长<br>• CI bit: 拥塞指示<br> RM cell由接收方返回给发送方</li>
</ul>
<h1 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h1><h2 id="TCP拥塞控制的基本原理"><a href="#TCP拥塞控制的基本原理" class="headerlink" title="TCP拥塞控制的基本原理"></a>TCP拥塞控制的基本原理</h2><p>Sender限制发送速率</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-1aa66a618c493da7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>CongWin可以动态调整以改变发送速率，并且反映所感知到的网络拥塞。</p>
<p>那么问题来了，如何感知网络拥塞：</p>
<ul>
<li>Loss事件=timeout或3个重复ACK</li>
<li>发生loss事件后，发送方降低速率</li>
</ul>
<p>感知到网络拥塞后，需要动态调整发送速率，以减轻网络的拥塞状况，如何调整发送速率，一般有两个方法：</p>
<ul>
<li>加性增—乘性减: AIMD</li>
<li>慢启动: SS</li>
</ul>
<h2 id="加性增—乘性减-AIMD"><a href="#加性增—乘性减-AIMD" class="headerlink" title="加性增—乘性减: AIMD"></a>加性增—乘性减: AIMD</h2><p>顾名思义，这种方法就是先简单的增加，遇到拥塞的情况，就乘性减少。<br>原理：逐渐增加发送速率，谨慎探测可用带宽，直到发生loss。<br>Additive Increase: 每个RTT将CongWin增大一个MSS——拥塞避免<br>Multiplicative Decrease: 发生loss后将CongWin减半。<br>AIMD方法会使congwin呈锯齿状的波动</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-e9c36c1963b96e3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>首先慢慢增加，当遇到拥塞时，减为一半，然后又继续慢慢增加，直到遇到拥塞后又减为一半，这样往复就会出现锯齿状的波动。</p>
<h2 id="TCP慢启动-SS"><a href="#TCP慢启动-SS" class="headerlink" title="TCP慢启动: SS"></a>TCP慢启动: SS</h2><p>我们考虑下面这种情况：<br>TCP连接建立时，<br>CongWin=1<br> 例：MSS=500 byte,<br>RTT=200msec<br> 初始速率=20k bps<br>我们发现在这种情况下，可用带宽可能远远高于初始速率，如果我们采用加性增的方法就太慢了，我们希望快速增长到可用带宽。<br>这就慢启动算法的思想：<br>当连接开始时，指数性增长。指数性增长。每个RTT将CongWin翻倍。收到每个ACK进行操作。初始速率很慢，但是快速攀升。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-30e0c423185e158c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>那么问题来了，我们什么时候才进行线性增长来避免拥塞控制？<br>我们通过设置一个变量 Threshold，Loss事件发生时, Threshold被设为Loss事件前CongWin值的1/2。然后如果cogwin到了Threshold，就开始线性增长。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-2738b3eb14207b1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如图所示，初始的Threshold变量为8，所以当指数增长大于等于8的时候，就开始线性增长，然后直到发生loss事件，Threshold变为发生loss事件时的一半，也就是6，然后继续指数增长到Threshold，又开始线性增长。</p>
<p>那么我们如何判断loss事件的发生呢？<br>我们分为两种情况来处理：</p>
<ul>
<li>3个重复ACKs:<br>CongWin切到一半，然后线性增长</li>
<li>Timeout事件:<br>CongWin直接设为1个MSS，然后指数增长，达到threshold后, 再线性增长</li>
</ul>
<p>我们想想这样做的原因，因为3个重复ACKs表示网络还能够传输一些 segments<br>，timeout事件表明拥塞更为严重。</p>
<p>慢启动算法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Th = ?</span><br><span class="line">CongWin = 1 MSS</span><br><span class="line">/* slow start or exponential increase */</span><br><span class="line">While (No Packet Loss and CongWin &lt; Th) &#123;</span><br><span class="line">send CongWin TCP segments</span><br><span class="line">for each ACK increase CongWin by 1</span><br><span class="line">&#125;</span><br><span class="line">/* congestion avoidance or linear increase */</span><br><span class="line">While (No Packet Loss) &#123;</span><br><span class="line">send CongWin TCP segments</span><br><span class="line">for CongWin ACKs, increase CongWin by 1</span><br><span class="line">&#125;</span><br><span class="line">Th = CongWin/2</span><br><span class="line">If (3 Dup ACKs) CongWin = Th;</span><br><span class="line">If (timeout) CongWin=1;</span><br></pre></td></tr></table></figure></p>
<p> 一个TCP连接总是以1 KB的最大段长发送TCP段，发送方有足够多的数据要发<br>送。当拥塞窗口为16 KB时发生了超时，如果接下来的4个RTT（往返时间）时<br>间内的TCP段的传输都是成功的，那么当第4个RTT时间内发送的所有TCP段<br>都得到肯定应答时，拥塞窗口大小是多少？<br> 解：threshold=16/2=8 KB, CongWin=1 KB, 1个RTT后， CongWin=2 KB ，2<br>个RTT后， CongWin=4 KB ，3个RTT后， CongWin=8 KB ，Slowstart is<br>over; 4个RTT后， CongWin=9 KB</p>
]]></content>
      
        <categories>
            
            <category> 网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP/IP之可靠数据传输原理]]></title>
      <url>/2017/05/24/TCP-IP%E4%B9%8B%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>可靠数据传输对于应用层、传输层、链路层都很重要，是网络领域的Top10问题。<br>对于传输层来说，由于相邻的网络层是不可靠的，所以要在传输层实现可靠数据传输（rdt）就比较复杂。<br>那么我们来了，究竟怎样才是可靠？<br><a id="more"></a></p>
<blockquote>
<p>我们将讨论一下几个方面的内容<br>信道的(不可靠)特性<br>可靠数据传输的需求<br>Rdt 1.0<br>Rdt 2.0, rdt 2.1, rdt 2.2<br>Rdt 3.0<br>流水线与滑动窗口协议<br>GBN<br>SR</p>
</blockquote>
<h1 id="什么是可靠？"><a href="#什么是可靠？" class="headerlink" title="什么是可靠？"></a>什么是可靠？</h1><ul>
<li>不错<br>就是传输的数据包没有错误</li>
<li>不丢<br>传输的数据包不丢失</li>
<li>不乱<br>传输的数据包顺序要保持正确</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-42e421ecf296175b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>为了更好的说明，我们采取渐进式的设计可靠数据传输的发送方和接收方。</p>
<p>我们考虑第一个版本的可靠数据传输</p>
<h1 id="Rdt-1-0-可靠信道上的可靠数据传输"><a href="#Rdt-1-0-可靠信道上的可靠数据传输" class="headerlink" title="Rdt 1.0: 可靠信道上的可靠数据传输"></a>Rdt 1.0: 可靠信道上的可靠数据传输</h1><blockquote>
<p>假设<br><strong> 底层信道完全可靠 </strong></p>
<ul>
<li>不会发生错误(bit error)</li>
<li>不会丢弃分组<br>显然有了这个假设的话，发送方和接收方只要能正确接收数据就可以了，所以他们是相互独立的，因为发过来的数据保证一定是正确的。</li>
</ul>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-dae1b601dd0f2ba4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h1 id="Rdt-2-0-产生位错误的信道"><a href="#Rdt-2-0-产生位错误的信道" class="headerlink" title="Rdt 2.0: 产生位错误的信道"></a>Rdt 2.0: 产生位错误的信道</h1><p>我们假设底层信道可能翻转分组中的位(bit)</p>
<p>首先如何判断错误，我们可以利用校验和来判断是否发生位错误<br>那么发现了错误，我们该如何处理呢？<br>第一种思路当然是纠正错误，但是这样实现的难度和代价都比较大，在计算机网络中，我们一般都会采取第二种思路<br>第二种思路就是直接重传，如果我们发现了错误，很自然，那我们就重传一次，直到接受方收到正确的分组。<br>还有一个问题就是假设接收方发现了错误，如果告知发送方已经发生了错误呢？<br>其实处理起来也很简单，就是向接收方发送一个信号，代表出现错误，如果没错误就发送一个信号，表示没错误。</p>
<p>如何从错误中恢复？</p>
<ul>
<li>确认机制(Acknowledgements, ACK): 接收方显式地告知发送方分组已正确接收</li>
<li>NAK:接收方显式地告知发送方分组有错误</li>
<li>发送方收到NAK后，重传分组</li>
<li>基于这种重传机制的rdt协议称为ARQ(Automatic Repeat reQuest)协议</li>
</ul>
<p>Rdt 2.0中引入的新机制</p>
<ul>
<li>差错检测</li>
<li>接收方反馈控制消息: ACK/NAK</li>
<li>重传</li>
</ul>
<p>下面两个图分别模拟了有错误和无错误场景：<br>无错误场景<br><img src="http://upload-images.jianshu.io/upload_images/1234352-808292eb4c75ae23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>有错误场景</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-4ca7ce3a82fd7e4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="Rdt-2-1-发送方-应对ACK-NAK破坏"><a href="#Rdt-2-1-发送方-应对ACK-NAK破坏" class="headerlink" title="Rdt 2.1: 发送方, 应对ACK/NAK破坏"></a>Rdt 2.1: 发送方, 应对ACK/NAK破坏</h1><p>我们看rdt2.0有什么问题，我们知道确认信号也需要通过信道传播，那么如果ack，nck的信号发生了错误呢？发送方应该怎么处理？<br>显然发生了错误，我们就应该重传<br>但是这里，又有一个问题，接收方怎么知道发送方这次新传过来的是新的报文段还是因为ack出错而重传的报文段呢？显然我们需要区分，上一个报文段和当前的报文段，我们给报文段编写好序号就可以了，而且只需要0，1两个序号，一个表示上次的报文段，一个表示新接受的。<br>这样接收方如果收到0，就知道这次不是新的报文段，可能是上次ack出错了，发送方无法确认，就重传了上次的报文段，所以接收方需要丢掉这个报文段，然后再次传一次ack确认信号，如果收到的是序号为1的报文段，则接收方直接接受就可以了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-b1b5495dabb01354.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="Rdt-2-1-vs-Rdt-2-0"><a href="#Rdt-2-1-vs-Rdt-2-0" class="headerlink" title="Rdt 2.1 vs. Rdt 2.0"></a>Rdt 2.1 vs. Rdt 2.0</h2><p>发送方：</p>
<ul>
<li>为每个分组增加了序列号</li>
<li>两个序列号(0, 1)就够用，为什么？</li>
<li>需校验ACK/NAK消息是否发生错误</li>
<li>状态数量翻倍</li>
<li>状态必须“记住”“当前”的分组序列号<br>接收方:</li>
<li>需判断分组是否是重复</li>
<li>当前所处状态提供了期望收到分组的序列号</li>
<li>注意：接收方无法知道ACK/NAK是否被发送方正确收到</li>
</ul>
<h1 id="Rdt-2-2-无NAK消息协议"><a href="#Rdt-2-2-无NAK消息协议" class="headerlink" title="Rdt 2.2: 无NAK消息协议"></a>Rdt 2.2: 无NAK消息协议</h1><p>我们考虑一下我们真的需要两个确认信号ack和nck么？<br> 与rdt 2.1功能相同，但是只使用ACK<br>如何实现？<br> 接收方通过ACK告知最后一个被正确接收的分组<br> 在ACK消息中显式地加入被确认分组的序列号<br> 发送方收到重复ACK之后，采取与收到NAK消息相同的动作<br> 重传当前分组</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-ccee276d0d53b937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="Rdt-3-0"><a href="#Rdt-3-0" class="headerlink" title="Rdt 3.0"></a>Rdt 3.0</h1><p>到rdt2.2为止，我们基本解决了“不错”的要求，即报文和确认信息在信道上发生了错误的话，我们都可以很好的解决，解决的方法其实就是重传<br>那么我们接下来就该解决不丢的问题。<br>如果信道既可能发生错误，也可能丢失分组，怎么办？<br>“校验和 + 序列号 + ACK + 重传”够用吗？<br>显然是不够用的’<br>我们假设这时候ack不是错误而是直接丢了，那么发送方就会无限制的等着接收方的ack，同时接收方也会无限制的等着发送方的新报文。<br>这样就陷入了类似死锁的机制，如果不加以处理，那么网络就卡死在这里了。<br>那么我们该如何处理呢？<br>方法：发送方等待“合理”时间<br> 如果没收到ACK，重传<br> 如果分组或ACK只是延迟而不是丢了</p>
<ul>
<li>重传会产生重复，序列号机制能够处理</li>
<li>接收方需在ACK中显式告知所确认的分组</li>
</ul>
<p> 需要定时器</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-7c4c042bccc037a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-3341204bd18bedc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="rdt3-0效率"><a href="#rdt3-0效率" class="headerlink" title="rdt3.0效率"></a>rdt3.0效率</h2><p>Rdt 3.0能够正确工作，但性能很差<br>示例：1Gbps链路，15ms端到端传播延迟，1KB分组</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-3a6170d9c746130d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p> 发送方利用率：发送方发送时间百分比</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-52b2eb0a816ad820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p> 在1Gbps链路上每30毫秒才发送一个分组33KB/sec<br> 网络协议限制了物理资源的利用</p>
<p>这样低效率的原因是，我们采取的是停-等操作<br>就是说发送方发了一个数据包，就停下来了，直到得到来自接收方的确认才发送第二个，这样就造成了很多的空余时间都在空闲等待。</p>
<h1 id="流水线机制与滑动窗口协议"><a href="#流水线机制与滑动窗口协议" class="headerlink" title="流水线机制与滑动窗口协议"></a>流水线机制与滑动窗口协议</h1><p>为了改进停等机制所造成的效率低下，我们可以采用流水线的机制，一次发送多条报文段，充分利用空闲的时间</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-e8af04d63f149b8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>允许发送方在收到ACK之前连续发送多个分组<br> 更大的序列号范围<br> 发送方和/或接收方需要更大的存储空间以缓存分组</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-74602a632f487a0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>进一步的，我们采用滑动窗口协议，顾名思义，就是发送给定窗口大小的报文数，随着报文被接收确认，同时窗口可以动态的向前滑动</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-01e11d92a2b61d3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>滑动窗口协议: Sliding-window protocol<br>窗口<br> 允许使用的序列号范围<br> 窗口尺寸为N：最多有N个等待确认的消息<br>滑动窗口<br> 随着协议的运行，窗口在序列号空间内向前滑动<br>滑动窗口协议：GBN, SR</p>
<h1 id="Go-Back-N-GBN-协议"><a href="#Go-Back-N-GBN-协议" class="headerlink" title="Go-Back-N(GBN)协议"></a>Go-Back-N(GBN)协议</h1><p><img src="http://upload-images.jianshu.io/upload_images/1234352-e253c7bc0098ee72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如图所示，窗口大小N,最多允许N个分组未确认。<br>ACK(n): 确认到序列号n(包含n)的分组均已被正确接收<br> 可能收到重复ACK<br>为没收到确认的分组设置计时器(timer)<br>超时Timeout(n)事件: 重传序列号大于等于n，还未收到ACK的所有分组<br>ACK机制: 发送拥有最高序列号的、已被正确接收的分组的ACK<br> 可能产生重复ACK<br> 只需要记住唯一的expectedseqnum<br>接收方是没有缓存的，所以接收方对于乱序到达的分组直接丢弃，并且重新发送目前为止接收到的分组中序列号最大的按序到达的分组</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-d14b55e7828b9e45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>简单的习题：<br> 数据链路层采用后退N帧（GBN）协议，发送方已经发送了编号为<br>0～7的帧。当计时器超时时，若发送方只收到0、2、3号帧的确认<br>，则发送方需要重发的帧数是多少？分别是那几个帧？<br> 解：根据GBN协议工作原理，GBN协议的确认是累积确认，所以<br>此时发送端需要重发的帧数是4个，依次分别是4、5、6、7号帧</p>
<h1 id="Selective-Repeat协议"><a href="#Selective-Repeat协议" class="headerlink" title="Selective Repeat协议"></a>Selective Repeat协议</h1><p>GBN有什么缺陷？<br>由于GBN接收方没有缓存，对于非按序的分组直接丢弃，就会造成很多到达的分组由于顺序乱了，却白发了，需要再次重新发送。<br>显然为了提高效率，我们可以在接收方设置缓存，对于未按序达到的分组，先存起来，而不是直接丢弃。<br>这就是选择重复协议的思想<br>接收方对每个分组单独进行确认<br> 设置缓存机制，缓存乱序到达的分组<br>发送方只重传那些没收到ACK的分组<br> 为每个分组设置定时器<br>发送方窗口<br> N个连续的序列号<br> 限制已发送且未确认的分组</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-104c336e2f45fd1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-6b7137ad019ce358.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从图中我们可以看到，接收方是动态移动滑动窗口的，只有当窗口部分前面的全部正确接受并确认了，才向前移动。</p>
<h1 id="可靠数据传输原理与协议回顾"><a href="#可靠数据传输原理与协议回顾" class="headerlink" title="可靠数据传输原理与协议回顾"></a>可靠数据传输原理与协议回顾</h1><p>信道的(不可靠)特性<br>可靠数据传输的需求<br>Rdt 1.0<br>Rdt 2.0, rdt 2.1, rdt 2.2<br>Rdt 3.0<br>流水线与滑动窗口协议<br>GBN<br>SR</p>
]]></content>
      
        <categories>
            
            <category> 网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[排列类算法问题大总结]]></title>
      <url>/2017/03/26/%E6%8E%92%E5%88%97%E7%B1%BB%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%E5%A4%A7%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li>全排列</li>
<li>带重复元素的排列</li>
<li>下一个排列</li>
<li>上一个排列</li>
<li>第 k 个排列</li>
<li>排列序号</li>
<li>排列序号II<a id="more"></a>
<h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1>给定一个数字列表，返回其所有可能的排列。</li>
</ul>
</blockquote>
<p> 注意事项</p>
<p>你可以假设没有重复数字。<br>样例<br>给出一个列表[1,2,3]，其全排列为：</p>
<p>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>可以用递归和非递归解决</p>
<p>首先递归法，也是利用了回溯法和深度优先搜索。</p>
<p>我们考虑一个一个将数组元素加入到排列中，递归求解，就好像下面的解答树：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-b54091100c813c0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>添加的时候排除掉相同的元素即可，回溯法我们经常会设置一个已访问标识数组，来表示数组被访问过，但这里不用这样，因为如果list里面已经包含就说明已经访问过了，所以只要判断，跳过已有的元素即可。<br>再考虑递归的结束条件，当元素都添加足够就结束了，添加足够的意思就是，元素个数等于数组的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param nums: A list of integers.</span><br><span class="line">     * @return: A list of permutations.</span><br><span class="line">     */</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">		if(nums == null)</span><br><span class="line">			return res;</span><br><span class="line">		if(nums.length == 0)</span><br><span class="line">		&#123;	</span><br><span class="line">			res.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">			return res;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">		dfs(res, list, nums);</span><br><span class="line">		return res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">	private void dfs(List&lt;List&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; list, int[] nums) &#123;</span><br><span class="line">		</span><br><span class="line">		int n = nums.length;</span><br><span class="line">		if(list.size() == n)</span><br><span class="line">		&#123;	</span><br><span class="line">			res.add(new ArrayList&lt;Integer&gt;(list));</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		for(int i = 0;i &lt; n;i++) &#123;</span><br><span class="line">			if(list.contains(nums[i]))</span><br><span class="line">				continue;</span><br><span class="line">			list.add(nums[i]);</span><br><span class="line">			dfs(res, list, nums);</span><br><span class="line">			list.remove(list.size() - 1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归实现<br>思路是这样的，就是高中的排列组合知识，运用插入法即可，假设有i个元素的排列组合，那么对于i+1个元素，可以考虑就是将i+1的元素插入到上述的排列的每一个位置即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param nums: A list of integers.</span><br><span class="line">     * @return: A list of permutations.</span><br><span class="line">     */</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();  </span><br><span class="line">        if ( nums == null)  </span><br><span class="line">            return res;</span><br><span class="line">        if( nums.length == 0)</span><br><span class="line">        &#123;    </span><br><span class="line">            res.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(nums[0]);</span><br><span class="line">        res.add(new ArrayList&lt;Integer&gt;(list));</span><br><span class="line">        </span><br><span class="line">        for(int i=1;i&lt;nums.length;i++) &#123;</span><br><span class="line">        	int size1 = res.size();</span><br><span class="line">        	for(int j=0;j&lt;size1;j++) &#123;</span><br><span class="line">        		int size2 = res.get(0).size();</span><br><span class="line">        		for(int k=0;k&lt;=size2;k++) &#123;</span><br><span class="line">        			ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;(res.get(0));</span><br><span class="line">        			temp.add(k,nums[i]);</span><br><span class="line">        			res.add(temp);</span><br><span class="line">        		&#125;</span><br><span class="line">        		res.remove(0);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="带重复元素的全排列"><a href="#带重复元素的全排列" class="headerlink" title="带重复元素的全排列"></a>带重复元素的全排列</h1><p>给出一个具有重复数字的列表，找出列表所有不同的排列。</p>
<p>样例<br>给出列表 [1,2,2]，不同的排列有：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-6ce18120a2f1d77b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param nums: A list of integers.</span><br><span class="line">     * @return: A list of unique permutations.</span><br><span class="line">     */</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;</span><br><span class="line">	    </span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        if(nums == null)</span><br><span class="line">        	return null;</span><br><span class="line">        </span><br><span class="line">        if(nums.length == 0)</span><br><span class="line">        &#123;	</span><br><span class="line">        	res.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">        	return res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        //先将数组排序，这样相同元素将会出现在一起</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        int n = nums.length;</span><br><span class="line">        int[] visited = new int[n];</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        	visited[i] = 0;//0标识未访问</span><br><span class="line">        </span><br><span class="line">        helper(res, list, visited, nums);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	private void helper(ArrayList&lt;List&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; list, int[] visited, int[] nums) &#123;</span><br><span class="line">		</span><br><span class="line">		if(nums.length == list.size()) &#123;</span><br><span class="line">			res.add( new ArrayList&lt;Integer&gt;(list));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		for(int i=0;i&lt;nums.length;i++) &#123;</span><br><span class="line">			</span><br><span class="line">			if(visited[i] == 1 || i!= 0 &amp;&amp; (visited[i-1] == 0 &amp;&amp; nums[i] == nums[i-1]))</span><br><span class="line">				continue;</span><br><span class="line">			/*</span><br><span class="line">            上面的判断主要是为了去除重复元素影响。</span><br><span class="line">            比如，给出一个排好序的数组，[1,2,2]，那么第一个2和第二2如果在结果中互换位置，</span><br><span class="line">            我们也认为是同一种方案，所以我们强制要求相同的数字，原来排在前面的，在结果</span><br><span class="line">            当中也应该排在前面，这样就保证了唯一性。所以当前面的2还没有使用的时候，就</span><br><span class="line">            不应该让后面的2使用。</span><br><span class="line">            */</span><br><span class="line">			list.add(nums[i]);</span><br><span class="line">			visited[i] = 1;</span><br><span class="line">			helper(res, list, visited, nums);</span><br><span class="line">			list.remove(list.size()-1);</span><br><span class="line">			visited[i] = 0;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h1><p>给定一个若干整数的排列，给出按正数大小进行字典序从小到大排序后的下一个排列。</p>
<p>如果没有下一个排列，则输出字典序最小的序列。</p>
<p>样例<br>左边是原始排列，右边是对应的下一个排列。</p>
<p>1,2,3 → 1,3,2</p>
<p>3,2,1 → 1,2,3</p>
<p>1,1,5 → 1,5,1</p>
<h1 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h1><p>这道题让我们求下一个排列顺序，有题目中给的例子可以看出来，如果给定数组是降序，则说明是全排列的最后一种情况，则下一个排列就是最初始情况，可以参见之前的博客<a href="http://www.cnblogs.com/grandyang/p/4042156.html" target="_blank" rel="noopener"> </a><a href="http://www.cnblogs.com/grandyang/p/4358848.html" target="_blank" rel="noopener">Permutations 全排列</a>。我们再来看下面一个例子，有如下的一个数组<br>1　　2　　7　　4　　3　　1<br>下一个排列为：<br>1　　3　　1　　2　　4　　7<br>那么是如何得到的呢，我们通过观察原数组可以发现，如果从末尾往前看，数字逐渐变大，到了2时才减小的，然后我们再从后往前找第一个比2大的数字，是3，那么我们交换2和3，再把此时3后面的所有数字转置一下即可，步骤如下：<br>1　　2　　7　　4　　3　　1<br>1　　2　　7　　4　　3　　1<br>1　　3　　7　　4　　2　　1<br>1　　3　　1　　2　　4　　7</p>
<p>所以我们要做的就是找到第一个比peak元素大的数字，交换，然后反转</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param nums: an array of integers</span><br><span class="line">     * @return: return nothing (void), do not return anything, modify nums in-place instead</span><br><span class="line">     */</span><br><span class="line">    public int[] nextPermutation(int[] nums) &#123;</span><br><span class="line">        int i = nums.length - 2;</span><br><span class="line">        while (i &gt;= 0 &amp;&amp; nums[i + 1] &lt;= nums[i]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &gt;= 0) &#123;</span><br><span class="line">            int j = nums.length - 1;</span><br><span class="line">            while (j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[i]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums, i + 1);</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void reverse(int[] nums, int start) &#123;</span><br><span class="line">        int i = start, j = nums.length - 1;</span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void swap(int[] nums, int i, int j) &#123;</span><br><span class="line">        int temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="上一个排列"><a href="#上一个排列" class="headerlink" title="上一个排列"></a>上一个排列</h1><p>给定一个整数数组来表示排列，找出其上一个排列。</p>
<p> 注意事项</p>
<p>排列中可能包含重复的整数</p>
<p>样例<br>给出排列[1,3,2,3]，其上一个排列是[1,2,3,3]</p>
<p>给出排列[1,2,3,4]，其上一个排列是[4,3,2,1]</p>
<h1 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h1><p>与求下一个排列是一样的方法，只是相应的操作变反即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param nums: A list of integers</span><br><span class="line">     * @return: A list of integers that&apos;s previous permuation</span><br><span class="line">     */</span><br><span class="line">    public void swapItem(ArrayList&lt;Integer&gt; nums, int i, int j) &#123;</span><br><span class="line">		Integer tmp = nums.get(i);</span><br><span class="line">		nums.set(i, nums.get(j));</span><br><span class="line">		nums.set(j, tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	public void swapList(ArrayList&lt;Integer&gt; nums, int i, int j) &#123;</span><br><span class="line">		while ( i &lt; j) &#123;</span><br><span class="line">			swapItem(nums, i, j);</span><br><span class="line">			i ++; j --;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    public ArrayList&lt;Integer&gt; previousPermuation(ArrayList&lt;Integer&gt; nums) &#123;</span><br><span class="line">		int len = nums.size();</span><br><span class="line">		if ( len &lt;= 1)</span><br><span class="line">			return nums;</span><br><span class="line">		int i = len - 1;</span><br><span class="line">		while ( i &gt; 0 &amp;&amp; nums.get(i) &gt;= nums.get(i-1) )</span><br><span class="line">			i --;</span><br><span class="line">		swapList(nums, i, len - 1);     </span><br><span class="line">		if ( i != 0) &#123;</span><br><span class="line">			int j = i;</span><br><span class="line">			while ( nums.get(j) &gt;= nums.get(i-1) ) j++;</span><br><span class="line">			swapItem(nums, j, i-1);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="第k个排列"><a href="#第k个排列" class="headerlink" title="第k个排列"></a>第k个排列</h1><p>给定 n 和 k，求123..n组成的排列中的第 k 个排列。</p>
<p> 注意事项</p>
<p>1 ≤ n ≤ 9</p>
<p>样例<br>对于 n = 3, 所有的排列如下：</p>
<p>123<br>132<br>213<br>231<br>312<br>321<br>如果 k = 4, 第4个排列为，231.</p>
<h1 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h1><p>康托展开的公式：（不用记，看形势就行，下面会有例子）</p>
<p>X=an<em>(n-1)!+an-1</em>(n-2)!+…+ai<em>(i-1)!+…+a2</em>1!+a1*0!</p>
<p>ai为整数，并且0&lt;=ai&lt;i(1&lt;=i&lt;=n)</p>
<p>适用范围：没有重复元素的全排列</p>
<p>N个数的第k个排序，例子，1，2，3，4共有4！种排列，1234,1243,1324等等。按顺序应该是</p>
<p>1234</p>
<p>1243</p>
<p>1324</p>
<p>1342</p>
<p>1423</p>
<p>1432等等</p>
<p>可以通过STL中next_permutation（begin, end）;来算下一个全排列，理论上你要算n个数的第k个排列只要调用k-1次next_permutation()就行，但是一般来说肯定会超时的，因为next_permutation的时间复杂度是O(n)（如果自己写出来next_permutation时间复杂度比n大就要注意了，其中一个容易疏忽的地方是最后排序可以用reverse而不是sort）。所以如果用这个的话时间复杂度是O(N^2)。</p>
<p>而用康托展开只要O(n)就行，下面来说说具体怎么做:</p>
<p>题目：找出第16个n = 5的序列（12345）</p>
<p>首先第十六个也就是要前面有15个数，要调用15次next_permutation函数。</p>
<p>根据第一行的那个全排列公式，15 / 4! = 0 …15  =》  有0个数比他小的数是1，所以第一位是1</p>
<p>拿走刚才的余数15，用15 / 3! = 2 …3   =&gt;  剩下的数里有两个数比他小的是4（1已经没了），所以第二位是4</p>
<p>拿走余数3， 用 3 / 2! = 1 …1   =》  剩下的数里有一个数比他小的是3，所以第三位是3</p>
<p>拿走余数1， 用 1/  1! = 1 …0    =&gt;  剩下的数里有一个数比他小的是 5（只剩2和5了），所以第四位是5</p>
<p>所以排列是 1,4,3,5,2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">      * @param n: n</span><br><span class="line">      * @param k: the kth permutation</span><br><span class="line">      * @return: return the k-th permutation</span><br><span class="line">      */</span><br><span class="line">    public String getPermutation(int n, int k) &#123;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        boolean[] used = new boolean[n];</span><br><span class="line"></span><br><span class="line">        k = k - 1;</span><br><span class="line">        int factor = 1;</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            factor *= i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int index = k / factor;</span><br><span class="line">            k = k % factor;</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                if (used[j] == false) &#123;</span><br><span class="line">                    if (index == 0) &#123;</span><br><span class="line">                        used[j] = true;</span><br><span class="line">                        sb.append((char) (&apos;0&apos; + j + 1));</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        index--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &lt; n - 1) &#123;</span><br><span class="line">                factor = factor / (n - 1 - i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sb.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="排列序号"><a href="#排列序号" class="headerlink" title="排列序号"></a>排列序号</h1><p>给出一个不含重复数字的排列，求这些数字的所有排列按字典序排序后该排列的编号。其中，编号从1开始。</p>
<p>样例<br>例如，排列 [1,2,4] 是第 1 个排列。</p>
<h1 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h1><p>这道题是求第k个排列的反向思维</p>
<p>已知是n = 5，求14352是它的第几个序列？（同一道题）</p>
<p>用刚才的那道题的反向思维：</p>
<p>第一位是1，有0个数小于1，即0* 4！</p>
<p>第二位是4，有2个数小于4，即2* 3！</p>
<p>第三位是3，有1个数小于3，即1* 2！</p>
<p>第四位是5，有1个数小于5，即1* 1！</p>
<p>第五位是2，不过不用算，因为肯定是0</p>
<p>所以14352是 n = 5的第 0 + 12 + 2 + 1 + 0 = 15    + 1（求的是第几个，所以要加一） = 16</p>
<p>第16个，跟刚才那道题一样，证明对了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param A an integer array</span><br><span class="line">     * @return a long integer</span><br><span class="line">     */</span><br><span class="line">    public long permutationIndex(int[] A) &#123;</span><br><span class="line">        // Write your code here</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hash = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">		</span><br><span class="line">		for (int i = 0; i &lt; A.length; i++) &#123;</span><br><span class="line">			if (hash.containsKey(A[i]))</span><br><span class="line">				hash.put(A[i], hash.get(A[i]) + 1);</span><br><span class="line">			else &#123;</span><br><span class="line">				hash.put(A[i], 1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		long ans = 0;</span><br><span class="line">		for (int i = 0; i &lt; A.length; i++) &#123;</span><br><span class="line">			for (int j = i + 1; j &lt; A.length; j++) &#123;</span><br><span class="line">				if (A[j] &lt; A[i]) &#123;</span><br><span class="line">					hash.put(A[j], hash.get(A[j])-1);</span><br><span class="line">					ans += generateNum(hash);</span><br><span class="line">					hash.put(A[j], hash.get(A[j])+1);</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			</span><br><span class="line">			&#125;</span><br><span class="line">				hash.put(A[i], hash.get(A[i])-1);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return ans+1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    long fac(int numerator) &#123;</span><br><span class="line">			</span><br><span class="line">		long now = 1;</span><br><span class="line">		for (int i = 1; i &lt;= numerator; i++) &#123;</span><br><span class="line">			now *= (long) i;</span><br><span class="line">		&#125;</span><br><span class="line">		return now;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	long generateNum(HashMap&lt;Integer, Integer&gt; hash) &#123;</span><br><span class="line">		long denominator = 1;</span><br><span class="line">		int sum = 0;</span><br><span class="line">		for (int val : hash.values()) &#123;</span><br><span class="line">			if(val == 0 )	</span><br><span class="line">				continue;</span><br><span class="line">			denominator *= fac(val);</span><br><span class="line">			sum += val;</span><br><span class="line">		&#125;</span><br><span class="line">		if(sum==0) &#123;</span><br><span class="line">			return sum;</span><br><span class="line">		&#125;</span><br><span class="line">		return fac(sum) / denominator;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="排列序号II"><a href="#排列序号II" class="headerlink" title="排列序号II"></a>排列序号II</h1><p>给出一个可能包含重复数字的排列，求这些数字的所有排列按字典序排序后该排列在其中的编号。编号从1开始。</p>
<p>样例<br>给出排列[1, 4, 2, 2]，其编号为3。</p>
<h1 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h1><p>这道题基于查找不存在重复元素中排列序号的基础之上，</p>
<p>即P(n) = P(n-1)+C(n-1)</p>
<p>C(n-1) = (首元素为小于当前元素，之后的全排列值)<br>P(1) = 1;</p>
<p>而不存在重复元素的全排列值C(n-1) = (n-1)!*k(k为首元素之后小于当前元素的个数)</p>
<p>在存在重复元素的排列中首先全排列的值的求法变为：</p>
<p>C(n-1) = (n-1)!/(A1!<em>A2!</em>···<em>Aj!)</em>k(其中Ai 为重复元素的个数，k为小于首元素前不重复的个数)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * @param A an integer array</span><br><span class="line">     * @return a long integer</span><br><span class="line">     */</span><br><span class="line">    long fac(int numerator) &#123;</span><br><span class="line">        long now = 1;</span><br><span class="line">        for (int i = 1; i &lt;= numerator; i++) &#123;</span><br><span class="line">            now *= (long) i;</span><br><span class="line">        &#125;</span><br><span class="line">        return now;</span><br><span class="line">    &#125;   </span><br><span class="line">    long generateNum(HashMap&lt;Integer, Integer&gt; hash) &#123;</span><br><span class="line">        long denominator = 1;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int val : hash.values()) &#123;</span><br><span class="line">            if(val == 0 )    </span><br><span class="line">                continue;       </span><br><span class="line">            denominator *= fac(val);</span><br><span class="line">            sum += val; </span><br><span class="line">        &#125;       </span><br><span class="line">        if(sum==0) &#123;</span><br><span class="line">            return sum; </span><br><span class="line">        &#125;       </span><br><span class="line">        return fac(sum) / denominator;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    public long permutationIndexII(int[] A) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hash = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; A.length; i++) &#123;</span><br><span class="line">            if (hash.containsKey(A[i]))</span><br><span class="line">                hash.put(A[i], hash.get(A[i]) + 1);</span><br><span class="line">            else &#123;      </span><br><span class="line">                hash.put(A[i], 1);</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;       </span><br><span class="line">        long ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; A.length; i++) &#123;</span><br><span class="line">            HashMap&lt;Integer, Integer&gt; flag = new HashMap&lt;Integer, Integer&gt;(); </span><br><span class="line"></span><br><span class="line">            for (int j = i + 1; j &lt; A.length; j++) &#123;</span><br><span class="line">                if (A[j] &lt; A[i] &amp;&amp; !flag.containsKey(A[j])) &#123;</span><br><span class="line">                    flag.put(A[j], 1);</span><br><span class="line">                    hash.put(A[j], hash.get(A[j])-1);</span><br><span class="line">                    ans += generateNum(hash);</span><br><span class="line">                    hash.put(A[j], hash.get(A[j])+1);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            hash.put(A[i], hash.get(A[i])-1);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans + 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 数据结构与算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之生成器模式（Builder_Pattern）]]></title>
      <url>/2017/03/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Builder-Pattern%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>生成器模式的核心是<strong>当构建生成一个对象的时候，需要包含多个步骤，虽然每个步骤具体的实现不同，但是都遵循一定的流程与规则</strong><br><a id="more"></a><br>举个例子，我们如果构建生成一台电脑，那么我们可能需要这么几个步骤</p>
<ul>
<li>需要一个主机</li>
<li>需要一个显示器</li>
<li>需要一个键盘</li>
<li>需要一个鼠标</li>
<li>需要音响等</li>
</ul>
</blockquote>
<p>虽然我们具体在构建一台主机的时候，每个对象的实际步骤是不一样的，比如，有的对象构建了i7cpu的主机，有的对象构建了i5cpu的主机，有的对象构建了普通键盘，有的对象构建了机械键盘等。<br>但不管怎样，你总是需要经过一个步骤就是构建一台主机，一台键盘。<br>对于这个例子，我们就可以使用生成器模式来生成一台电脑，他需要通过多个步骤来生成。</p>
<p>所以，我们可以将生成器模式理解为，假设我们有一个对象需要建立，这个对象是由多个组件（Component）组合而成，每个组件的建立都比较复杂，但运用组件来建立所需的对象非常简单，所以我们就可以将构建复杂组件的步骤与运用组件构建对象分离，使用builder模式可以建立。</p>
<p>生成器模式的类图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-dafed33b138cb013.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>下面我们就根据这个例子来实现一个生成器模式，生成一台电脑</p>
<p>首先我们需要一个电脑类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package Builder;</span><br><span class="line"></span><br><span class="line">public class Computer &#123;</span><br><span class="line">	public String master;</span><br><span class="line">	public String screen;</span><br><span class="line">	public String keyboard;</span><br><span class="line">	public String mouse;</span><br><span class="line">	public String audio;</span><br><span class="line">	public void setMaster(String master) &#123;</span><br><span class="line">		this.master = master;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setScreen(String screen) &#123;</span><br><span class="line">		this.screen = screen;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setKeyboard(String keyboard) &#123;</span><br><span class="line">		this.keyboard = keyboard;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setMouse(String mouse) &#123;</span><br><span class="line">		this.mouse = mouse;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setAudio(String audio) &#123;</span><br><span class="line">		this.audio = audio;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们建立一个抽象的builder类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package Builder;</span><br><span class="line"></span><br><span class="line">public abstract class ComputerBuilder &#123;</span><br><span class="line">	</span><br><span class="line">	protected Computer computer;</span><br><span class="line">	</span><br><span class="line">	public Computer getComputer() &#123;</span><br><span class="line">		return computer;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void buildComputer() &#123;</span><br><span class="line">		computer = new Computer();</span><br><span class="line">		System.out.println(&quot;生成了一台电脑！！！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public abstract void buildMaster();</span><br><span class="line">	public abstract void buildScreen();</span><br><span class="line">	public abstract void buildKeyboard();</span><br><span class="line">	public abstract void buildMouse();</span><br><span class="line">	public abstract void buildAudio();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们实现两个具体的builder类，分别是惠普电脑的builder和戴尔电脑的builder<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package Builder;</span><br><span class="line"></span><br><span class="line">public class HPComputerBuilder extends ComputerBuilder &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void buildMaster() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		computer.setMaster(&quot;i7,16g,512SSD,1060&quot;);</span><br><span class="line">		System.out.println(&quot;(i7,16g,512SSD,1060)的惠普主机&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void buildScreen() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		computer.setScreen(&quot;1080p&quot;);</span><br><span class="line">		System.out.println(&quot;(1080p)的惠普显示屏&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void buildKeyboard() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		computer.setKeyboard(&quot;cherry 青轴机械键盘&quot;);</span><br><span class="line">		System.out.println(&quot;(cherry 青轴机械键盘)的键盘&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void buildMouse() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		computer.setMouse(&quot;MI 鼠标&quot;);</span><br><span class="line">		System.out.println(&quot;(MI 鼠标)的鼠标&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void buildAudio() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		computer.setAudio(&quot;飞利浦 音响&quot;);</span><br><span class="line">		System.out.println(&quot;(飞利浦 音响)的音响&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package Builder;</span><br><span class="line"></span><br><span class="line">public class DELLComputerBuilder extends ComputerBuilder &#123;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void buildMaster() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		computer.setMaster(&quot;i7,32g,1TSSD,1060&quot;);</span><br><span class="line">		System.out.println(&quot;(i7,32g,1TSSD,1060)的戴尔主机&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void buildScreen() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		computer.setScreen(&quot;4k&quot;);</span><br><span class="line">		System.out.println(&quot;(4k)的dell显示屏&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void buildKeyboard() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		computer.setKeyboard(&quot;cherry 黑轴机械键盘&quot;);</span><br><span class="line">		System.out.println(&quot;(cherry 黑轴机械键盘)的键盘&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void buildMouse() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		computer.setMouse(&quot;MI 鼠标&quot;);</span><br><span class="line">		System.out.println(&quot;(MI 鼠标)的鼠标&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void buildAudio() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		computer.setAudio(&quot;飞利浦 音响&quot;);</span><br><span class="line">		System.out.println(&quot;(飞利浦 音响)的音响&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们实现一个director类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package Builder;</span><br><span class="line"></span><br><span class="line">public class Director &#123;</span><br><span class="line">	</span><br><span class="line">	private ComputerBuilder computerBuilder;</span><br><span class="line"></span><br><span class="line">	public void setComputerBuilder(ComputerBuilder computerBuilder) &#123;</span><br><span class="line">		this.computerBuilder = computerBuilder;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public Computer getComputer() &#123;</span><br><span class="line">		return computerBuilder.getComputer();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void constructComputer() &#123;</span><br><span class="line">		computerBuilder.buildComputer();</span><br><span class="line">		computerBuilder.buildMaster();</span><br><span class="line">		computerBuilder.buildScreen();</span><br><span class="line">		computerBuilder.buildKeyboard();</span><br><span class="line">		computerBuilder.buildMouse();</span><br><span class="line">		computerBuilder.buildAudio();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后我们测试一下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package Builder;</span><br><span class="line"></span><br><span class="line">public class ComputerCustomer &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		Director director = new Director();</span><br><span class="line">		</span><br><span class="line">		ComputerBuilder hp = new HPComputerBuilder();</span><br><span class="line">		</span><br><span class="line">		director.setComputerBuilder(hp);</span><br><span class="line">		</span><br><span class="line">		director.constructComputer();</span><br><span class="line">		</span><br><span class="line">		//get the pc</span><br><span class="line">		Computer pc = director.getComputer();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-f7b71a87b9f639e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h1 id="生成器模式的优缺点"><a href="#生成器模式的优缺点" class="headerlink" title="生成器模式的优缺点"></a>生成器模式的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>将一个对象分解为各个组件</li>
<li>将对象组件的构造封装起来</li>
<li>可以控制整个对象的生成过程</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>对不同类型的对象需要实现不同的具体构造器的类，这可能回答大大增加类的数量</p>
<h1 id="生成器模式的实际应用"><a href="#生成器模式的实际应用" class="headerlink" title="生成器模式的实际应用"></a>生成器模式的实际应用</h1><p>Builder pattern has been used in a lot of libraries. However, there is a common mistake here. Consider the following example of StringBuilder which is a class from Java standard library. Does it utilize the Builder pattern?</p>
<p>生成器模式在许多类库中都使用了。但是严格来说，却有些错误。<br>比如这个例子，我们考虑java标准库中的StringBuilder类，它使用了生成器模式么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder strBuilder= new StringBuilder();</span><br><span class="line">strBuilder.append(&quot;one&quot;);</span><br><span class="line">strBuilder.append(&quot;two&quot;);</span><br><span class="line">strBuilder.append(&quot;three&quot;);</span><br><span class="line">String str= strBuilder.toString();</span><br></pre></td></tr></table></figure>
<p>在标准库中，StringBuilder继承自AbstractStringBuilder<br>append方法是这个生成过程中的一步，就像我们构建电脑时，先构建主机这样的步骤一样。<br>toString方法也是生成过程中的一步，而且是构建过程中的最后一步。然而，这里的不同是没有director，所以严格来说这不是一个标准的生成器模式。我们程序的调用者好像就是director可以生成我们自己的String。</p>
<h1 id="生成器模式与工厂模式的不同"><a href="#生成器模式与工厂模式的不同" class="headerlink" title="生成器模式与工厂模式的不同"></a>生成器模式与工厂模式的不同</h1><p>生成器模式构建对象的时候，对象通常构建的过程中需要多个步骤，就像我们例子中的先有主机，再有显示屏，再有鼠标等等，生成器模式的作用就是将这些复杂的构建过程封装起来。<br>工厂模式构建对象的时候通常就只有一个步骤，调用一个工厂方法就可以生成一个对象。</p>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深度解析Java多线程的内存模型]]></title>
      <url>/2017/03/12/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li>内部java内存模型</li>
<li>硬件层面的内存模型</li>
<li>Java内存模型和硬件内存模型的联系</li>
<li>共享对象的可见性</li>
<li>资源竞速</li>
</ul>
</blockquote>
<p>Java内存模型很好的说明了JVM是如何在内存里工作的，JVM可以理解为java执行的一个操作系统，作为一个操作系统就有内存模型，这就是我们常说的JAVA内存模型。</p>
<p>如果我们想正确的写多线程的并行程序。理解好java内存模型在多线程下的工作方式是及其重要的，这可以帮我们更好的理解底层的工作方式。<br><a id="more"></a><br>java内存模型说明了不同的线程怎样以及何时可以看到其他线程写入共享变量的值，以及同步程序怎么共享变量。最初的java内存模型不够好，存在很多的不足，所以在java1.5z中，java内存模型的版本的进行了一次重大的更新与改进，并且在java8中仍然被使用。</p>
<h1 id="内部java内存模型"><a href="#内部java内存模型" class="headerlink" title="内部java内存模型"></a>内部java内存模型</h1><p>JVM的内部的内存模型分为了两部分，thread stack和heap，也就是线程栈和堆，我们将复杂的内存模型抽象成下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-0a8474641ef704d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>每一个在JVM中运行的线程在内存里都会有属于自己的线程栈。线程栈一般包含这个线程的方法执行到哪一个点了这些信息，也被称作“call stack”，当线程执行代码，调用栈就会随着执行的状态改变。</p>
<p>线程栈也包括了每个方法执行时的local 变量，所有的方法也都存储在线程栈上，一个线程可以只能访问自己的线程栈。每个线程自己创建的本地本地变量对其他线程是不可见的，也就是私有的，即使两个线程调用的是同一个方法，每个线程会分别保存一份本地变量，各自属于各自的线程栈。</p>
<p>所有基本类型的local变量（ boolean, byte, short, char, int, long, float, double）全都被存储在线程栈里，而且对其他线程是不可见的，一个线程可能会传递一份基本类型的变量值的一份拷贝给另一个线程，但是自己本身的变量是不能共享的，只能传递拷贝。</p>
<p>堆中存储着java程序中new出来的对象，不管是哪个线程new出来的对象，都存在一起，而且不区分是哪个线程的对象。这些对象里面也包括那些原始类型的对象版本(e.g. Byte, Integer, Long etc.). 不管这个对象是分配给本地变量还是成员变量，最终都是存在堆里。</p>
<p>下面这个图就说明了线程栈中存储了local变量，堆中存储着对象object。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-ea5d1f42c48880b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>一个原始数据类型的本地变量将完全被存储在线程栈中。</p>
<p>本地变量也可以是指向对象的引用，在这种情况下，本地变量存在线程栈上，但是对象本身是存在堆上。</p>
<p>一个对象可能包含方法这些方法同时也会包含本地变量，这些本地变量也是存储在线程栈上面，即使他们所属于的对象和方法是存在堆上的。</p>
<p>一个对象的成员变量是跟随着对象本身存储在堆上的，不管成员变量是原始数据类型还是指向对象的引用。</p>
<p>静态的类变量一般也存储在堆上，根据类的定义。</p>
<p>存储在堆上的对象可以被所有的线程通过引用来访问。当一个线程持有一个对象的引用时，他同时也就可以访问这个对象的成员变量了。如果两个线程同时调用同一个对象的一个方法，他们就会都拥有这个对象的成员变量，但是每一个线程会享有自己私有的本地变量。</p>
<p>下面这张图就说明以上的内容</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-8be0905d91a01264.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>两个线程有一系列的本地变量。其中一个本地变量(Local Variable 2)指向堆中的object3.这两个线程每个都有指向同一个对象object3的不同引用。他们的引用是本地变量，都存在各自的线程栈中，虽然这两个不同的引用是指向同一个对象的。</p>
<p>我们还可以发现，共有的对象object3有指向object2和object4的引用，这些引用是作为object3中的成员变量存在的。通过object3中的成员变量的引用，两个线程都可以访问到object2和object4.</p>
<p>这个图也说明了指向堆中不同对象的本地变量。例如图中的object1和object5，不是同一个对象。理论上，所有的线程都可以访问堆中的对象，只要这个线程持有堆中对象的引用。但是这个图中，每个线程只有这两个对象中的一个引用。</p>
<p>下面，我们将写一段实际的代码，这段代码的内存模型就跟上图一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        methodOne();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void methodOne() &#123;</span><br><span class="line">        int localVariable1 = 45;</span><br><span class="line"></span><br><span class="line">        MySharedObject localVariable2 =</span><br><span class="line">            MySharedObject.sharedInstance;</span><br><span class="line"></span><br><span class="line">        //... do more with local variables.</span><br><span class="line"></span><br><span class="line">        methodTwo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void methodTwo() &#123;</span><br><span class="line">        Integer localVariable1 = new Integer(99);</span><br><span class="line"></span><br><span class="line">        //... do more with local variable.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MySharedObject &#123;</span><br><span class="line"></span><br><span class="line">    //static variable pointing to instance of MySharedObject</span><br><span class="line"></span><br><span class="line">    public static final MySharedObject sharedInstance =</span><br><span class="line">        new MySharedObject();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //member variables pointing to two objects on the heap</span><br><span class="line"></span><br><span class="line">    public Integer object2 = new Integer(22);</span><br><span class="line">    public Integer object4 = new Integer(44);</span><br><span class="line"></span><br><span class="line">    public long member1 = 12345;</span><br><span class="line">    public long member1 = 67890;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果两个线程执行run方法那么，上图的内存模型就会是这段程序的执行结果。</p>
<p>methodOne()声明了一个原始数据类型的本地变量，int类型的localVariable1 ，和一个指向对象的引用的本地变量(localVariable2).</p>
<p>每个线程执行methodOne()的时候都会创建属于自己的一份本地变量的拷贝，也就是<br> localVariable1 and localVariable2在他们各自的线程栈的空间中。localVariable1将会被完全对其他线程是不可见的，只存在与每个线程自己的线程栈空间中。一个线程不能看到其他线程对localVariable1所做的改变与操作，是不可见的。</p>
<p>每个线程执行methodOne()方法的时候也会创建localVariable2的拷贝，但是不同的localVariable2的拷贝最终却指向同一个堆上的对象。这段代码让localVariable2指向之前通过一个静态变量引用的对象。静态变量只会存在一份，不会有多余的拷贝，而且静态变量是存在堆中的。所以，localVariable2的两份拷贝同时指向同一个MySharedObject对象的实例，与此同时，还有一个堆中的静态变量也指向这个对象实例。这个对象就是对应上图中的object3. </p>
<p>我们发现MySharedObject 包含这两个成员变量。这些成员变量跟对象一样存储在堆上。这两个成员变量指向两个integer对象。这两个对象分别对应上图中的object2和object4.</p>
<p>我们发现，methodTwo() 创建了一个本地变量叫做localVariable1。这个本地变量是一个对象的引用，他指向一个integer对象。这个方法将本地变量localVariable1指向一个新的值。在执行methodTwo()的时候，每个线程都会持有一份localVariable1的拷贝。这两个Integer对象将会被初始化在堆上，但是因为每次执行这个方法的时候，这个方法都会创建一个新的对象，所以两个线程会拥有独立的对象实例。这两个对象就对应上图中的object1和object5.</p>
<p>我们发现MySharedObject 中的成员变量是原始数据类型，但由于他们是成员变量，所以依旧存储在堆上。只有本地变量存储在线程栈中。</p>
<h1 id="硬件层面的内存模型"><a href="#硬件层面的内存模型" class="headerlink" title="硬件层面的内存模型"></a>硬件层面的内存模型</h1><p>硬件层面的内存内存结构与JVM中的内存结构是有不同的，对我们来说，正确理解掌握硬件层面的内存模型是很必要的，这可以帮助我们理解java多线程的底层机制，更要了解java内存模型如何在硬件内存结构上工作。这一章将讲述硬件层面内存模型，下一部分将讲述java如何结合硬件工作。</p>
<p>下图是一个简化的现代计算机硬件结构图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-65520363c97a56e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>现代计算机通常会有两个甚至更多的cpu，这些cpu可能还会有多个核心，这个意义是，拥有多个cpu的计算机可能会有多个线程在同时执行，每个cpu都可以在任何给定的时间运行一个线程。这就意味着如果我们的java程序是多线程的，在内部就每个线程就会有一个cpu在同时执行。</p>
<p>每个cpu都会有一系列的寄存器registers在cpu的内存中，而且这些寄存器是很重要的。cpu在寄存器上进行计算操作比在主内存中进行计算要快的多。这是因为cpu访问寄存器的速度比访问内存要快得多。</p>
<p>每个cpu也会有一个cpu的cache内存。这是因为cpu访问cache比访问内存的速度要快得多，但是却比访问的寄存器要慢一些，所以cache的速度是介于寄存器和内存的。一些cpu还有多级cache，比如(Level 1 and Level 2)，但是这对于我们理解java内存模型关系不大，我们只需要cpu有三层内存结构，寄存器-cache-内存（RAM）.</p>
<p>一台计算机一般都会有主内存也就是RAM,所有cpu都可以访问主内存，主内存的容量一般远比cache大得多。</p>
<p>一般的，当cpu需要访问内存的时候，他会先读取一部分主内存到cache中，甚至，会读取一部分cache到内部的寄存器中，然后再在寄存器进行计算操作。当cpu将计算结果写回内存中时，他会flush寄存器和cache中的数据，然后将值写回至内存中。</p>
<p>当cpu要求cache去存储其他内容时，也会将cache中的内容flush到内存中。cpu的cache可以边写入一部分数据到内存，边写入一部分到自己cache中，所以在更新数据，不必要全部清空cache，可以边读边写。一般的，cache真正更新数据是在更小的内存块上，叫做“cache lines”。多个“cache lines”可能正在读取数据到cache中，而另一部分可能正在将数据写回到内存中。</p>
<h1 id="Java内存模型和硬件内存模型的联系"><a href="#Java内存模型和硬件内存模型的联系" class="headerlink" title="Java内存模型和硬件内存模型的联系"></a>Java内存模型和硬件内存模型的联系</h1><p>上文已经提到，java内存模型和硬件内存模型是不同的。硬件内存模型不区分堆和栈。在硬件层面，所有的线程栈和堆都被存储在主内存中，一部分线程栈和堆可能有时候会出现在cpu cache中和cpu寄存器中。下图可以说明这个问题：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-6a9e26f10ccaa42e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>当对象和变量被存储在不同的内存区域的时候，很多问题就可能发生，主要有以下两类问题：</p>
<ul>
<li>当线程对一些共享数据进行更新或者写操作时，可见性的问题</li>
<li>当读写共享数据产生资源竞速的问题<br>接下来的部分就会讨论这两个问题</li>
</ul>
<h2 id="共享对象的可见性"><a href="#共享对象的可见性" class="headerlink" title="共享对象的可见性"></a>共享对象的可见性</h2><p>如果多个线程在共享一个对象，没有正确使用volatile或者synchronize声明，更新共享对象的时候就可能出现其他线程不可见的问题。</p>
<p>我们假设共享对象初始化主内存中。一个在cpu中运行的线程读取共享对象到cache中。这时候，随着程序的执行，可能导致共享对象发生一些变化。只要cpu的cache还没有被写回到主内存中，这个共享对象的变化就对其他在cpu上运行的线程不可见。这种情况下，每个线程都会有持有一份自己对于共享对象的拷贝，这份拷贝存储在各自的cpu的cache中，而且对于其他线程是不可见的。</p>
<p>下图说明了大致的情况，在左边cpu执行的线程将共享对象读取到cache中，并且将他的值改变为2.这个变化对右边的cpu的其他线程是不可见的，因为对于变量count的更新还没有被写回到主内存中。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-9f992a05d55d5ccf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>想要解决这个共享对象可见性的问题，可以使用java的volatile关键字（参见笔者的另一篇volatile的博文），这个关键字可以保证所给定的变量都是直接从主内存中读取，而且每当更新时就立即写回到内存中，所以可以保证变化是及时可见的。</p>
<h2 id="资源竞速"><a href="#资源竞速" class="headerlink" title="资源竞速"></a>资源竞速</h2><p>如果多个线程共享一个对象，而且多个线程需要更新共享对象中的变量，那么就可能造成资源竞速的发生。</p>
<p>假设线程A读取读取一个共享对象的变量count到cpu的cache中，同时，线程B也执行同样的步骤，但是是读取到一个不同的CPU的cache中，现在线程A给count加一，线程B也做同样的事情，现在这个变量被加了两次，分别在不同的cpu的cache中。</p>
<p>如果这两次递增操作是被按顺序先后执行的，这个变量count就会被加两次而且比最初的值加了2，写回到主内存中。</p>
<p>然而，如果这两个递增操作是并发执行的，且没有正确的进行同步操作，写回内存的时候，更新后的值只会被加一，虽然实际上是进行了两次递增操作。<br>下图就说明了程序并发执行的时候，产生的资源竞速的问题：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-db30344a33ca84dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>想要解决这个问题，我们可以使用java中的synchronize关键字。synchronize可以保证只有一个线程能进入那些被声明为synchronize的代码段中。同步的线程可以保证所有同步代码段中的变量都会从内存中读取，而且当线程离开代码块的时候，所有更新后的值都会被写回主内存中，不管这个变量有没有被声明volatile。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文详细的剖析了java内存模型和硬件层面的内存模型，并且分析了硬件和java是怎么在内存模型上合作联系的。这对于我们接下来理解java多线程的概念是及其重要的，打下了牢固的基础。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java动态代理与静态代理]]></title>
      <url>/2017/03/04/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<p>我们先看一个简单的例子，当我们需要程序中加入方法执行的日志信息的时候，很显然我们最容易想到的实现方法，就是在方法前后插入日志记录信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.logging.*;</span><br><span class="line"></span><br><span class="line">public class HelloSpeaker &#123;</span><br><span class="line">    private Logger logger = </span><br><span class="line">            Logger.getLogger(this.getClass().getName()); </span><br><span class="line"></span><br><span class="line">    public void hello(String name) &#123; </span><br><span class="line">        // 方法執行開始時留下日誌</span><br><span class="line">        logger.log(Level.INFO, &quot;hello method starts....&quot;); </span><br><span class="line">        // 程式主要功能</span><br><span class="line">        System.out.println(&quot;Hello, &quot; + name); </span><br><span class="line">        // 方法執行完畢前留下日誌</span><br><span class="line">        logger.log(Level.INFO, &quot;hello method ends....&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后这种实现方式有明显的不足，这种切入式的代码（Cross-cutting），会使得HelloSpeaker拥有了本该不属于他的职责，要在hello的同时记录日志。</p>
<p>试想一下，如果程序中的代码到处都是这种日志需求，那么我们的就必须在到处都加上这些日志代码，想必那是很大的工作量，而且当我们需要修改密码的时候，将会变得更加复杂，维护起来变得困难，所以我们自然想到封装，由于很多对象都需要日志记录这种需求，我们何不把日志行为分离出来。</p>
<p>这时候就可以代理模式解决这个问题，代理又分为<strong>静态代理（Static proxy）</strong>和<strong>动态代理（Dynamic proxy）</strong><br><a id="more"></a></p>
<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>在静态代理模式中，代理与被代理对象必须实现同一个接口，代理专注于实现日志记录需求，并在合适的时候，调用被代理对象，这样被代理对象就可以专注于执行业务逻辑。</p>
<p>改进上面那个例子<br>首先定义一个接口</p>
<ul>
<li>IHello.java</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package Reflection;</span><br><span class="line"></span><br><span class="line">public interface IHello &#123;</span><br><span class="line">	public void hello(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后专注于业务逻辑实现HelloSpeaker实现上面这个接口：</p>
<ul>
<li>HelloSpeaker.java</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package Reflection;</span><br><span class="line"></span><br><span class="line">public class HelloSpeaker implements IHello &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void hello(String name) &#123;</span><br><span class="line">		System.out.println(&quot;Hello, &quot; + name);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在这个类中没有日志记录的代码，其只需要专注于实现业务功能，而记录日志的工作则可以交给代理对象来实现，代理对象也要实现Ihello接口：</p>
<ul>
<li>HelloProxy.java</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package Reflection;</span><br><span class="line"></span><br><span class="line">import java.util.logging.*; </span><br><span class="line"></span><br><span class="line">public class HelloProxy implements IHello &#123; </span><br><span class="line">    private Logger logger = </span><br><span class="line">            Logger.getLogger(this.getClass().getName());</span><br><span class="line">    </span><br><span class="line">    private IHello helloObject; </span><br><span class="line"></span><br><span class="line">    public HelloProxy(IHello helloObject) &#123; </span><br><span class="line">        this.helloObject = helloObject; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    public void hello(String name) &#123; </span><br><span class="line">        // 日誌服務</span><br><span class="line">        log(&quot;hello method starts....&quot;);      </span><br><span class="line"></span><br><span class="line">        // 執行商務邏輯</span><br><span class="line">        helloObject.hello(name);</span><br><span class="line">        </span><br><span class="line">        // 日誌服務</span><br><span class="line">        log(&quot;hello method ends....&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    private void log(String msg) &#123;</span><br><span class="line">        logger.log(Level.INFO, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到在hello方法的实现中，前后插入了日志记录的方法。<br>下面我们就测试一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IHello proxy = </span><br><span class="line">            new HelloProxy(new HelloSpeaker());</span><br><span class="line">        proxy.hello(&quot;Justin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-465809cb3d7e72f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>程序中执行hello方法的是代理对象，实例化代理对象的时候，必须传入被代理对象，而且声明代理对象的时候，必须使用代理对象和被代理对象共同实现的接口，以便实现多态。</p>
<p>代理对象将代理真正执行hello方法的被代理对象来执行hello,并在执行的前后加入日志记录的操作这样就可以使业务代码专注于业务实现。</p>
<p>这就是静态代理</p>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>jdk1.3加入了动态代理相关的API，从上面静态代理的例子我们知道，静态代理，需要为被代理对象和方法实现撰写特定的代理对象，显然这样做并不灵活，我们希望可以有一个公用的代理，可以动态的实现对不同对象的代理，这就需要利用到反射机制和动态代理机制。<br>在动态代理中，一个handler可以代理服务各种对象，首先，每一个handler都必须继承实现java.lang.reflect.InvocationHandler接口，下面具体实例说明，依然是上面那个记录日志的例子</p>
<ul>
<li>LogHandler.java</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package Reflection;</span><br><span class="line"></span><br><span class="line">import java.util.logging.*; </span><br><span class="line">import java.lang.reflect.*; </span><br><span class="line"></span><br><span class="line">public class LogHandler implements InvocationHandler &#123; </span><br><span class="line">    private Logger logger = </span><br><span class="line">            Logger.getLogger(this.getClass().getName()); </span><br><span class="line">    </span><br><span class="line">    private Object delegate;</span><br><span class="line"></span><br><span class="line">    public Object bind(Object delegate) &#123; </span><br><span class="line">        this.delegate = delegate; </span><br><span class="line">        return Proxy.newProxyInstance( </span><br><span class="line">                           delegate.getClass().getClassLoader(), </span><br><span class="line">                           delegate.getClass().getInterfaces(), </span><br><span class="line">                           this); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    public Object invoke(Object proxy, Method method, </span><br><span class="line">                         Object[] args) throws Throwable &#123; </span><br><span class="line">        Object result = null; </span><br><span class="line">        </span><br><span class="line">        try &#123; </span><br><span class="line">            log(&quot;method starts...&quot; + method);</span><br><span class="line">            </span><br><span class="line">            result = method.invoke(delegate, args);</span><br><span class="line">            </span><br><span class="line">            logger.log(Level.INFO, &quot;method ends...&quot; + method); </span><br><span class="line">        &#125; catch (Exception e)&#123; </span><br><span class="line">            log(e.toString()); </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return result; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    private void log(String message) &#123;</span><br><span class="line">        logger.log(Level.INFO, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体来说就是使用Proxy.newProxyInstance()静态方法new一个代理对象出来，底层会使用反射机制，建立代理对象的时候，需要传入被代理对象的class，以及被代理对象的所实现的接口，以及代理方法调用的调用程序 InvocationHandler，即实现 InvocationHandler接口的对象。这个对象会返回一个指定类指定接口，指定 InvocationHandler的代理类实例，这个实例执行方法时，每次都会调用 InvocationHandler的invoke方法，invoke方法会传入被代理对象的方法与方法参数，实际方法的执行会交给method.invoke().所以我们就可以在其前后加上日志记录的工作。</p>
<p>接下来我们就来测试一下，使用logHandler的bind方法来绑定代理对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package Reflection;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class ProxyDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">	        </span><br><span class="line">	        LogHandler logHandler  = new LogHandler(); </span><br><span class="line">	        </span><br><span class="line">	        IHello helloProxy = </span><br><span class="line">	                (IHello) logHandler.bind(new HelloSpeaker()); </span><br><span class="line">	        helloProxy.hello(&quot;baba&quot;);</span><br><span class="line">	        		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解javascript中的原型]]></title>
      <url>/2017/01/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>原型prototype是javascript中极其重要的概念之一，但也是比较容易引起混淆的地方。我们需要花费一些时间和精力好好理解原型的概念，这对于我们学习javascript是必须的。<br><a id="more"></a></p>
<hr>
<h1 id="原型的概念"><a href="#原型的概念" class="headerlink" title="原型的概念"></a>原型的概念</h1><p>真正理解什么是原型是学习原型理论的关键。很多人在此产生了混淆，没有真正理解，自然后续疑惑更多。</p>
<p>首先，我们明确原型是一个对象，其次，最重要的是，<br><strong> Every function has a prototype property and it contains an object </strong><br>这句话就是说，每个函数都有一个属性叫做原型，这个属性指向一个对象。<br>也就是说，原型是函数对象的属性，不是所有对象的属性，对象经过构造函数new出来，那么这个new出来的对象的构造函数有一个属性叫原型。明确这一点很重要。</p>
<p><strong> The prototype property is a property that is available to you as soon as you define the function. Its initial value is an “empty” object.
 </strong><br>每次你定义一个函数的时候，这个函数的原型属性也就被定义出来了，也就可以使用了，如果不对它进行显示赋值的话，那么它的初始值就是一个空的对象Object。<br>所以，综上我们知道我们讨论原型的时候，都是基于函数的，有了一个函数对象，就有了原型。切记这一点，讨论原型，不能脱离了函数，它是原型真正归属的地方，<strong> 原型只是函数的一个属性 </strong>！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo(a,b) &#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line">foo.prototype</span><br><span class="line">foo.constructor</span><br></pre></td></tr></table></figure>
<p>chrome控制台测试结果</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-96cea924e2c6dc06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>我们可以看到函数foo的原型是空对象Object，所有函数的构造函数都是Function。</p>
<hr>
<h1 id="使用原型给对象添加方法和属性"><a href="#使用原型给对象添加方法和属性" class="headerlink" title="使用原型给对象添加方法和属性"></a>使用原型给对象添加方法和属性</h1><p>不使用原型，使用构造函数给对象添加属性和方法的是通过this，像下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Gadget(name, color) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.color = color;</span><br><span class="line">    this.whatAreYou = function() &#123;</span><br><span class="line">        return &apos;I am &apos; + this.color + &apos;  &apos; + this.name; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Gadget是一个构造函数，作为一个函数，它有一个属性，这个属性是原型，它指向一个对象，目前我们没有设置这个属性，所以它是一个空的对象。<br><strong> Adding methods and properties to the prototype property of the constructor<br>function is another way to add functionality to the objects this constructor produces </strong><br>当我们有了原型之后，我们可以给构造函数的原型对象添加属性和方法来。<br>像下面这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Gadget.prototype.price = 100;</span><br><span class="line">Gadget.prototype.rating = 3;</span><br><span class="line">Gadget.prototype.getInfo = function() &#123;</span><br><span class="line">    return &apos;Rating: &apos; + this.rating +&apos;, price: &apos; + this.price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>给原型添加了属性和方法后，原型所指的对象也会更新</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-9363a11910f64fc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h1 id="使用原型对象的属性和方法"><a href="#使用原型对象的属性和方法" class="headerlink" title="使用原型对象的属性和方法"></a>使用原型对象的属性和方法</h1><p>我们使用原型的对象和方法不会在直接在构造函数上使用，而是通过构造函数new出一个对象，那么new出来的对象就会有构造函数原型里的属性和方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-471038db652d523e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>这里很容易造成误解，我们需要强调newtoy这个new出来的对象是没有原型的，原型只是函数对象的一个属性，newtoy是通过构造函数new出来的对象，所以他不是函数对象，也没有prototype属性，我们在chrome的控制台里自然也无法访问他的prototype属性。<br>但我们可以通过构造函数访问。<br>我们知道每个对象都有constructor属性，newtoy的constructor属性就指向Gadget，那么我们通过constructor可以访问到prototype。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-35443c4508a02382.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>到这里，我们对为什么要通过constructor.protptype访问属性应该清楚了。（笔者第一次接触原型就没看懂这个），切记，原型是函数对象的属性，只有函数对象才有原型就容易理解了。</p>
<h2 id="原型的实时性"><a href="#原型的实时性" class="headerlink" title="原型的实时性"></a>原型的实时性</h2><p>这里特别需要提出，原型是实时的，意思就是原型对象的属性和方法会实时更新。其实很好理解，javascript中对象是通过引用传递的，原型对象只有一份，不是new出一个对象就复制一份，所以我们对原型的操作和更新，会影响到所有的对象。这就是原型对象的实时性。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-c9ad1967b9af0b84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h2 id="自身属性与原型属性"><a href="#自身属性与原型属性" class="headerlink" title="自身属性与原型属性"></a>自身属性与原型属性</h2><p>这里涉及到javascript是如何搜索属性和方法的，javascript会先在对象的自身属性里寻找，如果找到了就输出，如果在自身属性里没有找到，那么接着到构造函数的原型属性里去找，如果找到了就输出，如果没找到，就null。<br>所以，如果碰到了自身属性和原型属性里有同名属性，那么根据javascript寻找属性的过程，显然，如果我们直接访问的话，会得到自身属性里面的值。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-7e542ecd0c5f5255.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>我们加下来做一个小实验，寻找toString方法是谁的属性，一步步寻找</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-63dee589a984a269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>通过实验我们可以发现，原来toString方法是object的原型对象的方法。</p>
<h2 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf()"></a>isPrototypeOf()</h2><p>Object的原型里还有这样一个方法isPrototypeOf(),这个方法可以返回一个特定的对象是不是另一个对象的原型，实际这里不准确，因为我们知道只有函数对象有原型属性，普通对象通过构造函数new出来，自动继承了构造的函数原型的属性方法。但这个方法是可以直接判断，而不需要先取出constructor对象再访问prototype。看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Human(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var monkey = &#123;</span><br><span class="line">    hair:true,</span><br><span class="line">    feeds:&apos;banana&apos;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Human.prototype = monkey;</span><br><span class="line"></span><br><span class="line">var chi = new Human(&apos;chi&apos;);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-8c2f9944b429c645.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>我们知道chi这个对象是没有原型属性的，它有的是他的构造函数的原型属性monkey。但isPrototypeOf直接判断，实际上是省略了获取构造函数的过程，搞清楚这里面的区别。<br>object还有一个getPrototypeOf方法，基本用法和isPrototype一样，参考下面的代码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-09c3025f68fe706c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h2 id="神秘的proto链接"><a href="#神秘的proto链接" class="headerlink" title="神秘的proto链接"></a>神秘的proto链接</h2><p>我们之前访问对象的原型，都要先取得构造函数然后访问prototype<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chi.constructor.prototype;</span><br><span class="line">newtoy.constructor.prototype;</span><br></pre></td></tr></table></figure></p>
<p>这样是不是特别别扭，所以各个浏览器一般都会给出一个<strong>proto</strong>属性，前后分别有双下划线，对象的这个属性可以直接访问到构造函数的原型。这就很方便了。所以proto与prototype是有很大区别的。区别就在此。proto是实例对象用来直接访问构造函数的属性，prototype是函数对象的原型属性。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-557dc27db5ec5c65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chi.constructor.prototype == chi.__proto__</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-6ad7fe6d04547f3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>显然现在已经很容易弄清楚了proto和prototype的区别了。</p>
<h1 id="原型的陷阱"><a href="#原型的陷阱" class="headerlink" title="原型的陷阱"></a>原型的陷阱</h1><p>原型在使用的时候有一个陷阱：<br><strong> 在我们完全替换掉原型对象的时候，原型会失去实时性，同时原型的构造函数属性不可靠，不是理论上应该的值。</strong><br>这个陷进说的是什么呢？好像不太明白<br>举个例子我们就懂了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Dog() &#123;</span><br><span class="line">    this.tail = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var benji = new Dog();</span><br><span class="line">var rusty = new Dog();</span><br><span class="line"></span><br><span class="line">Dog.prototype.say = function () &#123;</span><br><span class="line">    return &apos;Woof!&apos;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们进行测试：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-d9ebb0075e1d14ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>直到这里一切都是正常的<br>接下来我们将原型对象整个替换掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dog.prototype = &#123;</span><br><span class="line">    paws: 4,</span><br><span class="line">    hair: true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-e538ed4fd7f2ab70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>通过测试我们发现，我们没法访问刚刚更新的原型对象，却能访问之前的原型对象，这说明没有实现实时性。</p>
<p>我们继续测试</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-6c0086739f3a57a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>我们发现这时新建的对象可以访问更新后的原型，但是构造方法又不对了，本来constructor属性应该指向dog，结果却指向了Object。这就是javascript中的原型陷阱。</p>
<p>我们很容易解决这个问题，只要在更新原型对象后面，重新指定构造函数即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dog.prototype.constructor = Dog;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-5be6521e397938b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>这样所有就按正常的运行了</p>
<p><strong> 所以我们切记在替换掉原型对象之后，切记重新设置constructor.prototype </strong></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>我们大概介绍了原型中容易混淆的问题，主要有以下几方面:</p>
<ul>
<li>所有函数都有一个属性prototype，这就是我们指的原型，他的初始值是一个空的对象</li>
<li>你可以原型对象添加属性和方法，甚至直接用另一个对象替换他</li>
<li>当你用构造函数new出一个对象之后，这个对象可以访问构造函数的原型对象的属性和方法</li>
<li>对象的自身属性搜索的优先级比原型的属性要高</li>
<li>proto属性的神秘连接及其同prototype的区别</li>
<li>prototype使用中的陷阱</li>
</ul>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之装饰者模式Decorator_Pattern]]></title>
      <url>/2016/07/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8FDecorator-Pattern/</url>
      <content type="html"><![CDATA[<p>装饰者模式可以做到在不修改任何底层代码的情况下，给对象增加的新的方法。<br>首先，我们通过对一个现实问题的模拟分析，了解什么是装饰者模式以及装饰者模式的作用。<br><a id="more"></a></p>
<hr>
<h1 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h1><p>咖啡店在街头随处可见。我们以咖啡店的饮品订单系统为例。假设我们要设计一个饮品的订单系统。<br>设计了一个这样的类图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-b86a8cb8871ffbe4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>Beverage是一个 抽象类，所有咖啡店的饮品都必须继承这个类，description是饮品的描述信息，cost()是计算此种饮品的价格。</p>
<p>我们会遇到这样的问题，在购买饮品的时候，我们可以要求在其中加入不同的调料配品，比如，摩卡（Mocha），加奶泡等。除了原本饮料需要的价格的外，咖啡店会根据所加入调料的再收取不同的费用。</p>
<p>如果按照之前的设计方式，那么会出现如下的情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-26ab46c99870ff46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><strong> 显然这似乎已经是类爆炸了！</strong></p>
<p>而且我们永远无法预测，顾客会选取怎样的调料的搭配，每当出现一个新的调料搭配时，我们就需要增加一个新的类。<br>更加糟糕的是，当原料配料的价格上涨后或者下降后，那么所有涉及到这种配料的类都得重新改过。这简直是个噩梦！很显然这很不符合我们设计模式的原则。作为一个程序员，我们是决不能容忍这种情况发生的！</p>
<p>那么我们该如何设计呢？</p>
<p><strong>这里就需要用到我们的装饰者模式！</strong></p>
<h1 id="引出装饰者模式"><a href="#引出装饰者模式" class="headerlink" title="引出装饰者模式"></a>引出装饰者模式</h1><p>让我们转换思路，我们以饮品beverage为主体，在运行时以顾客选择的调料来<strong>装饰</strong>beverage。比如，如果顾客想要摩卡和奶泡的拿铁咖啡，我们要做的应该是这样的：</p>
<ul>
<li>取一个拿铁咖啡的对象</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-dbdc69711c7e4c65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>用摩卡对象装饰它</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-3673c6434f60f99c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>用奶泡对象装饰它</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-e8dd1f6724cfa4e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>调用cost方法计算价钱，并依赖委托将配料摩卡和奶泡加上去。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-871ac8034baac451.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>会先计算whip的cost然后调用mocha的cost，然后调用拿铁的cost，这样就计算出了总价格。<br>这样就是实现的装饰者模式解决这个问题的思路。<br>下面我们看一下装饰者模式的定义，以及代码实现的基本思路</p>
<h1 id="定义装饰者模式"><a href="#定义装饰者模式" class="headerlink" title="定义装饰者模式"></a>定义装饰者模式</h1><p><strong>装饰者模式动态的将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-d9a55b87f80f8867.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>这个类图就是装饰者模式的实现方式。更详细的是如下这个版本的类图。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-fe6ef694b2c9958e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>下面我们就根据这个类图来解决我们之前在实现咖啡店饮料系统上遇到的问题。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-5a2e1096f6623de2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>分析设计类图：</p>
<ul>
<li>beverage相当于抽象的component类，具体的component和decorator都需要继承实现这个抽象类。</li>
<li>四个具体的饮料的类，相当于concrete component！每一个类代表了一个饮料类型。</li>
<li>condimentDecorator是抽象的decorator类，它是所有调料类的抽象，它保存了beverage的一个引用。</li>
<li>调料装饰者类继承自condimentDecorator，是各种具体调料的实现，他们都实现了cost方法。</li>
</ul>
<p>上面有一个非常关键的地方，就是我们注意到装饰者和被装饰者必须是一样的类型，也就是拥有共同的超类。这样做是因为我们要装饰者必须能取代被装饰者。<br>这样我们就可以利用对象的组合，将调料和饮料的行为组合起来。这符合我们之前提到的设计原则<strong>多用组合，少用继承</strong></p>
<h1 id="实现装饰者模式"><a href="#实现装饰者模式" class="headerlink" title="实现装饰者模式"></a>实现装饰者模式</h1><p>如果看到这里还是不太清楚，也没关系，接下来我们将具体实现代码，对装饰者模式有一个直观根本的了解。</p>
<ul>
<li>首先实现beverage和condiment两个抽象类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstractComponent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> String description = <span class="string">"Unknow Beverage"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> description;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstractDecrator;</span><br><span class="line"><span class="keyword">import</span> abstractComponent.Beverage;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CondimentDecorator</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后我们实现具体的饮料类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concreteComponent;</span><br><span class="line"><span class="keyword">import</span> abstractComponent.Beverage;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coco</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Coco</span><span class="params">()</span></span>&#123;</span><br><span class="line">		description = <span class="string">"Coco"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0.89</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package concreteComponent;</span><br><span class="line">import abstractComponent.Beverage;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Espresso extends Beverage &#123;</span><br><span class="line">	public Espresso() &#123;</span><br><span class="line">		description = &quot;Espresso&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public double cost() &#123;</span><br><span class="line">		return 1.99;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们再实现具体的装饰者类，也就是调料类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concreteDecorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> abstractComponent.Beverage;</span><br><span class="line"><span class="keyword">import</span> abstractDecrator.CondimentDecorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	Beverage beverage;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Mocha</span><span class="params">(Beverage beverage)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> .<span class="number">20</span> + beverage.cost();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> beverage.getDescription() + <span class="string">", Mocha"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concreteDecorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> abstractComponent.Beverage;</span><br><span class="line"><span class="keyword">import</span> abstractDecrator.CondimentDecorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soy</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	Beverage beverage;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Soy</span><span class="params">(Beverage beverage)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> beverage.getDescription() + <span class="string">", Soy"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> .<span class="number">15</span> + beverage.cost();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concreteDecorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> abstractComponent.Beverage;</span><br><span class="line"><span class="keyword">import</span> abstractDecrator.CondimentDecorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Whip</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	Beverage beverage;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Whip</span><span class="params">(Beverage beverage)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> beverage.getDescription() + <span class="string">" , whip"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> .<span class="number">10</span> + beverage.cost();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后编写一个测试类，来测试我们装饰者模式的效果如何</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concreteComponent.Coco;</span><br><span class="line"><span class="keyword">import</span> concreteComponent.Espresso;</span><br><span class="line"><span class="keyword">import</span> concreteDecorator.Mocha;</span><br><span class="line"><span class="keyword">import</span> concreteDecorator.Soy;</span><br><span class="line"><span class="keyword">import</span> concreteDecorator.Whip;</span><br><span class="line"><span class="keyword">import</span> abstractComponent.Beverage;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Beverage beverage = <span class="keyword">new</span> Espresso();</span><br><span class="line">		System.out.println( beverage.getDescription() + <span class="string">"$"</span> + beverage.cost());</span><br><span class="line">		</span><br><span class="line">		Beverage beverage2 = <span class="keyword">new</span> Coco();</span><br><span class="line">		beverage2 = <span class="keyword">new</span> Mocha(beverage2);</span><br><span class="line">		beverage2 = <span class="keyword">new</span> Mocha(beverage2);</span><br><span class="line">		beverage2 = <span class="keyword">new</span> Whip(beverage2);</span><br><span class="line">		System.out.println( beverage2.getDescription() + <span class="string">"$"</span> + beverage2.cost());</span><br><span class="line">		</span><br><span class="line">		Beverage beverage3 = <span class="keyword">new</span> Espresso();</span><br><span class="line">		beverage3 = <span class="keyword">new</span> Whip(beverage3);</span><br><span class="line">		beverage3 = <span class="keyword">new</span> Mocha(beverage3);</span><br><span class="line">		beverage3 = <span class="keyword">new</span> Soy(beverage3);</span><br><span class="line">		System.out.println( beverage3.getDescription() + <span class="string">"$"</span> + beverage3.cost());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结与分析"><a href="#总结与分析" class="headerlink" title="总结与分析"></a>总结与分析</h1><p>通过装饰者模式我们可以很好的解决咖啡店的问题，用装饰者去包装组件，可以达到很好的可扩展性。</p>
<ul>
<li>装饰者模式用到的技术主要有两种就是组合和委托，这帮助我们动态的在运行时加上新的行为。</li>
<li>装饰者模式意味着一群装饰者类，这些类用来包装装饰者。</li>
<li>装饰者和被装饰者类实际上具有相同类型的。</li>
<li>装饰者可以在被装饰者的行为前面或后面加上自己的行为，甚至完全覆盖。</li>
<li>但装饰者模式的使用会导致出现很多小对象，就是装饰者对象，过度使用也会使程序变得复杂。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之观察者模式（Observer_Pattern）]]></title>
      <url>/2016/07/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Observer-Pattern%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>在正式介绍观察者模式前，我们先引用生活中的小例子来模拟观察者，先对观察者模式有一个整体的感觉。</p>
<hr>
<h1 id="现实模拟"><a href="#现实模拟" class="headerlink" title="现实模拟"></a>现实模拟</h1><p>报纸和杂志的故事。<br>我们看看报纸和杂志的订阅是怎么一回事：</p>
<ul>
<li>报纸的任务就是出版报纸</li>
<li>我们向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来，只要你是他们的订户，你就会一直得到新报纸</li>
<li>当你们不想再看报纸的时候，向报社取消订阅，他们就不会再送报纸来，你也不会再收到报纸</li>
<li>只要报社还在运营，就会有人向他们订阅或者取消报纸</li>
</ul>
<p>这其实就可以理解为是一种观察者模式。报社出版者被认为是观察者模式中的<strong>Subject</strong>，订阅报纸的人被认为是观察者模式中的<strong>Observer</strong>。具体的观察者模式的subject和observer我们后面会介绍。</p>
<p>订阅者通常有很多个，他们订阅或者取消需要通知出版者。出版者当报纸有更新时，就会把新报纸一起推送给订阅者，所有订阅者都会收到出版社的所有更新。<br><a id="more"></a><br>再举个常见的例子，我们常见的手机app，网易新闻或者其他类。只要我们安装了这个这个应用，并在app设置接收应用的消息通知，那么当app有新消息通知时，我们就会收到新消息。这里，我们用户就是观察者，app就是Subject。</p>
<h1 id="观察者模式定义"><a href="#观察者模式定义" class="headerlink" title="观察者模式定义"></a>观察者模式定义</h1><p>观察者模式是设计模式中很常用的一个模式。<br>比较严格的解释是：<strong> 观察者模式定义了对象之间的一对多的依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-2fb637cb11200e43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>跟图中的例子一样，主题和观察者定义了一对多的关系。观察者依赖于此主题，只要主题状态一有变化，观察者就会被通知。</p>
<p>观察者模式的类图可以很好的观察者模式的设计思想</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-2efa7665353422e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>观察者的设计方式有很多种，但其中实现Subject和observer接口的设计方式是最常用的、</p>
<p>Subject的接口有三个方法，分别是注册观察者，移除观察者和通知观察者。对象通过Subject接口注册成为观察者，同事也可以通过它从解除观察者的身份，也就是之前例子中的取消订阅报纸。</p>
<p>每个Subject通常可以有很多个观察者</p>
<p>具体的Subject对象需要实现Subject接口的三个方法，其中notify方法是用于当状态发生变化时，来通知观察者update，里面一般要调用观察者接口的update方法。</p>
<p>所有的观察者都需要实现Observer接口，并实现其中的update方法，以便当主题状态发生变化，观察者得到主题的通知。用于Subject具体实现类的notify方法的调用。</p>
<p>具体的Observer都需要继承至接口，同时他们必须注册到具体的Subject对象，以成为一个观察者，并得到更新。</p>
<h1 id="观察者实现的设计原则"><a href="#观察者实现的设计原则" class="headerlink" title="观察者实现的设计原则"></a>观察者实现的设计原则</h1><p><strong> 观察者模式提供了一种对象设计，让主题和观察者之间松耦合 </strong></p>
<p>关于观察者的一切，主题只需要知道观察者实现了某个接口也就是Observer接口，主题不需要知道观察者的具体的实现类是谁，做了些什么或者其他任何细节，主题都不需要知道。</p>
<p>任何时候我们都可以增加新的观察者，因为主题唯一依赖的东西是一个实现Observer接口的对象列表，所以我们可以随时增加观察者。事实上，在运行时我们可以用新的观察者取代现有的观察者，主题不会受任何影响。同样的，也可以在任何时候删除观察者。</p>
<p>当有新的类型的观察者出现时，主题的代码不会发生修改。假如我们有个新的具体类需要当观察者，我们不需要为了兼容新类型而修改主题的代码，所需要的只是在新的类里实现此观察者的接口，然后注册为观察者即可。</p>
<p>这里体现了一个设计原则就是<strong> 为了交互对象之间的松耦合设计而努力 </strong><br>争取让对象之间的互相依赖降到最低</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>我们考虑这样一个问题：实现一个气象站监测应用。</p>
<p>有三个部分，气象站（获取实际气象数据的装置），weatherData对象（追踪来自气象站的数据，并更新布告板）和布告板（显示目前天气的状况给用户看）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-0fc9922595d59552.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>我们要做到的就是建立一个应用，利用weatherdata对象获取数据，并更新三个布告板。<br>我们对气象站的初步设计图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-2658b8a63eb4e396.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>根据观察者设计了一个类图，接下来我们实现这个类图。从建立接口开始，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liu.itf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observers o)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observers o)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liu.itf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observers</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liu.itf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DisplayElement</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来在weatherdata类中实现Subject接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liu.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.liu.itf.Observers;</span><br><span class="line"><span class="keyword">import</span> com.liu.itf.Subject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;Observers&gt; observers;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		observers = <span class="keyword">new</span> ArrayList&lt;Observers&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observers o)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		observers.add(o);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observers o)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">int</span> i = observers.indexOf(o);</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">			observers.remove(o);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;observers.size();i++) &#123;</span><br><span class="line">			Observers observer = (Observers)observers.get(i);</span><br><span class="line">			observer.update(temperature, humidity, pressure);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measurementsChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		notifyObserver();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity,<span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">		<span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">		<span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">		measurementsChanged();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>布告板类作为观察者实现观察者接口和display接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liu.view;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.liu.itf.DisplayElement;</span><br><span class="line"><span class="keyword">import</span> com.liu.itf.Observers;</span><br><span class="line"><span class="keyword">import</span> com.liu.itf.Subject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionDisplay</span> <span class="keyword">implements</span> <span class="title">DisplayElement</span>, <span class="title">Observers</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">	<span class="keyword">private</span> Subject weatherData;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CurrentConditionDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.weatherData = weatherData;</span><br><span class="line">		weatherData.registerObserver(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">this</span>.temperature = temp;</span><br><span class="line">		<span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">		display();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Current conditions: "</span> + temperature + <span class="string">"F degrees and "</span> + humidity + <span class="string">"% humidity"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编写一个测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.liu.model.WeatherData;</span><br><span class="line"><span class="keyword">import</span> com.liu.view.CurrentConditionDisplay;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherStation</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line">		</span><br><span class="line">		CurrentConditionDisplay currentConditionDisplay = <span class="keyword">new</span> CurrentConditionDisplay(weatherData);</span><br><span class="line">		</span><br><span class="line">		weatherData.setMeasurements(<span class="number">80</span>, <span class="number">45</span>, <span class="number">30.4f</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>观察者定义了对象之间一对多的关系。</li>
<li>主题用一个共同的接口来更新观察者</li>
<li>观察者和主题之间用松耦合的方式连接，主题不知道观察者的细节，只知道观察者实现了观察者接口</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之策略模式（Strategy Pattern）]]></title>
      <url>/2016/07/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Strategy-Pattern%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>策略模式，是我们接触到的第一个设计模式，也是较容易理解的一个模式。<br>我们可以给它下一个定义：<br><strong>定义了算法族，分别封装起来，让它们之间可以互相转换，此模式让算法的独立于使用算法的客户</strong><br>维基百科上的定义是：<strong>a software design pattern that enables an algorithm’s behavior to be selected at runtime.</strong><br>维基百科上的强调了算法行为是在运行时决定的，这正是策略模式很关键的一点。<br><a id="more"></a></p>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>假设我们现在要设计一个鸭子类Duck类，然后让不同的鸭子继承于它。我们把目光聚焦到鸭子的行为上。如果我们要给鸭子增加一个行为“fly”，第一个想法，在抽象类duck里添加一个fly方法就可，其余鸭子继承实现这个方法。<br>但是这就出现了一个问题，并不是所有鸭子都会飞，我们反而让一些本不具备这个fly行为的鸭子也具有该行为。那怎么办呢？<br>利用继承来提供鸭子的行为，会导致下面这些后果：</p>
<ul>
<li>代码在多个子类中重复，如果两类不同鸭子需要同一种fly行为，我们就要在两个类里分别覆盖两次，这样万一维护起来是非常困难的</li>
<li>很难知道所有鸭子的全部行为</li>
<li>运行时的行为不容易改变</li>
<li>改变会一发动全身，造成其他鸭子不想要改变</li>
</ul>
<h1 id="设计原则1"><a href="#设计原则1" class="headerlink" title="设计原则1"></a>设计原则1</h1><p>软件开发中，我们常常需要遵守的设计原则是：<br><strong>把可能需要变化的地方独立出来，不要和那些不需要变化的代码混在一起</strong><br>这样代码变化引起的不经意后果变少，系统变得更有弹性<br>实际就是尽量让系统中某部分的改变不影响其他部分的变化。</p>
<p>#提取鸭子的的行为<br>根据设计原则，鸭子飞行的行为会发生变化，所以我们需要将fly行为单独提取出来。同理，我们提取出两个鸭子可能变化的行为fly和quack鸭叫。用两组类分别代表fly和quack行为。</p>
<p>#设计原则2<br>那么我们如何那两组鸭子行为的类呢？这里引出第二个我们提出的设计原则：<br><strong>面对接口编程，而不是面对实现编程</strong><br>这样就可以实现在运行时改变鸭子的行为。<br>我们不会直接指定特定的行为给鸭子。而是声明两个接口FlyBehavior和QuackBehavior。我们制造的其他一系列的类专门来实现FlyBehavior和QuackBehavior，这组就成为行为类，或者算法类。<br>用行为类来实现接口而不是利用duck类来实现。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-7208f93228b27bab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h1 id="实现鸭子的行为"><a href="#实现鸭子的行为" class="headerlink" title="实现鸭子的行为"></a>实现鸭子的行为</h1><p>根据设计原则2，可以让飞行和鸭叫行为的动作被其他对象复用，因为这些为行为已经与鸭子类无关了。<br>而且当我们新增一些行为的时候，不会影响到既有的行为类，也不会影响鸭子类。太棒了！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-d77b3979e9e745bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><strong>很多同学都觉得这里用类来代表行为是不是觉得很奇怪。在大家默认里，类应该是代表某种东西的，类应该拥有状态与行为。这里，我们需要纠正这个观点，一个行为也可以具有各种属性和函数。类不仅仅是用来代表东西事物的。</strong></p>
<h1 id="整合实现我们设计的鸭子类"><a href="#整合实现我们设计的鸭子类" class="headerlink" title="整合实现我们设计的鸭子类"></a>整合实现我们设计的鸭子类</h1><p>首先，在duck类中加入两个实例变量，分别声明为两个接口的类型，每个鸭子对象都会动态的设置这些变量以便在运行时引用正确的行为类型</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-ae6719635af73001.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>duck类的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategyPattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象的Duck类，所有鸭子都继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//为行为接口类型声明两个引用变量，所有鸭子类都继承它们</span></span><br><span class="line">	FlyBehavior flyBehavior;</span><br><span class="line">	QuackBehavior quackBehavior;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlyBehavior</span><span class="params">(FlyBehavior flyBehavior)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.flyBehavior = flyBehavior;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuackBehavior</span><span class="params">(QuackBehavior quackBehavior)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.quackBehavior = quackBehavior;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performFly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		flyBehavior.fly();  <span class="comment">//委托给fly行为类实现</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performQuack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		quackBehavior.quack();  <span class="comment">//委托给quack行为类实现</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//swim是所有鸭子都共同拥有的方法，所以可以直接在在duck类中实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"All ducks float, even decoys!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FlyBehavior接口的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategyPattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有飞行行为类必须实现的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两个fly行为实现类，继承至FlyBehavior接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategyPattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWithWings</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"I'm flying with wings!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategyPattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyNoWay</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"I can't fly!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Quack接口及其三个行为实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategyPattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quack</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Quack"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategyPattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MuteQuack</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"&lt;&lt;silence&gt;&gt;"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategyPattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Squeak</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Squeak"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategyPattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QuackBehavior</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个MallardDuck类继承至Duck类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategyPattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MallardDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MallardDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		quackBehavior = <span class="keyword">new</span> Quack();</span><br><span class="line">		flyBehavior = <span class="keyword">new</span> FlyWithWings();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"I'm a real Mallard duck！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategyPattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniDuckSimulator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Duck mallard = <span class="keyword">new</span> MallardDuck();</span><br><span class="line">		<span class="comment">//这里调用mallardduck继承来的performFly方法，进而委托给该对象的quackBehavior对象处理</span></span><br><span class="line">		<span class="comment">//也就是最后是调用了继承来的quackBehavior引用对象的quack（）方法</span></span><br><span class="line">		mallard.performFly();</span><br><span class="line">		mallard.performQuack();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-97835fcd053cccd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>在这里为了实现动态的改变鸭子的行为，我们可以新建一个flyrocketPowered行为类，然后动态的改变其行为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategyPattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyRocketPowered</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"I'm flying with a rocket "</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategyPattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniDuckSimulator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Duck mallard = <span class="keyword">new</span> MallardDuck();</span><br><span class="line">		<span class="comment">//这里调用mallardduck继承来的performFly方法，进而委托给该对象的quackBehavior对象处理</span></span><br><span class="line">		<span class="comment">//也就是最后是调用了继承来的quackBehavior引用对象的quack（）方法</span></span><br><span class="line">		mallard.performFly();</span><br><span class="line">		mallard.performQuack();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		Duck model = <span class="keyword">new</span> ModelDuck();</span><br><span class="line">		model.performFly();</span><br><span class="line">		model.setFlyBehavior(<span class="keyword">new</span> FlyRocketPowered());</span><br><span class="line">		model.performFly();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-91e9d6a0aab310bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-795767f04b1145bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>每一个鸭子都有一个FlyBehavior和一个quackBehavior，好将飞行和鸭叫委托给他们代为处理。<br>当你将两个类结合起来使用时，如同本例，这就是组合composition。这种做法和继承不同的地方在于，鸭子的行为不是继承来的而是和适当行为对象那个组合来的。<br>设计原则3：<br><strong>多用组合 少用继承</strong></p>
<p>#策略模式总结<br>三个设计原则：</p>
<ul>
<li>封装变化，分开变化与不变</li>
<li>多用组合，少用继承</li>
<li>面向接口编程，而不是面对实现编程</li>
</ul>
<p>策略模式：<br><strong>定义了算法族，分别封装起来，让它们之间可以互相转换，此模式让算法的独立于使用算法的客户。</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-66fd7cb092f950dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>实现策略模式，我们需要对行为或算法实现各自的接口，具体的实现交给继承自这些接口的行为类，不需要在我们的主类鸭子中实现。主类鸭子声明两个接口的引用的实例变量，并设计set方法，这样就能在运行时动态的改变行为。实现独立和复用。</p>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[session和cookies会话机制详解]]></title>
      <url>/2016/07/20/session%E5%92%8Ccookies%E4%BC%9A%E8%AF%9D%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="session-management会话管理的原理"><a href="#session-management会话管理的原理" class="headerlink" title="session management会话管理的原理"></a>session management会话管理的原理</h1><hr>
<p> web请求与响应基于http，而http是无状态协议。所以我们为了跨越多个请求保留用户的状态，需要利用某种工具帮助我们记录与识别每一次请求及请求的其他信息。举个栗子，我们在淘宝购物的时候，首先添加了一本《C++ primer》进入购物车，然后我们又继续去搜索《thinking in java》，继续添加购物车，这时购物车应该有两本书。但如果我们不采取session management会话管理的话，基于http无状态协议，我们在第二次向购物车发出添加请求时，他是无法知道我们第一次添加请求的信息的。所以，我们就需要session management会话管理！</p>
<hr>
<a id="more"></a>
<h2 id="会话管理的基本方式"><a href="#会话管理的基本方式" class="headerlink" title="会话管理的基本方式"></a>会话管理的基本方式</h2><p>会话管理的基本主要有隐藏域，cookies，与URL重写这几种实现方式。用得较多的是后两种。</p>
<hr>
<h3 id="隐藏域实现会话管理"><a href="#隐藏域实现会话管理" class="headerlink" title="隐藏域实现会话管理"></a>隐藏域实现会话管理</h3><p>以一个网络注册信息填写为例。<br>我们在填注册信息的时候，经常遇到填完一个页面的内容之后，还要继续填写下一个页面的内容。但由于http的无状态，那么容易造成的后果，当进入第二页填写的时候，服务器已经不记得我们上一页填写了什么。<br>怎么利用隐藏域解决这个问题呢？<br>顾名思义，其实就是既然服务器不会记得两次请求间的关系，那就由浏览器在每次请求时主动告诉服务器多次请求间的必要信息，但是上一页的信息并不显示在第二页中，而是采用隐藏域的方式。<br>然而显然这种方式是存在各种问题的。<br>比如关掉网页之后，就会遗失信息，而且查看网页源代码时，容易暴露信息，安全性不高。隐藏域并不是servlet/jsp实际会话管理的机制。</p>
<h3 id="cookie实现会话管理"><a href="#cookie实现会话管理" class="headerlink" title="cookie实现会话管理"></a>cookie实现会话管理</h3><p>cookie是什么？举个简单的例子，现在当我们浏览网站的时候，经常会自动保存账号与密码，这样下次访问的时候，就可以直接登录了。这种技术的实现就是利用了cookie技术。<strong> cookie是存储key-value对的一个文件，务必记住，它是由服务器将cookie添加到response里一并返回给客户端，然后客户端会自动把response里的cookie接收下来，并且保存到本地，下次发出请求的时候，就会把cookie附加在request里，服务器在根据request里的cookie遍历搜索是否有与之符合的信息 </strong><br>具体cookie的实现我们会在后面详细讲到</p>
<h3 id="URL重写实现会话管理"><a href="#URL重写实现会话管理" class="headerlink" title="URL重写实现会话管理"></a>URL重写实现会话管理</h3><p>URL重写就是将需要记录的信息附加在请求的链接背后，以链接参数的形式发送给服务器识别。具体实现的过程会在后文结合cookie详解。</p>
<hr>
<h1 id="servlet-amp-jsp中的session会话管理机制"><a href="#servlet-amp-jsp中的session会话管理机制" class="headerlink" title="servlet&amp;jsp中的session会话管理机制"></a>servlet&amp;jsp中的session会话管理机制</h1><p><strong> 利用httpsession对象进行会话管理。httpsession对象可以保存跨同一个客户多个请求的会话状态。</strong></p>
<p>换句话说，与一个特定客户的整个会话期间看，httpsession会持久储存。</p>
<p><strong>对于会话期间客户做的所有请求，从中得到的所有信息都可以用httpsession对象保存。 </strong></p>
<h2 id="httpsession的工作机制"><a href="#httpsession的工作机制" class="headerlink" title="httpsession的工作机制"></a>httpsession的工作机制</h2><ul>
<li>以之前的问卷调查为例，当一个新客户小明填写问卷时，服务器会生成一个httpsession对象，用于保存会话期间小明所选择的信息，服务器会以setAttribute的方式将其保存到httpsession对象中。<br>每个客户会有一个独立的httpsession对象，保存这个客户所有请求所需要保存的信息。</li>
<li>服务器如何识别所有的请求是否来自同一个客户？<br>客户需要一个会话ID来标识自己。就跟我们每个人的身份证号一样。对于客户的第一个请求，容器会生成一个唯一的会话ID，并通过相应把它返回给用户，客户在以后发回一个请求中发回这个会话ID，容器看到ID之后，就会找到匹配的会话，并把这个会话与请求关联。</li>
<li><strong>实现存储会话ID的就是通过cookie！</strong></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1234352-474c42b13e2d470d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>cookie存储在客户端，是被服务器放在response里发回客户端的，以后每次request时，都会把cookie加入到request里。<br>而session是存在服务器的，以属性的形式将会话中的信息存到httpsession对象中。调用时，只要通过httpsession对象调用相应attribute即可。</p>
<ul>
<li><p>很多地方总是把session与cookie分开单独讲。但我们通过前面的介绍，不难知道，session实现其会话管理机制时，在如何确定所有请求是否来自同一个客户时，是利用了cookie技术的。所以不应该将cookie与session完全分开讲。</p>
</li>
<li><p>这里产生这个误解的原因。是因为我们对session的会话管理机制不够了解。因为容器在创建session对象时，会帮我们实现所有cookie相关的工作，而我们只需要实现这一句：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br></pre></td></tr></table></figure>
<p>记住： <strong> 这个方法不只是创建一个会话，而是会完成所有与cookie相关的工作，只是容器都自动帮我们实现了。</strong>我们来看看容器在背后默默为我们做了什么：</p>
<ul>
<li>建立新的httpsession对象</li>
<li>生成唯一的会话ID</li>
<li>建立新的会话对象</li>
<li>把会话ID与cookie关联</li>
<li>在响应中设置cookie</li>
</ul>
<p>cookie所有的工作都在后台进行。<br>看到这里，是不是很爽？容器几乎帮我们实现了所有cookie工作。<br>从请求中得到会话ID<br>只需一行代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br></pre></td></tr></table></figure></p>
<p>与上一部分为响应生成会话ID是一致的<br>其中也在后台实现了一些步骤：<br>if（请求包含一个会话ID）<br>  找到与该ID匹配的会话<br>else if（没有会话ID或者没有匹配的ID）<br>  创建一个新的会话。<br>还是那句话： <strong> cookie所有工作都在后台自动进行 </strong></p>
<h1 id="cookie的更多用处"><a href="#cookie的更多用处" class="headerlink" title="cookie的更多用处"></a>cookie的更多用处</h1><p>cookie原先设计的初衷就是为了帮助支持会话状态。但是因为cookie的简便性，容器为我们封装了大量操作。现在cookie已经被越来越运用到各个方面。<br>首先，<strong> 我们明确cookie是存在客户端的，实际上就是在客户端与服务端交换的一小段数据（一个name/string对）。</strong><br>由于session在用户关闭浏览器后，会话结束，就会消失，cookie随之应该也会消失。但servlet的API中提供了一些方法，可以让客户端的cookie存活的时间更久一点。这就是cookie相对于session的一大优势所在。我们目前常用的记住用户名和密码，下次登录就是利用cookie在session消失后，还能存活实现的。<br>所以，我们可以定制cookie为我们实现各种功能。</p>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
